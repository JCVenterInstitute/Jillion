package org.jcvi.jillion.trace.sff;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
import org.jcvi.jillion.trace.sff.SffFileParserCallback.SffFileMemento;
/**
 * {@code SffFileParser} can parse an SFF
 * binary encoded
 * flowgram file.
 * @author dkatzel
 * @see <a href ="http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=format#sff">SFF file format spec from NCBI</a>
 */
public class SffFileParser {

	private final File sffFile;
	private SffCommonHeader header;
	/**
	 * Create a new instance of {@link SffFileParser}
	 * that will parse the given sff encoded file.
	 * The file isn't actually parsed until
	 * one of the accept methods is called.
	 * @param sffFile the sff file to parse
	 * @throws NullPointerException if sffFile is null.
	 * @throws FileNotFoundException if sffFile does not exist.
	 */
	public SffFileParser(File sffFile) throws FileNotFoundException{
		if(sffFile ==null){
			throw new NullPointerException("sff file can not be null");
		}
		if(!sffFile.exists()){
			throw new FileNotFoundException(String.format("sff file %s does not exist", sffFile.getAbsolutePath()));
		}
		this.sffFile = sffFile;
	}
	/**
	 * Visit the sff file (starting from the beginning)
	 * and call the visit methods on the given visitor.
	 * @param visitor the visitor to call the visit methods on.
	 * @throws IOException if there is a problem parsing the file.
	 * @throws NullPointerException if visitor is null.
	 */
	public void accept(SffFileVisitor visitor) throws IOException{
		if(visitor==null){
			throw new NullPointerException("visitor can not be null");
		}
		InputStream in = null;
		try{
			in = new BufferedInputStream(new FileInputStream(sffFile));
			accept(in, visitor);
		}finally{
			IOUtil.closeAndIgnoreErrors(in);
		}
	}
	/**
	 * Visit the sff file starting from the portion
	 * of the file specified by the given {@link SffFileMemento}.
	 * and call the visit methods on the given visitor.
	 * 
	 * @param visitor the visitor to call the visit methods on.
	 * @param memento the {@link SffFileMemento} instance which will
	 * tell the parser where to start parsing.  Only {@link SffFileMemento}s
	 * generated by this parser instance are valid.
	 * @throws IOException if there is a problem parsing the file.
	 * @throws NullPointerException if visitor is null.
	 */
	public void accept(SffFileVisitor visitor, SffFileMemento memento) throws IOException{
		
		if(!(memento instanceof AbstractSffFileMemento)){
			throw new IllegalArgumentException("don't know how to handle this memento");
		}
		//if the header is null,
		//then we haven't yet parsed the file,
		//therefore we don't have a valid memento
		if(header ==null){
			throw new IllegalStateException("parser has not yet been initialized, must call accept(visitor) method first");
		}
		InputStream in = null;
		RandomAccessFile randomAccessFile =null;
		try{
			
			if(memento instanceof ReadRecordSffFileMemento){
				
				ReadRecordSffFileMemento readRecordSffFileMemento = (ReadRecordSffFileMemento)memento;
				ParserState parserState = new ParserState(readRecordSffFileMemento.getPosition());
				randomAccessFile = new RandomAccessFile(sffFile, "r");
				randomAccessFile.seek(parserState.position);
				in = new BufferedInputStream(new RandomAccessFileInputStream(randomAccessFile));
				DataInputStream dataIn = new DataInputStream(in);
				for(int i=readRecordSffFileMemento.readCount; parserState.keepParsing && i<header.getNumberOfReads(); i++){
					parserState = handleSingleRead(visitor, dataIn, parserState,
							i);
				    
				}
			}else{
				in = new BufferedInputStream(new FileInputStream(sffFile));
				accept(in, visitor);
			}
		}finally{
			IOUtil.closeAndIgnoreErrors(in,randomAccessFile);
		}
	}
	
	
    /**
     * Parse the given {@link InputStream} containing sff encoded
     * data and call the appropriate visitXXX methods on the given visitor.
     * @param in {@link InputStream} containing sff encoded
     * data
     * @param visitor the visitor to visit.
     * @throws SffDecoderException if there is a problem parsing the sff data.
     * @throws NullPointerException if the inputstream or visitor are null.
     */
    private  void accept(InputStream in, SffFileVisitor visitor) throws IOException{
        DataInputStream dataIn = new DataInputStream(in);

        header =DefaultSFFCommonHeaderDecoder.INSTANCE.decodeHeader(dataIn);
        ParserState parserState = new ParserState();
        visitor.visitHeader(createCommonHeaderCallback(parserState), header);
        if(!parserState.keepParsing){
        	return;
        }
        parseReads(visitor, dataIn, header);
        visitor.endSffFile();
        
    }
    
    private SffFileParserCallback createCommonHeaderCallback(final ParserState parserState){
    	return new SffFileParserCallback(){

			@Override
			public boolean mementoSupported() {
				return true;
			}

			@Override
			public SffFileMemento createMemento() {
				return new BeginningSffFileMomento();
			}

			@Override
			public void stopParsing() {
				parserState.stop();				
			}
    		
    	};
    }
	private  void parseReads(SffFileVisitor visitor,
			DataInputStream dataIn, SffCommonHeader commonHeader)
			throws IOException {
		final long numberOfReads = commonHeader.getNumberOfReads();
		
		int keyLength = (int)commonHeader.getKeySequence().getLength();
        int size = 31+commonHeader.getNumberOfFlowsPerRead()+ keyLength;
        int padding =SffUtil.caclulatePaddedBytes(size);
        int commonHeaderLength = size+padding;
        
        ParserState parserState  = new ParserState(commonHeaderLength);
		for(int i=0;parserState.keepParsing && i<numberOfReads; i++){
			parserState = handleSingleRead(visitor, dataIn, parserState,
					i);
		    
		}
	}

	private ParserState handleSingleRead(SffFileVisitor visitor,
			DataInputStream dataIn, ParserState parserState,
			int readCount) throws IOException {
		SffFileParserCallback readHeaderCallback = createReadHeaderCallback(parserState, readCount);
		SffReadHeader readHeader = DefaultSffReadHeaderDecoder.INSTANCE.decodeReadHeader(dataIn);
   
		
		
		SffFileReadVisitor readVisitor = visitor.visitRead(readHeaderCallback, readHeader);
		int unpaddedHeaderLength = 16+readHeader.getId().length();
		int readHeaderPadding = SffUtil.caclulatePaddedBytes(unpaddedHeaderLength);
		int paddedHeaderLength = unpaddedHeaderLength+readHeaderPadding;
		ParserState updatedParserState= parserState.incrementPosition(paddedHeaderLength);
		int numberOfFlowsPerRead = header.getNumberOfFlowsPerRead();
		int readDataLength = SffUtil.getReadDataLength(numberOfFlowsPerRead, readHeader.getNumberOfBases());
		int readDataPadding =SffUtil.caclulatePaddedBytes(readDataLength);
		
		if(readVisitor==null){
			//skip read data	    	
			IOUtil.blockingSkip(dataIn, readDataLength+readDataPadding);		    
		}else{
			final int numberOfBases = readHeader.getNumberOfBases();
			SffReadData readData = DefaultSffReadDataDecoder.INSTANCE.decode(dataIn, numberOfFlowsPerRead, numberOfBases);

			SffFileParserCallback readDataCallback = createReadDataCallback(updatedParserState);
			readVisitor.visitReadData(readDataCallback, readData);
			readVisitor.visitEndOfRead(readDataCallback);
		}
		updatedParserState= updatedParserState.incrementPosition(readDataLength+readDataPadding);
		return updatedParserState;
	}
	
	
	private SffFileParserCallback createReadHeaderCallback(final ParserState parserState,final int readCount){
    	return new SffFileParserCallback(){

			@Override
			public boolean mementoSupported() {
				return true;
			}

			@Override
			public SffFileMemento createMemento() {
				return new ReadRecordSffFileMemento(parserState.position, readCount);
			}

			@Override
			public void stopParsing() {
				parserState.stop();				
			}
    		
    	};
    }
	
	private SffFileParserCallback createReadDataCallback(final ParserState parserState){
    	return new SffFileParserCallback(){

			@Override
			public boolean mementoSupported() {
				return false;
			}

			@Override
			public SffFileMemento createMemento() {
				throw new UnsupportedOperationException("can not create Momento inside of read record"); 
			}

			@Override
			public void stopParsing() {
				parserState.stop();				
			}
    		
    	};
    }
	
	
	private abstract static class AbstractSffFileMemento implements SffFileMemento{
		private final long position;

		public AbstractSffFileMemento(long position) {
			this.position = position;
		}

		public long getPosition() {
			return position;
		}
		
		
	}
	
	private static class ReadRecordSffFileMemento extends AbstractSffFileMemento{
		private final int readCount;
		public ReadRecordSffFileMemento(long position, int readCount) {
			super(position);
			this.readCount = readCount;
		}
		
	}
	
	private static class BeginningSffFileMomento extends AbstractSffFileMemento{

		public BeginningSffFileMomento() {
			super(0L);
		}
		
	}
	
	private static class ParserState{
		private final long position;
		private boolean keepParsing=true;
		
		public ParserState(){
			this(0L);
		}
		public ParserState(long initialPosition){
			this.position = initialPosition;
		}
		private ParserState(long position, boolean keepParsing) {
			this.position = position;
			this.keepParsing = keepParsing;
		}

		public ParserState incrementPosition(long increment){
			return new ParserState(this.position +increment, keepParsing);
		}
		
		public void stop(){
			keepParsing=false;
		}
		
	}
}
