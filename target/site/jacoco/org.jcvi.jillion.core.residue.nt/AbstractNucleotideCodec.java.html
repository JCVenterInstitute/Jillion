<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractNucleotideCodec.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.residue.nt</a> &gt; <span class="el_source">AbstractNucleotideCodec.java</span></div><h1>AbstractNucleotideCodec.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core.residue.nt;

import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.util.iter.SingleElementIterator;
import org.jcvi.jillion.internal.core.io.ValueSizeStrategy;
import org.jcvi.jillion.internal.core.util.GrowableIntArray;


/**
 * Encodes
 * nucleotides as in as few bits as possible
 * plus some extra bytes to store offsets
 * for a special &quot;sentinel&quot; base (usually gaps).  
 * 
 * 
 * This allows quick random access of bases
 * even computing from gapped to ungapped values.
 * 
 * 
 * @author dkatzel
 *
 *
 */
abstract class AbstractNucleotideCodec implements NucleotideCodec{
	private static final int END_OF_ITER = Integer.MIN_VALUE;
<span class="fc" id="L50">        private static final ValueSizeStrategy[] VALUE_SIZE_STRATEGIES = ValueSizeStrategy.values();</span>
		/*
         * Implementation Details:
         * ====================================
         * We store everything as a single byte array which
         * contains a header with the decoded size, and number of gaps as ints.
         * Header
         * byte : ordinal of ValueSizeStrategy
         * 1 -4 bytes: decoded size packed according to valueSizeStrategy
         * byte : ordinal of ValueSizeStrategy for number of gaps
         * 0 -4 bytes: decoded #gaps packed according to valueSizeStrategy.  
         * if previous ordinal of ValueStrategy was for ValueSizeStrategy#NONE
         * then this field is 0 bytes long.
         * 
         * Next, we store gaps offsets (if any)
         * We can use the decoded size to figure out how many
         * bits per offset we need (unsigned). Anything &lt;256 (like a next-gen read)
         * only needs 1 byte while sanger/ small contig consensuses can fit in 2 bytes.
         * 
         * Finally, the rest of the byte array contains the ACGT- basecalls
         * stored as 2bits each.  A gap is recorded here to keep offsets correct.
         * 
         * We can find a basecall by pulling out the gap offsets and seeing if 
         * the offset we want is there.  If so return gap, else compute offset into encoded 
         * byte array for ACGT call and then do bit shifting to get the 2bits we need.
         */
        /**
         * This is the 5th {@link Nucleotide} of our 2 bit encoding
         * usually a &quot;-&quot; or &quot;N&quot;.  These 5th bases will occasionally occur
         * but infrequently enough that we should still use our
         * 2 bit encoding for all sequences.
         */
        private final Nucleotide sententialBase;
<span class="fc" id="L83">        protected AbstractNucleotideCodec(Nucleotide sententialBase){</span>
<span class="fc" id="L84">            this.sententialBase = sententialBase;</span>
<span class="fc" id="L85">        }</span>
        
        protected abstract int getNucleotidesPerGroup();
        
        
       protected abstract Nucleotide getNucleotide(byte encodedByte, int index);
       
       private ByteBuffer getBufferToComputeNumberOfGapsOnly(byte[] encodedBytes){
	    	//at most we only need the first 12 bytes
	    	//there is no need to wrap the entire array
<span class="fc" id="L95">	    	return ByteBuffer.wrap(encodedBytes,0, Math.min(encodedBytes.length, 12));</span>
			
	    }
       /**
	    * {@inheritDoc}
	    */
	    @Override
	    public int getUngappedOffsetFor(byte[] encodedGlyphs, int gappedOffset) {
<span class="fc" id="L103">	        int numGaps=getNumberOfGapsUntil(encodedGlyphs,gappedOffset);</span>
<span class="fc" id="L104">	        return gappedOffset-numGaps;</span>
	    }
	    /**
	    * {@inheritDoc}
	    */
	    @Override
	    public int getGappedOffsetFor(byte[] encodedGlyphs, int ungappedOffset) {
<span class="fc" id="L111">	    	int currentOffset=ungappedOffset;</span>
<span class="fc" id="L112">	    	ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L113">			ValueSizeStrategy offsetStrategy = ValueSizeStrategy.values()[buf.get()];</span>
	        //need to skip length since we don't care about it
			//but need to read it to advance pointer in buffer
<span class="fc" id="L116">			offsetStrategy.getNext(buf);</span>
<span class="fc" id="L117">	        ValueSizeStrategy sentinelStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
            	//no gaps
<span class="nc" id="L120">            	return currentOffset;</span>
            }
<span class="fc" id="L122">            int numberOfSentinels = sentinelStrategy.getNext(buf);</span>
            
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for(int i = 0; i&lt; numberOfSentinels; i++, currentOffset++){</span>
<span class="fc" id="L125">            	int currentGapOffset =offsetStrategy.getNext(buf);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            	if(currentGapOffset &gt;currentOffset){</span>
<span class="fc" id="L127">                	return currentOffset;</span>
                }
            }
<span class="fc" id="L130">            return currentOffset;</span>
	    }
       /**
	    * {@inheritDoc}
	    */
	    @Override
	    public boolean isGap(byte[] encodedGlyphs, int gappedOffset) {
<span class="fc" id="L137">	    	ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L138">			ValueSizeStrategy offsetStrategy = ValueSizeStrategy.values()[buf.get()];</span>
	        //need to skip length since we don't care about it
			//but need to read it to advance pointer in buffer
<span class="fc" id="L141">			offsetStrategy.getNext(buf);</span>
<span class="fc" id="L142">	        ValueSizeStrategy sentinelStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
            	//no gaps
<span class="nc" id="L145">            	return false;</span>
            }
<span class="fc" id="L147">            int numberOfSentinels = sentinelStrategy.getNext(buf);</span>
            
<span class="fc" id="L149">            int firstGapOffset =offsetStrategy.getNext(buf);            </span>
            
            //special case that first gap is after the offset we care about
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if(firstGapOffset &gt;gappedOffset){</span>
<span class="fc" id="L153">            	return false;</span>
            }
            //actually need to check the gap offset
            //since we don't want to skip it!
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if(firstGapOffset == gappedOffset){</span>
<span class="fc" id="L158">            	return true;</span>
            }
<span class="fc" id="L160">            int currentGapOffset = firstGapOffset;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            for(int i = 1; i&lt; numberOfSentinels; i++){</span>
<span class="fc" id="L162">            	currentGapOffset =offsetStrategy.getNext(buf);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            	if(currentGapOffset == gappedOffset){</span>
            		//found it
<span class="fc" id="L165">            		return true;</span>
            	}
<span class="fc bfc" id="L167" title="All 2 branches covered.">            	if(currentGapOffset &gt;gappedOffset){</span>
            		//past it
<span class="fc" id="L169">            		return false;</span>
            	}
            }
            //we checked all the gap offsets
            //and didn't find a match
            //so it must be not a gap
<span class="fc" id="L175">            return false;</span>
	    }
       /**
	    * {@inheritDoc}
	    */
	    @Override
	    public long getUngappedLength(byte[] encodedGlyphs) {
<span class="nc" id="L182">	    	ByteBuffer buf = getBufferToComputeNumberOfGapsOnly(encodedGlyphs);</span>
<span class="nc" id="L183">			ValueSizeStrategy offsetStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="nc" id="L184">	        int length =offsetStrategy.getNext(buf);</span>
<span class="nc" id="L185">	        ValueSizeStrategy sentinelStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">	        if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
	        	//no gaps
<span class="nc" id="L188">	        	return length;</span>
	        }
<span class="nc" id="L190">	        int numGaps= sentinelStrategy.getNext(buf);</span>
<span class="nc" id="L191">	        return length-numGaps;</span>
	    }
       /**
	    * {@inheritDoc}
	    */
	    @Override
	    public int getNumberOfGaps(byte[] encodedGlyphs) {
<span class="fc" id="L198">	    	ByteBuffer buf = getBufferToComputeNumberOfGapsOnly(encodedGlyphs);</span>
<span class="fc" id="L199">			ValueSizeStrategy offsetStrategy = ValueSizeStrategy.values()[buf.get()];</span>
	        //need to read the next few bytes even though we
			//don't care what the size is
<span class="fc" id="L202">			offsetStrategy.getNext(buf);</span>
<span class="fc" id="L203">	        ValueSizeStrategy sentinelStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">	        if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
<span class="fc" id="L205">	        	return 0;</span>
	        }
<span class="fc" id="L207">	        return sentinelStrategy.getNext(buf);</span>
	    }
        
		
		
	    protected GrowableIntArray getSentinelOffsets(byte[] encodedGlyphs){
<span class="fc" id="L213">	    	ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L214">			ValueSizeStrategy offsetStrategy = ValueSizeStrategy.values()[buf.get()];</span>
	        //need to skip length since we don't care about it
			//but need to read it to advance pointer in buffer
<span class="fc" id="L217">			offsetStrategy.getNext(buf);</span>
<span class="fc" id="L218">			ValueSizeStrategy sentinelStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">            if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
<span class="nc" id="L220">            	return new GrowableIntArray();</span>
        	}else{            	
            	//there are sentinels
<span class="fc" id="L223">            	int numberOfSentinels = sentinelStrategy.getNext(buf);</span>
<span class="fc" id="L224">            	GrowableIntArray sentinelOffsets = new GrowableIntArray(numberOfSentinels);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            	for(int i = 0; i&lt; numberOfSentinels; i++){</span>
<span class="fc" id="L226">            		sentinelOffsets.append(offsetStrategy.getNext(buf));            	</span>
            	}
<span class="fc" id="L228">            	return sentinelOffsets;</span>
            }
	    }
	    
		@Override
		public int getNumberOfGapsUntil(byte[] encodedGlyphs, int gappedOffset) {
<span class="fc" id="L234">			ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L235">			ValueSizeStrategy offsetStrategy = ValueSizeStrategy.values()[buf.get()];</span>
	        //need to skip length since we don't care about it
			//but need to read it to advance pointer in buffer
<span class="fc" id="L238">			offsetStrategy.getNext(buf);</span>
<span class="fc" id="L239">	        ValueSizeStrategy sentinelStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
            	//no gaps
<span class="fc" id="L242">            	return 0;</span>
            }
<span class="fc" id="L244">            int numberOfSentinels = sentinelStrategy.getNext(buf);</span>

<span class="fc bfc" id="L246" title="All 2 branches covered.">            for(int i = 0; i&lt; numberOfSentinels; i++){</span>
<span class="fc" id="L247">            	int currentGapOffset =offsetStrategy.getNext(buf);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            	if(currentGapOffset &gt;gappedOffset){</span>
            		//we found 
<span class="fc" id="L250">            		return i;</span>
            	}
            }
<span class="fc" id="L253">			return numberOfSentinels;</span>
		}
        
       
        @Override
        public Nucleotide decode(byte[] encodedGlyphs, long index){
<span class="fc bfc" id="L259" title="All 2 branches covered.">        	if(index &lt;0){</span>
<span class="fc" id="L260">        		throw new IndexOutOfBoundsException(String.format(&quot;offset %d can not be negative &quot;, index));</span>
        	}
<span class="fc" id="L262">        	ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L263">            ValueSizeStrategy offsetStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="fc" id="L264">            int length=offsetStrategy.getNext(buf);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if(index &gt;=length){</span>
<span class="fc" id="L266">            	throw new IndexOutOfBoundsException(String.format(&quot;offset %d is &gt;= length (%d)&quot;, index,length));</span>
            }
<span class="fc bfc" id="L268" title="All 2 branches covered.">            if(isSentinelOffset(buf,offsetStrategy,(int)index)){</span>
<span class="fc" id="L269">            	return sententialBase;</span>
            }
<span class="fc" id="L271">            int currentPosition =buf.position();</span>
<span class="fc" id="L272">            int bytesToSkip = (int)(index/getNucleotidesPerGroup());</span>
<span class="fc" id="L273">            buf.position(currentPosition+ bytesToSkip);</span>

<span class="fc" id="L275">            int indexIntoByte = (int)(index%getNucleotidesPerGroup());</span>
<span class="fc" id="L276">            return getNucleotide(buf.get(), indexIntoByte);</span>
        
        }
        private boolean isSentinelOffset(ByteBuffer buf, ValueSizeStrategy offsetStrategy, int index) {
<span class="fc" id="L280">        	ValueSizeStrategy sentinelStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        	if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
<span class="fc" id="L282">        		return false;</span>
        	}
<span class="fc" id="L284">        	int numberOfSentinels = sentinelStrategy.getNext(buf);</span>
<span class="fc" id="L285">        	int nextSentinelOffset= Integer.MIN_VALUE;</span>
        	//offsets are sorted so if we get to
        	//the desired index we can short circuit the for loop.
        	//we can't do a binarysearch very easily
        	//because the offsets are packed many into 
        	//one byte so we would have to read them all
        	//in O(n) anyway.
        	//it is also important that if we 
        	//don't find the sentinel value
        	//that the buffer has advanced to the end of the
        	//section so we can start getting 
        	//the other basecalls.
<span class="fc bfc" id="L297" title="All 2 branches covered.">        	for(int i = 0; i&lt; numberOfSentinels; i++){</span>
<span class="fc" id="L298">        		nextSentinelOffset = offsetStrategy.getNext(buf);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">				if(index ==nextSentinelOffset){</span>
<span class="fc" id="L300">        			return true;</span>
        		}
        	}
        	
<span class="fc" id="L304">			return false;</span>
		}
		
       

        @Override
		public byte[] encode(int numberOfNucleotides, int[] gapOffsets,
				Iterator&lt;Nucleotide&gt; nucleotides) {
<span class="fc" id="L312">        	 return encodeNucleotides(nucleotides, gapOffsets, numberOfNucleotides);</span>
		}
		
        /**
         * Convenience method to encode a single basecall.
         * @param nt the Nucleotide to encode; can not be null.
         * @return the encoded nucleotide
         * 
         * @throws NullPointerException if nt is null.
         */
        @Override
        public byte[] encode(Nucleotide nt) {
        	final int gapOffsets[];
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        	if(nt.isGap()){</span>
<span class="nc" id="L326">        		gapOffsets = new int[]{0};</span>
        	}else{
<span class="fc" id="L328">        		gapOffsets = new int[0];</span>
        	}
<span class="fc" id="L330">            return encodeNucleotides(new SingleElementIterator&lt;&gt;(nt), gapOffsets, 1);</span>
            
        }
        
        public int getNumberOfEncodedBytesFor(int totalLength, int numberOfSentinelValues){
<span class="fc" id="L335">        	int encodedBasesSize = computeHeaderlessEncodedSize(totalLength);</span>
<span class="fc" id="L336">        	ValueSizeStrategy numBasesSizeStrategy = ValueSizeStrategy.getStrategyFor(totalLength);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            ValueSizeStrategy sentinelSizeStrategy = numberOfSentinelValues==0</span>
            											?	ValueSizeStrategy.NONE 
<span class="fc" id="L339">            											:	ValueSizeStrategy.getStrategyFor(numberOfSentinelValues);</span>
<span class="fc" id="L340">            return computeEncodedBufferSize(encodedBasesSize,</span>
					numBasesSizeStrategy, numberOfSentinelValues,
					sentinelSizeStrategy);
        }
        
        private byte[] encodeNucleotides(Iterator&lt;Nucleotide&gt; iterator, int[] sentienelOffsetArray,
                final int unEncodedSize) {
<span class="fc" id="L347">            int encodedBasesSize = computeHeaderlessEncodedSize(unEncodedSize);</span>
<span class="fc" id="L348">            ByteBuffer encodedBases = ByteBuffer.allocate(encodedBasesSize);</span>
<span class="fc" id="L349">            encodeAll(iterator, unEncodedSize, encodedBases);</span>
<span class="fc" id="L350">            encodedBases.flip();</span>
<span class="fc" id="L351">            ValueSizeStrategy numBasesSizeStrategy = ValueSizeStrategy.getStrategyFor(unEncodedSize);</span>
<span class="fc" id="L352">            int numberOfSentinels = sentienelOffsetArray.length;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">			ValueSizeStrategy sentinelSizeStrategy = numberOfSentinels==0</span>
            											?	ValueSizeStrategy.NONE 
<span class="fc" id="L355">            											:	ValueSizeStrategy.getStrategyFor(numberOfSentinels);</span>
            
<span class="fc" id="L357">            int bufferSize = computeEncodedBufferSize(encodedBasesSize,</span>
					numBasesSizeStrategy, numberOfSentinels,
					sentinelSizeStrategy);
            
<span class="fc" id="L361">            ByteBuffer result = ByteBuffer.allocate(bufferSize);</span>
<span class="fc" id="L362">            result.put((byte)numBasesSizeStrategy.ordinal());</span>
<span class="fc" id="L363">            numBasesSizeStrategy.put(result, unEncodedSize);</span>
<span class="fc" id="L364">            result.put((byte)sentinelSizeStrategy.ordinal());</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if(sentinelSizeStrategy != ValueSizeStrategy.NONE){</span>
<span class="fc" id="L366">            	sentinelSizeStrategy.put(result, numberOfSentinels);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            	for(int i=0; i&lt;numberOfSentinels; i++){</span>
<span class="fc" id="L368">            		numBasesSizeStrategy.put(result, sentienelOffsetArray[i]);</span>
                }
            }
<span class="fc" id="L371">            result.put(encodedBases);</span>
<span class="fc" id="L372">            return result.array();</span>
        }
        
        
        
		private static int computeEncodedBufferSize(int encodedBasesSize,
				ValueSizeStrategy numBasesSizeStrategy, int numberOfSentinels,
				ValueSizeStrategy sentinelSizeStrategy) {
<span class="fc" id="L380">			int bufferSize = 2 + numBasesSizeStrategy.getNumberOfBytesPerValue() + sentinelSizeStrategy.getNumberOfBytesPerValue()</span>
<span class="fc" id="L381">            		+ numBasesSizeStrategy.getNumberOfBytesPerValue() * numberOfSentinels + encodedBasesSize;</span>
<span class="fc" id="L382">			return bufferSize;</span>
		}
        /**
         * pack every 4 nucleotides into a single byte.
         * @param glyphs
         * @param unEncodedSize
         * @param result
         */
        private void encodeAll(Iterator&lt;Nucleotide&gt; glyphs,
                final int unEncodedSize, ByteBuffer result) {
        	
<span class="fc" id="L393">            int groupSize = getNucleotidesPerGroup();</span>
            //create variable i outside of for loop
            //so it can be used afterwards
<span class="fc" id="L396">            int i=0;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">			for(; i&lt;unEncodedSize-groupSize; i+=groupSize){</span>
<span class="fc" id="L398">				encodeCompleteGroup(glyphs, result,i);</span>
            }
			//need this check incase we are empty
<span class="fc bfc" id="L401" title="All 2 branches covered.">			if(i&lt;unEncodedSize){</span>
<span class="fc" id="L402">				encodeLastGroup(glyphs, result,i);</span>
			}
<span class="fc" id="L404">        }</span>
       
        protected int computeHeaderlessEncodedSize(final int size) {
<span class="fc" id="L407">            return (size+3)/getNucleotidesPerGroup();</span>
        }
       
        
        protected abstract byte getByteFor(Nucleotide nuc);
        
        protected abstract Nucleotide getGlyphFor(byte b);
       
        protected abstract void encodeCompleteGroup(Iterator&lt;Nucleotide&gt; glyphs, ByteBuffer result, int offset);
        
        protected abstract void encodeLastGroup(Iterator&lt;Nucleotide&gt; glyphs, ByteBuffer result, int offset);
     
        protected byte getSentienelByteFor(Nucleotide nucleotide){
<span class="fc bfc" id="L420" title="All 2 branches covered.">            if(nucleotide.equals(sententialBase)){</span>
<span class="fc" id="L421">                return 0;</span>
            }
<span class="fc" id="L423">            return getByteFor(nucleotide);</span>
        }
        @Override
        public int decodedLengthOf(byte[] encodedGlyphs) {
<span class="fc" id="L427">            ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L428">            return VALUE_SIZE_STRATEGIES[buf.get()].getNext(buf);</span>
        }
		@Override
		public Iterator&lt;Nucleotide&gt; iterator(byte[] encodedData) {
<span class="fc" id="L432">			return new IteratorImpl(encodedData);</span>
		}
		
		@Override
		public Iterator&lt;Nucleotide&gt; iterator(byte[] encodedData, Range range) {
<span class="fc" id="L437">			return new IteratorImpl(encodedData, range);</span>
		}
		@Override
		public String toString(byte[] encodedData) {
<span class="fc" id="L441">			IteratorImpl iter = (IteratorImpl)iterator(encodedData);</span>
<span class="fc" id="L442">			StringBuilder builder = new StringBuilder(iter.getLength());</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">			while(iter.hasNext()){</span>
<span class="fc" id="L444">				builder.append(iter.next());</span>
			}
<span class="fc" id="L446">			return builder.toString();</span>
		}

		private final class IteratorImpl implements Iterator&lt;Nucleotide&gt;{
			
			private final int length;
			private final int[] sentinelArray;
<span class="fc" id="L453">			private final int numberOfBasesPerGroup = getNucleotidesPerGroup();</span>
			private int nextSentinel;
<span class="fc" id="L455">			private int currentOffset=0;</span>
<span class="fc" id="L456">			private int sentinelIndex=0;</span>
			private final byte[] encodedBytes;
			
<span class="fc" id="L459">			public IteratorImpl(byte[] encodedGlyphs){</span>
<span class="fc" id="L460">				ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L461">				ValueSizeStrategy offsetStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="fc" id="L462">	            this.length =offsetStrategy.getNext(buf);</span>
<span class="fc" id="L463">	            this.sentinelArray = parseSentinelOffsetsIteratorFrom(buf,offsetStrategy);</span>
<span class="fc" id="L464">	            this.encodedBytes =new byte[buf.remaining()];</span>
<span class="fc" id="L465">	            buf.get(encodedBytes);</span>
<span class="fc" id="L466">	            this.nextSentinel = getNextSentinel();	           </span>
<span class="fc" id="L467">			}</span>
			
<span class="fc" id="L469">			public IteratorImpl(byte[] encodedGlyphs, Range range){</span>
<span class="fc" id="L470">				ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="fc" id="L471">				ValueSizeStrategy offsetStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
<span class="fc" id="L472">	            int sequenceLength =offsetStrategy.getNext(buf);</span>
<span class="fc bfc" id="L473" title="All 4 branches covered.">	            if(range.getBegin()&lt;0 || range.getEnd()&gt;=sequenceLength){</span>
<span class="fc" id="L474">					throw new IndexOutOfBoundsException(&quot;range &quot;+range +&quot; is out of range of sequence which is only &quot;+ new Range.Builder(sequenceLength).build());</span>
				}
<span class="fc" id="L476">	            this.length = (int)range.getEnd()+1;</span>
<span class="fc" id="L477">	            this.sentinelArray = parseSentinelOffsetsIteratorFrom(buf,offsetStrategy);</span>
<span class="fc" id="L478">	            this.nextSentinel = getNextSentinel();</span>
<span class="fc" id="L479">	            currentOffset = (int)range.getBegin();</span>
<span class="fc bfc" id="L480" title="All 4 branches covered.">	            while(nextSentinel!=END_OF_ITER &amp;&amp; nextSentinel &lt; currentOffset){</span>
<span class="fc" id="L481">	            	this.nextSentinel = getNextSentinel();</span>
	            }
<span class="fc" id="L483">	            this.encodedBytes =new byte[buf.remaining()];</span>
<span class="fc" id="L484">	            buf.get(encodedBytes);</span>
	           	           
<span class="fc" id="L486">			}</span>
			
			public int getLength() {
<span class="fc" id="L489">				return length;</span>
			}

			private int[] parseSentinelOffsetsIteratorFrom(
					ByteBuffer buf, ValueSizeStrategy offsetStrategy) {
<span class="fc" id="L494">				ValueSizeStrategy sentinelStrategy = VALUE_SIZE_STRATEGIES[buf.get()];</span>
	            //no sentinels (no gaps or N's)
<span class="fc bfc" id="L496" title="All 2 branches covered.">	            if(sentinelStrategy == ValueSizeStrategy.NONE){</span>
<span class="fc" id="L497">	            	return new int[0];</span>
	            }else{            	
<span class="fc" id="L499">	            	int numberOfSentinels = sentinelStrategy.getNext(buf);</span>
	            	//
<span class="fc" id="L501">	            	int[] sentinelArray = new int[numberOfSentinels];</span>
	            	
<span class="fc bfc" id="L503" title="All 2 branches covered.">	            	for(int i = 0; i&lt; numberOfSentinels; i++){</span>
<span class="fc" id="L504">	            		sentinelArray[i] =offsetStrategy.getNext(buf);</span>
	            	}
<span class="fc" id="L506">	            	return sentinelArray;</span>
	            }
			}
			
			private int getNextSentinel() {
<span class="fc bfc" id="L511" title="All 2 branches covered.">				if(sentinelIndex&gt;= sentinelArray.length){</span>
<span class="fc" id="L512">					return END_OF_ITER;</span>
				}
<span class="fc" id="L514">				return sentinelArray[sentinelIndex++];</span>
			}
			@Override
			public boolean hasNext() {
<span class="fc bfc" id="L518" title="All 2 branches covered.">				return currentOffset&lt;length;</span>
			}

			@Override
			public Nucleotide next() {
<span class="fc bfc" id="L523" title="All 2 branches covered.">				if(!hasNext()){</span>
<span class="fc" id="L524">					throw new NoSuchElementException(&quot;no more elements&quot;);</span>
				}
<span class="fc bfc" id="L526" title="All 2 branches covered.">				if(nextSentinel == currentOffset){</span>
<span class="fc" id="L527">            		nextSentinel = getNextSentinel();</span>
<span class="fc" id="L528">            		currentOffset++;</span>
<span class="fc" id="L529">            		return sententialBase;</span>
				}
<span class="fc" id="L531">				int arrayoffset = currentOffset/numberOfBasesPerGroup;</span>
<span class="fc" id="L532">				int groupIndex = currentOffset%numberOfBasesPerGroup;</span>
<span class="fc" id="L533">				Nucleotide next= getNucleotide(encodedBytes[arrayoffset], groupIndex);</span>
<span class="fc" id="L534">				currentOffset++;</span>
<span class="fc" id="L535">				return next;</span>
			}

			@Override
			public void remove() {
<span class="nc" id="L540">				throw new UnsupportedOperationException(&quot;can not modify immutable sequence&quot;);</span>
				
				
			}
			
		}
        
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>