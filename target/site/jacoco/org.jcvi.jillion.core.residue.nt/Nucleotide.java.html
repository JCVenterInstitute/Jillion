<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Nucleotide.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.residue.nt</a> &gt; <span class="el_source">Nucleotide.java</span></div><h1>Nucleotide.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 14, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.residue.nt;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jcvi.jillion.core.residue.Residue;
/**
 * {@code Nucleotide} is a {@link Residue}
 * implementation for DNA Nucleotides.
 * @author dkatzel
 *
 *
 */
<span class="pc" id="L46">public enum Nucleotide implements Residue {</span>
    //order is in ambiguity traversal order that is most efficient.
<span class="fc" id="L48">    Unknown(Character.valueOf('N')),</span>
<span class="fc" id="L49">    NotThymine(Character.valueOf('V')),</span>
<span class="fc" id="L50">    NotGuanine(Character.valueOf('H')),</span>
<span class="fc" id="L51">    NotCytosine(Character.valueOf('D')),</span>
<span class="fc" id="L52">    NotAdenine(Character.valueOf('B')),</span>
<span class="fc" id="L53">    Weak(Character.valueOf('W')),</span>
<span class="fc" id="L54">    Amino(Character.valueOf('M')),   </span>
<span class="fc" id="L55">    Purine(Character.valueOf('R')),</span>
<span class="fc" id="L56">    Strong(Character.valueOf('S')),  </span>
<span class="fc" id="L57">    Pyrimidine(Character.valueOf('Y')),   </span>
<span class="fc" id="L58">    Keto(Character.valueOf('K')),    </span>
<span class="fc" id="L59">    Gap(Character.valueOf('-')),</span>
<span class="fc" id="L60">    Adenine(Character.valueOf('A')),</span>
<span class="fc" id="L61">    Cytosine(Character.valueOf('C')),</span>
<span class="fc" id="L62">    Guanine(Character.valueOf('G')),</span>
<span class="fc" id="L63">    Thymine(Character.valueOf('T')),</span>
    
    ;

    private static final Map&lt;Nucleotide,Set&lt;Nucleotide&gt;&gt; AMBIGUITY_TO_CONSTIUENT;
    private static final Map&lt;Nucleotide,Set&lt;Nucleotide&gt;&gt; CONSTIUENT_TO_AMBIGUITY;
   
    //42 - 121
<span class="fc" id="L71">    private static Nucleotide[] CACHE = new Nucleotide[80];</span>
    
<span class="fc" id="L73">    private static final Nucleotide[] VALUES_ARRAY = values();</span>
<span class="fc" id="L74">    public static final List&lt;Nucleotide&gt; VALUES = Collections.unmodifiableList(Arrays.asList(VALUES_ARRAY));</span>
    static{
        
       
<span class="fc" id="L78">        AMBIGUITY_TO_CONSTIUENT = new EnumMap&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt;(Nucleotide.class);</span>
       
<span class="fc" id="L80">        AMBIGUITY_TO_CONSTIUENT.put(Unknown, EnumSet.of(Adenine,Cytosine,Guanine,Thymine));</span>
<span class="fc" id="L81">        AMBIGUITY_TO_CONSTIUENT.put(NotThymine, EnumSet.of(Adenine,Cytosine,Guanine));</span>
<span class="fc" id="L82">        AMBIGUITY_TO_CONSTIUENT.put(NotGuanine, EnumSet.of(Adenine,Cytosine,Thymine));</span>
<span class="fc" id="L83">        AMBIGUITY_TO_CONSTIUENT.put(NotCytosine, EnumSet.of(Adenine,Guanine,Thymine));</span>
<span class="fc" id="L84">        AMBIGUITY_TO_CONSTIUENT.put(NotAdenine, EnumSet.of(Cytosine,Guanine,Thymine));</span>
        
<span class="fc" id="L86">        AMBIGUITY_TO_CONSTIUENT.put(Weak, EnumSet.of(Adenine,Thymine));</span>
<span class="fc" id="L87">        AMBIGUITY_TO_CONSTIUENT.put(Amino, EnumSet.of(Adenine,Cytosine));</span>
        
<span class="fc" id="L89">        AMBIGUITY_TO_CONSTIUENT.put(Purine, EnumSet.of(Adenine,Guanine));</span>
<span class="fc" id="L90">        AMBIGUITY_TO_CONSTIUENT.put(Strong, EnumSet.of(Cytosine,Guanine));</span>
        
<span class="fc" id="L92">        AMBIGUITY_TO_CONSTIUENT.put(Pyrimidine, EnumSet.of(Cytosine,Thymine));</span>
<span class="fc" id="L93">        AMBIGUITY_TO_CONSTIUENT.put(Keto, EnumSet.of(Guanine,Thymine));</span>
        
<span class="fc" id="L95">        AMBIGUITY_TO_CONSTIUENT.put(Adenine, EnumSet.of(Adenine));</span>
<span class="fc" id="L96">        AMBIGUITY_TO_CONSTIUENT.put(Cytosine, EnumSet.of(Cytosine));</span>
<span class="fc" id="L97">        AMBIGUITY_TO_CONSTIUENT.put(Guanine, EnumSet.of(Guanine));</span>
<span class="fc" id="L98">        AMBIGUITY_TO_CONSTIUENT.put(Thymine, EnumSet.of(Thymine));</span>

        
<span class="fc" id="L101">        CONSTIUENT_TO_AMBIGUITY = new EnumMap&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt;(Nucleotide.class);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        for(Nucleotide n : EnumSet.of(Adenine,Cytosine,Guanine,Thymine)){</span>
<span class="fc" id="L103">            CONSTIUENT_TO_AMBIGUITY.put(n, EnumSet.noneOf(Nucleotide.class));</span>
<span class="fc" id="L104">        }</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for(Entry&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt; entry : AMBIGUITY_TO_CONSTIUENT.entrySet()){</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            for(Nucleotide n : entry.getValue()){</span>
<span class="fc" id="L107">                final Nucleotide toAdd = entry.getKey();</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                if(toAdd != n){</span>
<span class="fc" id="L109">                    CONSTIUENT_TO_AMBIGUITY.get(n).add(toAdd);</span>
                }
<span class="fc" id="L111">            }</span>
<span class="fc" id="L112">        }</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for(Nucleotide value : VALUES_ARRAY){</span>
<span class="fc" id="L114">        	char uppercase = value.c.charValue();</span>
        	
<span class="fc" id="L116">        	char lowercase = Character.toLowerCase(uppercase);</span>
        	
<span class="fc" id="L118">        	CACHE[computeOffsetFor(uppercase)] = value;</span>
<span class="fc" id="L119">        	CACHE[computeOffsetFor(lowercase)] = value;</span>
        }
        //add consed gap
<span class="fc" id="L122">        CACHE[computeOffsetFor('*')] = Gap;</span>
        //treat X's as Ns
<span class="fc" id="L124">        CACHE[computeOffsetFor('x')] = Unknown;</span>
<span class="fc" id="L125">        CACHE[computeOffsetFor('X')] = Unknown;</span>
        
<span class="fc" id="L127">    }</span>
    
  
    private static int computeOffsetFor(char c){
<span class="fc" id="L131">    	return c-42;</span>
    }
  
    
    private final Character c;
    
<span class="fc" id="L137">    private Nucleotide(Character c){</span>
<span class="fc" id="L138">        this.c = c;</span>
<span class="fc" id="L139">    }</span>
    /**
     * Return the Character equivalent of this
     * {@link Nucleotide}.  For example
     * calling this method for {@link #Adenine}
     * will return 'A'.
     * @return the Character equivalent of this.
     */
    @Override
    public Character getCharacter() {
<span class="fc" id="L149">        return c;</span>
    }

    /**
     * Get the complement this {@link Nucleotide}.
     * @return the complement of this.
     */
    public Nucleotide complement() {
<span class="fc" id="L157">    	Nucleotide ret=null;</span>
<span class="pc bpc" id="L158" title="1 of 17 branches missed.">    	switch(this){</span>
<span class="fc" id="L159">    		case Unknown : ret = Unknown;</span>
<span class="fc" id="L160">							break;</span>
<span class="fc" id="L161">    		case NotThymine : ret = NotAdenine;</span>
<span class="fc" id="L162">    						break;</span>
<span class="fc" id="L163">    		case NotGuanine : ret = NotCytosine;</span>
<span class="fc" id="L164">    						break;</span>
<span class="fc" id="L165">    		case NotCytosine : ret = NotGuanine;</span>
<span class="fc" id="L166">								break;</span>
<span class="fc" id="L167">    		case NotAdenine : ret = NotThymine;</span>
<span class="fc" id="L168">							break; </span>
<span class="fc" id="L169">    		case Weak : ret = Weak;</span>
<span class="fc" id="L170">								break; 		</span>
<span class="fc" id="L171">    		case Amino : ret = Keto;</span>
<span class="fc" id="L172">							break; </span>
<span class="fc" id="L173">    		case Purine : ret = Pyrimidine;</span>
<span class="fc" id="L174">								break; </span>
<span class="fc" id="L175">    		case Strong : ret = Strong;</span>
<span class="fc" id="L176">							break; </span>
<span class="fc" id="L177">    		case Pyrimidine : ret = Purine;</span>
<span class="fc" id="L178">							break; </span>
<span class="fc" id="L179">    		case Keto : ret = Amino;</span>
<span class="fc" id="L180">							break; </span>
<span class="fc" id="L181">    		case Gap : ret = Gap;</span>
<span class="fc" id="L182">							break;				</span>
<span class="fc" id="L183">    		case Adenine : ret = Thymine;</span>
<span class="fc" id="L184">    						break;</span>
<span class="fc" id="L185">    		case Cytosine : ret = Guanine;</span>
<span class="fc" id="L186">								break;</span>
<span class="fc" id="L187">    		case Guanine : ret = Cytosine;</span>
<span class="fc" id="L188">								break;</span>
<span class="fc" id="L189">    		case Thymine : ret = Adenine;</span>
<span class="fc" id="L190">    						break;</span>
			default : //can't happen 
<span class="nc" id="L192">				throw new IllegalStateException(&quot;a new nucleotide ordinal has been added&quot; + this);</span>
    	}
<span class="fc" id="L194">       return ret;</span>
    }
    
    /**
     * Get the {@link Nucleotide} for the given
     * String  representation.  If the given String is more than
     * one character long, only the first character will be considered.
     * For example,
     * {@link #parse(String) parse(&quot;A&quot;)} will return
     * {@link #Adenine}. This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param base the nucleotide as a String of length 1.
     * @return a {@link Nucleotide} equivalent.
     * @throws IllegalArgumentException if the given
     * character can not be mapped to a {@link Nucleotide}.
     */
    public static Nucleotide parse(String base){
<span class="fc" id="L211">        return parse(base.charAt(0));</span>
    }
    /**
     * Get the {@link Nucleotide} for the given
     * character representation.  For example,
     * {@link #parse(char) parse('A')} will return
     * {@link #Adenine}.  This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param base the nucleotide as a character.
     * @return a {@link Nucleotide} equivalent.
     * @throws IllegalArgumentException if the given
     * character can not be mapped to a {@link Nucleotide}.
     */
    public static Nucleotide parse(char base){
<span class="fc" id="L225">        final Nucleotide ret = parseOrNull(base);</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if(ret==null){</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(&quot;invalid character &quot; + base + &quot; ascii value &quot; + (int)base);</span>
        }
<span class="fc" id="L229">        return ret;</span>
    }
    /**
     * Same as {@link #parse(char)}
     * except if the character is ASCII whitespace
     * then return null.
     * @param base the nucleotide base to parse.
     * 
     * @return the {@link Nucleotide} of {@code null}
     * if the char does not represent a valid nucleotide.
     */
	protected static Nucleotide parseOrNull(char base) {
		//if it's a whitespace character return null.
<span class="pc bpc" id="L242" title="1 of 6 branches missed.">		if(base == 32 || (base &gt;=0 &amp;&amp; base &lt;=13)){</span>
<span class="fc" id="L243">			return null;</span>
		}
<span class="fc" id="L245">		int offset =computeOffsetFor(base);</span>
<span class="fc" id="L246">		Nucleotide ret=null;</span>
<span class="pc bpc" id="L247" title="2 of 4 branches missed.">		if(offset &gt;=0 &amp;&amp; offset &lt; CACHE.length){</span>
<span class="fc" id="L248">			ret = CACHE[offset];</span>
		}
		//if we're still null then it's invalid character
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    	if(ret==null){</span>
<span class="nc" id="L252">            throw new IllegalArgumentException(&quot;invalid character &quot; + base + &quot; ascii value &quot; + (int)base);</span>
        }
<span class="fc" id="L254">		return ret;</span>
	}
    /**
     * Returns this Nucleotide as a single character String.  For example {@link #Adenine} 
     * will return &quot;A&quot;.
     */
    @Override
    public String toString() {
<span class="fc" id="L262">        return c.toString();</span>
    }
    
    @Override
    public boolean isGap(){
<span class="fc bfc" id="L267" title="All 2 branches covered.">        return this == Gap;</span>
    }
    /**
     * Is This Nucleotide an ambiguity?
     * An ambiguity is any Nucleotide that is not an 
     * A , C, G or T or gap.
     * @return {@code true} if it is am ambiguity;
     * {@code false} otherwise.
     */
    public boolean isAmbiguity(){
<span class="fc bfc" id="L277" title="All 10 branches covered.">        return !isGap() &amp;&amp; this !=Adenine  </span>
         &amp;&amp; this !=Cytosine &amp;&amp; this != Guanine &amp;&amp; this != Thymine;
    }
    
    @Override
	public byte getOrdinalAsByte() {
<span class="fc" id="L283">		return (byte)ordinal();</span>
	}
   
    
    
    /**
     * Get the Set containing all ambiguous {@link Nucleotide}s that
     * could be created from this
     * {@link Nucleotide} (plus others).
     * @return the Set of ambiguous {@link Nucleotide}s that
     * could be created from this or an empty set if
     * the given {@link Nucleotide} is already
     * an ambiguity. 
     */
    public Set&lt;Nucleotide&gt; getAllPossibleAmbiguities(){
        
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if(CONSTIUENT_TO_AMBIGUITY.containsKey(this)){</span>
<span class="fc" id="L300">            return EnumSet.copyOf(CONSTIUENT_TO_AMBIGUITY.get(this));</span>
        }
<span class="fc" id="L302">        return EnumSet.noneOf(Nucleotide.class);</span>
    }
    /**
     * Give the ambiguity {@link Nucleotide} for
     * the corresponding collection of unambiguous {@link Nucleotide}s
     * 
     * @param unambiguiousBases collection of unambiguous {@link Nucleotide}s
     * to be turned into a single ambiguity.
     * @return the ambiguity {@link Nucleotide} or {@link #Gap}
     * if no ambiguity exists for all the given unambiguous bases.
     * @throws NullPointerException if unambiguiousBases is null.
     * @see #getBasesFor()
     */
    public static Nucleotide getAmbiguityFor(Collection&lt;Nucleotide&gt; unambiguiousBases){
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if(unambiguiousBases ==null){</span>
<span class="nc" id="L317">            throw new NullPointerException(&quot;unambiguousBases can not be null&quot;);</span>
        }
<span class="fc bfc" id="L319" title="All 2 branches covered.">        for(Entry&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt; entry : AMBIGUITY_TO_CONSTIUENT.entrySet()){</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            if(unambiguiousBases.containsAll(entry.getValue())){</span>
<span class="fc" id="L321">                return entry.getKey();</span>
            }
<span class="fc" id="L323">        }</span>
<span class="fc" id="L324">        return Gap;        </span>
    }
    /**
     * Get the non-ambiguous bases that make up this
     * {@link Nucleotide}.
     * If this Nucleotide is ambiguous, then
     * the returned {@link Set} will contain
     * all the {@link Nucleotide}s
     * that make up this ambiguity.
     * Calling this method on a non-ambiguous
     * {@link Nucleotide} will return
     * a Set containing a single element, this.
     * For example calling this method
     * on
     * {@link Nucleotide#Purine}
     * will return a set containing
     * the two {@link Nucleotide}s
     * {@link Nucleotide#Adenine} and
     * {@link Nucleotide#Guanine}.
     * &lt;p&gt;
     * This method mirrors {@link #getAmbiguityFor(Collection)}
     * such that the input of one of these methods should
     * be the return value of the other.
     * &lt;pre&gt; 
     * Nucleotide n = ...;
     * n == Nucleotide.getAmbiguityFor(n.getBasesFor());
     * &lt;/pre&gt; 
     * @return a {@link Set} of Nucleotides
     * will never be null or empty.
     */
    public Set&lt;Nucleotide&gt; getBasesFor(){
<span class="fc bfc" id="L355" title="All 2 branches covered.">    	if(this== Gap){</span>
<span class="fc" id="L356">    		return EnumSet.of(Gap);</span>
    	}
<span class="fc" id="L358">    	return AMBIGUITY_TO_CONSTIUENT.get(this);</span>
    }
    
    
    public static Nucleotide getByOrdinal(int ordinal){
<span class="fc" id="L363">    	return VALUES_ARRAY[ordinal];</span>
    }
    /**
     * Two {@link Nucleotide}s match if one of the {@link Nucleotide}'s
     * set of unambiguous bases
     * is a complete subset of the other.
     * For example, V (which is A,C or G) would
     * match A, C, G, M, R, S and N. However, V would not
     * match W since that could also represent a T.
     * @param other the other Nucleotide to match.
     * @return {@code true} if this Nucleotide matches the other given
     * {@link Nucleotide}; {@code false} otherwise.
     */
    public boolean matches(Nucleotide other){
<span class="fc bfc" id="L377" title="All 2 branches covered.">    	if(other ==null){</span>
<span class="fc" id="L378">    		throw new NullPointerException(&quot;other can not be null&quot;);</span>
    	}
<span class="fc bfc" id="L380" title="All 2 branches covered.">    	if(this==other){</span>
<span class="fc" id="L381">    		return true;</span>
    	}

<span class="fc" id="L384">    	Set&lt;Nucleotide&gt; basesForOther =other.getBasesFor();</span>
<span class="fc" id="L385">    	Set&lt;Nucleotide&gt; basesForThis =getBasesFor();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">    	return basesForThis.containsAll(basesForOther)</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    			|| basesForOther.containsAll(basesForThis);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>