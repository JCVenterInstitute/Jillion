<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultReferenceEncodedNucleotideSequence.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.residue.nt</a> &gt; <span class="el_source">DefaultReferenceEncodedNucleotideSequence.java</span></div><h1>DefaultReferenceEncodedNucleotideSequence.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Feb 9, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.residue.nt;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Ranges;
import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.util.iter.ArrayIterator;
import org.jcvi.jillion.internal.core.io.StreamUtil;
import org.jcvi.jillion.internal.core.io.ValueSizeStrategy;
import org.jcvi.jillion.internal.core.residue.AbstractResidueSequence;
import org.jcvi.jillion.internal.core.util.ArrayUtil;
import org.jcvi.jillion.internal.core.util.GrowableIntArray;

final class DefaultReferenceEncodedNucleotideSequence extends AbstractResidueSequence&lt;Nucleotide, NucleotideSequence, NucleotideSequenceBuilder&gt; implements ReferenceMappedNucleotideSequence{

    /**
	 * 
	 */
	private static final long serialVersionUID = 938806681397322051L;
	private final int length;
    private final int startOffset;
    private final NucleotideSequence reference;
    /**
     * All of the differences between this 
     * read and the reference it is aligned 
     * to (which could be a contig consensus)
     * are encoded here. If there are no SNPs in this read:
     * meaning that this read aligns to its reference at 100%
     * identity, then this value &lt;strong&gt; will be null&lt;/strong&gt;.
     * &lt;br/&gt;
     * The encoding uses {@link ValueSizeStrategy}
     * to pack the data in as few bytes as possible.
     * Here is the current encoding:&lt;br/&gt;
     * &lt;ul&gt;
     *  &lt;li&gt;first byte is the ordinal value of the {@link ValueSizeStrategy}
     *   used to store the number of elements&lt;/li&gt;
     *  
     *  &lt;li&gt;the next 1,2 or 4 bytes (depending on the {@link ValueSizeStrategy}
     *  specified in the previous byte) denote the number of SNPs encoded.&lt;/li&gt;
     *  
     *  &lt;li&gt;the next byte is the ordinal value of the {@link ValueSizeStrategy}
     *   used to store the number of bytes
     *   required for each SNP offset value&lt;/li&gt;
     *  
     *  &lt;li&gt;the next $num_snps * 1,2 or 4 bytes (depending on the {@link ValueSizeStrategy}
     *  specified in the previous byte) encode the SNP offsets in the read.&lt;/li&gt;
     *  
     *  &lt;/li&gt; the remaining bytes store the actual SNP values as Nucleotide ordinal values
     *  packed as 4 bits each.  This means that each byte actually stores
     *  2 SNPs.&lt;/li&gt;
     *  &lt;ul/&gt;
     */
    private final byte[] encodedSnpsInfo;
    /**
     * Our HashCode value,
     * This value is lazy loaded
     * so we only have 
     * to compute the hashcode value
     * once.
     * 
     * We can afford to store it because
     * the Java memory model will padd out
     * the bytes anyway so we don't
     * take up any extra memory.
     */
    private transient int hash;
    
    
    @Override
	public SortedMap&lt;Integer, Nucleotide&gt; getDifferenceMap() {
<span class="fc bfc" id="L108" title="All 2 branches covered.">    	if(encodedSnpsInfo==null){</span>
<span class="fc" id="L109">    		return new TreeMap&lt;Integer, Nucleotide&gt;();</span>
    	}
<span class="fc" id="L111">        ByteBuffer buf = ByteBuffer.wrap(encodedSnpsInfo);</span>
<span class="fc" id="L112">        ValueSizeStrategy numSnpsSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L113">		int size = numSnpsSizeStrategy.getNext(buf);</span>
<span class="fc" id="L114">        ValueSizeStrategy snpSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L115">    	byte[] snps = getSnpArray(numSnpsSizeStrategy, size, snpSizeStrategy);</span>
<span class="fc" id="L116">    	SortedMap&lt;Integer, Nucleotide&gt; differenceMap = new TreeMap&lt;Integer, Nucleotide&gt;();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">    	for(int i=0; i&lt;size; i++){        	</span>
<span class="fc" id="L118">            Integer offset = snpSizeStrategy.getNext(buf);</span>
<span class="fc" id="L119">            int index = i/2;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        	if(i%2==0){</span>
<span class="fc" id="L121">        		int temp1 = snps[index]&gt;&gt;4;</span>
<span class="fc" id="L122">				differenceMap.put(offset, Nucleotide.VALUES.get(temp1 &amp; 0x0F));</span>
<span class="fc" id="L123">        	}else{</span>
<span class="fc" id="L124">        		differenceMap.put(offset,Nucleotide.VALUES.get(snps[index] &amp; 0x0F));</span>
        	}
			
        }
<span class="fc" id="L128">		return differenceMap;</span>
	}

    public DefaultReferenceEncodedNucleotideSequence(NucleotideSequence reference,
            String toBeEncoded, int startOffset){
<span class="fc" id="L133">    	this(reference, new NucleotideSequenceBuilder(toBeEncoded), startOffset);</span>
<span class="fc" id="L134">    }</span>

	public DefaultReferenceEncodedNucleotideSequence(NucleotideSequence reference,
<span class="fc" id="L137">            NucleotideSequenceBuilder toBeEncoded, int startOffset){</span>
    
<span class="fc" id="L139">        this.startOffset = startOffset;</span>
<span class="fc" id="L140">        this.length = (int)toBeEncoded.getLength();</span>
<span class="fc" id="L141">        this.reference = reference;</span>
<span class="fc" id="L142">        SortedMap&lt;Integer, Nucleotide&gt; differentGlyphMap = populateFields(reference, toBeEncoded, startOffset);</span>
<span class="fc" id="L143">        int numSnps = differentGlyphMap.size();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if(numSnps ==0){</span>
        	//no snps
<span class="fc" id="L146">        	encodedSnpsInfo =null;</span>
<span class="fc" id="L147">        	return;</span>
        }
       
<span class="fc" id="L150">    	ValueSizeStrategy snpSizeStrategy = ValueSizeStrategy.getStrategyFor(differentGlyphMap.lastKey().intValue());</span>
<span class="fc" id="L151">        int snpByteLength = computeNumberOfBytesToStore(numSnps,snpSizeStrategy);</span>
<span class="fc" id="L152">        ValueSizeStrategy numSnpsStrategy = ValueSizeStrategy.getStrategyFor(snpByteLength);</span>
<span class="fc" id="L153">        int bufferSize = numSnpsStrategy.getNumberOfBytesPerValue()+ snpByteLength;</span>
<span class="fc" id="L154">        ByteBuffer buffer = ByteBuffer.allocate(bufferSize);</span>
        
<span class="fc" id="L156">        buffer.put((byte)numSnpsStrategy.ordinal());</span>
<span class="fc" id="L157">		numSnpsStrategy.put(buffer, numSnps);</span>
        
<span class="fc" id="L159">        buffer.put((byte)snpSizeStrategy.ordinal());</span>
<span class="fc" id="L160">        int i=0;</span>
<span class="fc" id="L161">        byte[] snpValues = new byte[(numSnps+1)/2];</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">    	for(Entry&lt;Integer, Nucleotide&gt; entry : differentGlyphMap.entrySet()){</span>
        
<span class="fc" id="L164">        	snpSizeStrategy.put(buffer, entry.getKey().intValue());</span>
<span class="fc" id="L165">        	byte ordinal = entry.getValue().getOrdinalAsByte();</span>
<span class="fc" id="L166">        	int index = i/2;</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        	if(i%2==0){</span>
<span class="fc" id="L168">        		snpValues[index] = (byte)(ordinal&lt;&lt;4 &amp; 0xF0);</span>
        	}else{
<span class="fc" id="L170">        		snpValues[index] = (byte)(snpValues[index] | ordinal);</span>
        	}
        	  	
<span class="fc" id="L173">        	i++;</span>
<span class="fc" id="L174">        }</span>
    	
<span class="fc" id="L176">		buffer.put(snpValues);	        </span>
<span class="fc" id="L177">        encodedSnpsInfo = buffer.array();</span>
    
<span class="fc" id="L179">    }</span>
    
    
    @Override
    public Stream&lt;Range&gt; findMatches(Pattern pattern) {
        //override if something better!
<span class="nc" id="L185">        Matcher matcher = pattern.matcher(toString());</span>
        
        
<span class="nc bnc" id="L188" title="All 2 branches missed.">        return StreamUtil.newGeneratedStream(() -&gt; matcher.find()</span>
<span class="nc" id="L189">                ? Optional.of(Range.of(matcher.start(), matcher.end() - 1))</span>
<span class="nc" id="L190">                : Optional.empty());</span>
    }
    
    

    @Override
    public Stream&lt;Range&gt; findMatches(Pattern pattern, Range subSequenceRange) {
        //override if something better!
<span class="nc" id="L198">        Matcher matcher = pattern.matcher(toString(subSequenceRange));</span>
        
<span class="nc bnc" id="L200" title="All 2 branches missed.">        return StreamUtil.newGeneratedStream(() -&gt; matcher.find()</span>
<span class="nc" id="L201">                ? Optional.of(new Range.Builder(matcher.start(), matcher.end() - 1).shift(subSequenceRange.getBegin()).build())</span>
<span class="nc" id="L202">                : Optional.empty());</span>
    }

    private int computeNumberOfBytesToStore(int numSnps,ValueSizeStrategy snpSizeStrategy) {
<span class="fc" id="L206">    	int numBytesPerSnpIndex = snpSizeStrategy.getNumberOfBytesPerValue();</span>
<span class="fc" id="L207">    	int numBytesRequiredToStoreSnps = (numSnps+1)/2;</span>
<span class="fc" id="L208">    	int numberOfBytesToStoreSnpOffsets=numBytesPerSnpIndex*numSnps;</span>
<span class="fc" id="L209">    	return 2+numberOfBytesToStoreSnpOffsets + numBytesRequiredToStoreSnps;</span>
	}


	private SortedMap&lt;Integer, Nucleotide&gt; populateFields(
			NucleotideSequence reference,
            NucleotideSequenceBuilder toBeEncoded, int startOffset) {
<span class="fc" id="L216">        handleBeforeReference(startOffset);</span>
<span class="fc" id="L217">        handleAfterReference(reference, toBeEncoded, startOffset);</span>
<span class="fc" id="L218">        TreeMap&lt;Integer, Nucleotide&gt; differentGlyphMap = new TreeMap&lt;Integer, Nucleotide&gt;();</span>
        
<span class="fc" id="L220">       Iterator&lt;Nucleotide&gt; readIterator = toBeEncoded.iterator();</span>
<span class="fc" id="L221">       Iterator&lt;Nucleotide&gt; refIterator = reference.iterator(new Range.Builder(length)</span>
<span class="fc" id="L222">    		   													.shift(startOffset)</span>
<span class="fc" id="L223">    		   													.build());</span>
<span class="fc" id="L224">       int i=0;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">       while(readIterator.hasNext()){</span>
<span class="fc" id="L226">            Nucleotide g = readIterator.next();</span>
<span class="fc" id="L227">            final Nucleotide referenceGlyph = refIterator.next();            </span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if(isDifferent(g, referenceGlyph)){</span>
<span class="fc" id="L229">                    differentGlyphMap.put(Integer.valueOf(i), g);</span>
            }
<span class="fc" id="L231">            i++;</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">        return differentGlyphMap;</span>
    }

    private void handleAfterReference(Sequence&lt;Nucleotide&gt; reference,
            NucleotideSequenceBuilder toBeEncoded, int startOffset) {
<span class="fc" id="L238">        int lastOffsetOfSequence = (int)toBeEncoded.getLength()+startOffset;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if(lastOffsetOfSequence &gt; reference.getLength()){</span>
<span class="fc" id="L240">            int overhang = (int)(toBeEncoded.getLength()+startOffset - reference.getLength());</span>
<span class="fc" id="L241">            throw new IllegalArgumentException(String.format(&quot;sequences extends beyond reference by %d base(s)&quot;, overhang));</span>
        }
<span class="fc" id="L243">    }</span>


    private void handleBeforeReference(int startOffset) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if(startOffset&lt;0){</span>
            //handle before values
<span class="fc" id="L249">           throw new IllegalArgumentException(&quot;can not start before reference: &quot;+ startOffset);</span>
        }
<span class="fc" id="L251">    }</span>

    @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
    private boolean isDifferent(Nucleotide g, final Nucleotide referenceGlyph) {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        return g!=referenceGlyph;</span>
    }

    @Override
	public Iterator&lt;Nucleotide&gt; iterator() {
<span class="fc" id="L260">    	Nucleotide[] array = asNucleotideArray();</span>
<span class="fc" id="L261">    	return new ArrayIterator&lt;&gt;(array);</span>
	}

	@Override
	public Iterator&lt;Nucleotide&gt; iterator(Range range) {		
<span class="fc" id="L266">		Nucleotide[] array = asNucleotideArray(range);</span>
<span class="fc" id="L267">		return new ArrayIterator&lt;&gt;(array);</span>
	}




	private Nucleotide[] createReferenceArray(Range range){
<span class="fc" id="L274">		Nucleotide[] array = new Nucleotide[(int)range.getLength()];</span>
<span class="fc" id="L275">		Iterator&lt;Nucleotide&gt; iter = reference.iterator(range);</span>
<span class="fc" id="L276">		int i=0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">		while(iter.hasNext()){</span>
<span class="fc" id="L278">			array[i] = iter.next();</span>
<span class="fc" id="L279">			i++;</span>
		}
<span class="fc" id="L281">		return array;</span>
	}
	private Nucleotide[] asNucleotideArray(Range range) {
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">		if(range==null){</span>
<span class="nc" id="L285">			throw new NullPointerException(&quot;range can not be null&quot;);</span>
		}
		//make sure begining of range is in bounds
<span class="fc bfc" id="L288" title="All 2 branches covered.">		if(range.getBegin() &lt; 0){</span>
<span class="fc" id="L289">			throw new IndexOutOfBoundsException();</span>
		}
		//make sure range is in bounds
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if(range.getEnd()&gt;= length){</span>
<span class="fc" id="L293">			throw new IndexOutOfBoundsException(range.getEnd() + &quot; is beyond end of sequence (length = &quot; + length + &quot;)&quot;);</span>
		}
<span class="fc" id="L295">		Nucleotide[] array = asNucleotideArray();</span>
		
<span class="fc" id="L297">		return Arrays.copyOfRange(array, (int)range.getBegin(), (int)range.getEnd()+1);</span>
	}
	private Nucleotide[] asNucleotideArray() {
		//get the reference bases as an array
		//we convert to an array since
		//we need to replace with our SNPs
		//and its simpler than
		//list.remove(offset); list.add(offset, snp);
		//with boundary checking
		//or 
		//list.add(offset, snp);
		//list.remove(offset+1);
		//without resizing list everytime.
<span class="fc" id="L310">		Nucleotide[] array= createReferenceArray(new Range.Builder(length)</span>
<span class="fc" id="L311">										.shift(startOffset).build());</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">		if(encodedSnpsInfo !=null){</span>
			//pull out all of our SNP data at the same
			//time and 
<span class="fc" id="L315">	        ByteBuffer buf = ByteBuffer.wrap(encodedSnpsInfo);</span>
	        
<span class="fc" id="L317">	        ValueSizeStrategy numSnpsSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L318">			int size = numSnpsSizeStrategy.getNext(buf);</span>
<span class="fc" id="L319">	        ValueSizeStrategy sizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L320">	        byte[] snps = getSnpArray(numSnpsSizeStrategy, size, sizeStrategy);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">	        for(int i=0; i&lt;size; i++){        	</span>
<span class="fc" id="L322">	            int index = sizeStrategy.getNext(buf); </span>
<span class="fc" id="L323">				int snpIndex = i/2;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">				if(i%2==0){</span>
<span class="fc" id="L325">					array[index]= Nucleotide.VALUES.get(snps[snpIndex]&gt;&gt;4 &amp;0x0F);</span>
				}else{
<span class="fc" id="L327">					array[index]= Nucleotide.VALUES.get(snps[snpIndex] &amp; 0x0F);</span>
				}
	        }
        }
<span class="fc" id="L331">		return array;</span>
	}
    @Override
    public Nucleotide get(long index) {
<span class="pc bpc" id="L335" title="2 of 4 branches missed.">        if(index &lt;0 || index &gt;= length){</span>
<span class="nc" id="L336">            throw new IndexOutOfBoundsException(&quot;invalid offset &quot; +index);</span>
        }
        
        
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if(encodedSnpsInfo !=null){</span>
        	//there are snps so we need to check them first
        
<span class="fc" id="L343">	        ByteBuffer buf = ByteBuffer.wrap(encodedSnpsInfo);</span>
	        
<span class="fc" id="L345">	        ValueSizeStrategy numSnpsSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L346">			int size = numSnpsSizeStrategy.getNext(buf);</span>
<span class="fc" id="L347">	        ValueSizeStrategy sizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L348">	        byte[] snps = getSnpArray(numSnpsSizeStrategy, size, sizeStrategy);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">	        for(int i=0; i&lt;size; i++){        	</span>
<span class="fc" id="L350">	            int nextValue = sizeStrategy.getNext(buf);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">				if(index ==nextValue){</span>
<span class="fc" id="L352">					int snpIndex = i/2;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">					if(i%2==0){</span>
<span class="fc" id="L354">						return Nucleotide.VALUES.get(snps[snpIndex]&gt;&gt;4 &amp;0x0F);</span>
					}else{
<span class="fc" id="L356">						return Nucleotide.VALUES.get(snps[snpIndex] &amp; 0x0F);</span>
					}

	            }
	        }
        }
<span class="fc" id="L362">        long referenceIndex = index+startOffset;</span>
<span class="fc" id="L363">        return reference.get(referenceIndex);</span>
    }



	private byte[] getSnpArray(ValueSizeStrategy numSnpsSizeStrategy,
			int size, ValueSizeStrategy sizeStrategy) {
<span class="fc" id="L370">		int from = numSnpsSizeStrategy.getNumberOfBytesPerValue()+2+size*sizeStrategy.getNumberOfBytesPerValue();</span>
<span class="fc" id="L371">		return Arrays.copyOfRange(encodedSnpsInfo, from, encodedSnpsInfo.length);</span>
	}


    @Override
    public boolean isGap(int index) {
<span class="nc" id="L377">        return getGapOffsets().contains(Integer.valueOf(index));</span>
        
    }
    
    @Override
    public long getLength() {
<span class="fc" id="L383">        return length;</span>
    }

    @Override
    public List&lt;Integer&gt; getGapOffsets() {
<span class="fc" id="L388">    	GrowableIntArray referenceGapOffsets = shiftReferenceGaps();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if(encodedSnpsInfo !=null){</span>
<span class="fc" id="L390">	        return modifyForSnps(referenceGapOffsets);</span>
        }
<span class="fc" id="L392">        return ArrayUtil.asList(referenceGapOffsets.toArray());</span>
    }

	private List&lt;Integer&gt; modifyForSnps(GrowableIntArray gaps) {
		//now check our snps to see
		//1. if we have snp where the ref has a gap
		//2. if we have gap
<span class="fc" id="L399">		ByteBuffer buf = ByteBuffer.wrap(encodedSnpsInfo);</span>
<span class="fc" id="L400">		int size = ValueSizeStrategy.values()[buf.get()].getNext(buf);</span>
<span class="fc" id="L401">		ValueSizeStrategy sizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="fc" id="L402">		GrowableIntArray snps = new GrowableIntArray(size);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">		for(int i=0; i&lt;size; i++){</span>
<span class="fc" id="L404">		    int snpOffset = sizeStrategy.getNext(buf);</span>
		    //if we have a snp where 
		    //the reference has a gap
		    //remove it from our list of gaps
<span class="fc" id="L408">		    int index = gaps.binarySearch(snpOffset);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">			if(index&gt;=0){</span>
<span class="fc" id="L410">		        gaps.remove(index);</span>
		    }
<span class="fc" id="L412">		    snps.append(snpOffset);</span>
		}
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">		if(buf.hasRemaining()){</span>
<span class="fc" id="L415">			int numBytesRemaining =buf.remaining();</span>
			
<span class="fc" id="L417">			 byte[] snpArray = Arrays.copyOfRange(encodedSnpsInfo, encodedSnpsInfo.length- numBytesRemaining, encodedSnpsInfo.length);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">		     for(int i=0; i&lt;size; i++){</span>
<span class="fc" id="L419">		    	 int snpIndex = i/2;</span>
		    	 final Nucleotide snp;
<span class="fc bfc" id="L421" title="All 2 branches covered.">					if(i%2==0){</span>
<span class="fc" id="L422">						snp= Nucleotide.VALUES.get(snpArray[snpIndex]&gt;&gt;4 &amp;0x0F);</span>
					}else{
<span class="fc" id="L424">						snp= Nucleotide.VALUES.get(snpArray[snpIndex] &amp; 0x0F);</span>
					}
<span class="fc bfc" id="L426" title="All 2 branches covered.">		    	 if(Nucleotide.Gap == snp){</span>
<span class="fc" id="L427">		    		 gaps.append(snps.get(i));</span>
		    	 }
		     }
		    
		}
		//sort gaps so they are in order
		//before this line, our gaps are in
		//sorted ref gaps
		//followed by sorted snps which happen to be gaps
<span class="fc" id="L436">		gaps.sort();</span>
<span class="fc" id="L437">		return ArrayUtil.asList(gaps.toArray());</span>
	}
	//first, get gaps from our aligned section of the reference
    //we may have a snp in the gap location
    //so we need to check for that
	/**
	 * Most reference gaps should also
	 * be present in our gapped sequence
	 * so we need to get the reference gaps
	 * that overlap with our sequence range
	 * and shift them accordingly so read coordinate space.
	 * (offset 0 is first base in our read)
	 * @return
	 */
	private GrowableIntArray shiftReferenceGaps() {
<span class="fc" id="L452">		List&lt;Integer&gt; refGapOffsets = reference.getGapOffsets();</span>
<span class="fc" id="L453">		GrowableIntArray gaps = new GrowableIntArray(refGapOffsets.size());</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        for(Integer refGap : refGapOffsets){</span>
<span class="fc" id="L455">            int adjustedCoordinate = refGap.intValue() - startOffset;</span>
<span class="fc bfc" id="L456" title="All 4 branches covered.">            if(adjustedCoordinate &gt;=0 &amp;&amp; adjustedCoordinate&lt;length){</span>
<span class="fc" id="L457">                gaps.append(adjustedCoordinate);</span>
            }
<span class="fc" id="L459">        }</span>
<span class="fc" id="L460">		return gaps;</span>
	}

	@Override
    public int hashCode() {
<span class="fc" id="L465">		long length = getLength();</span>
<span class="pc bpc" id="L466" title="1 of 4 branches missed.">		if(hash==0 &amp;&amp; length &gt;0){</span>
<span class="fc" id="L467">	        final int prime = 31;</span>
<span class="fc" id="L468">	        int result = 1;</span>
<span class="fc" id="L469">	        Iterator&lt;Nucleotide&gt; iter = iterator();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">	        while(iter.hasNext()){</span>
<span class="fc" id="L471">	        	result = prime * result + iter.next().hashCode();</span>
	        }
<span class="fc" id="L473">	        hash= result;</span>
		}
<span class="fc" id="L475">	    return hash;</span>
    }
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L479" title="All 2 branches covered.">    	 if (this == obj){</span>
<span class="fc" id="L480">             return true;</span>
         }
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">         if (!(obj instanceof NucleotideSequence)){</span>
<span class="nc" id="L483">             return false;</span>
         }
<span class="fc" id="L485">         NucleotideSequence other = (NucleotideSequence) obj;</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">         if(getLength() != other.getLength()){</span>
<span class="nc" id="L487">         	return false;</span>
         }
<span class="fc" id="L489">        Iterator&lt;Nucleotide&gt; iter = iterator();</span>
<span class="fc" id="L490">        Iterator&lt;Nucleotide&gt; otherIter = other.iterator();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        while(iter.hasNext()){</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">     	   if(!iter.next().equals(otherIter.next())){</span>
<span class="nc" id="L493">     		   return false;</span>
     	   }
        }
<span class="fc" id="L496">        return true;</span>
    }
    
    /**
     * {@inheritDoc}
     */
     @Override
     public int getNumberOfGaps() {
<span class="fc" id="L504">         return getGapOffsets().size();</span>
     }
    
    
     @Override
     public String toString(){
<span class="fc" id="L510">    	 Nucleotide[] array = asNucleotideArray();</span>
<span class="fc" id="L511">    	 StringBuilder builder = new StringBuilder(array.length);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">    	 for(int i=0; i&lt; array.length; i++){</span>
<span class="fc" id="L513">    		 builder.append(array[i]);</span>
    	 }
<span class="fc" id="L515">         return builder.toString();</span>
     }
     private String toString(Range range){
<span class="nc" id="L518">         Nucleotide[] array = asNucleotideArray(range);</span>
<span class="nc" id="L519">         StringBuilder builder = new StringBuilder(array.length);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">         for(int i=0; i&lt; array.length; i++){</span>
<span class="nc" id="L521">                 builder.append(array[i]);</span>
         }
<span class="nc" id="L523">         return builder.toString();</span>
     }



	@Override
	public NucleotideSequence getReferenceSequence() {
<span class="fc" id="L530">		return reference;</span>
	}

	@Override
	public NucleotideSequenceBuilder toBuilder() {
<span class="fc" id="L535">		return new NucleotideSequenceBuilder(this)</span>
<span class="fc" id="L536">						.setReferenceHint(reference, startOffset);</span>
	}
	
	@Override
        public NucleotideSequenceBuilder toBuilder(Range range) {
<span class="nc" id="L541">                return new NucleotideSequenceBuilder(this, range)</span>
<span class="nc" id="L542">                                                .setReferenceHint(reference, (int)(startOffset + range.getBegin()));</span>
        }

	 @Override
	    public NucleotideSequence asSubtype(){
<span class="nc" id="L547">	        return this;</span>
	    }

	@Override
	public List&lt;Range&gt; getRangesOfNs() {
		// TODO speed this up using reference info?
		//for now just do the good not optimal way of looping through eveything.
		
		//reference based probably is a read so it shouldn't be too long
<span class="fc" id="L556">		BitSet bits = new BitSet();</span>
<span class="fc" id="L557">		int offset =0;</span>
<span class="fc" id="L558">		Iterator&lt;Nucleotide&gt; iter = iterator();</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">		while(iter.hasNext()){</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">			if(iter.next() == Nucleotide.Unknown){</span>
<span class="fc" id="L561">				bits.set(offset);</span>
			}
<span class="fc" id="L563">			offset++;</span>
		}
<span class="fc" id="L565">		return Ranges.asRanges(bits);</span>
	}
	 
	 
	 
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>