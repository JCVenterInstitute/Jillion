<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConsedUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed</a> &gt; <span class="el_source">ConsedUtil.java</span></div><h1>ConsedUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 7, 2010
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.consed;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.assembly.consed.ace.AceAssembledReadBuilder;
import org.jcvi.jillion.assembly.consed.ace.AceContig;
import org.jcvi.jillion.assembly.consed.ace.AceContigBuilder;
import org.jcvi.jillion.assembly.consed.ace.ConsensusAceTag;
import org.jcvi.jillion.assembly.consed.ace.PhdInfo;
import org.jcvi.jillion.assembly.consed.phd.PhdDataStore;
import org.jcvi.jillion.assembly.consed.phd.PhdDirDataStore;
import org.jcvi.jillion.assembly.util.CoverageMap;
import org.jcvi.jillion.assembly.util.CoverageMapBuilder;
import org.jcvi.jillion.assembly.util.CoverageRegion;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.Ranges;
import org.jcvi.jillion.core.datastore.DataStore;
import org.jcvi.jillion.core.io.FileUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;

/**
 * This class contains utility scripts for
 * converting {@link AceContig} data into
 * data that can work with Consed.
 * @author dkatzel
 *
 *
 */
public final class ConsedUtil {
	
	
    /**
     * 
     */
    private static final String CONTIG_RENAME_TAG_TYPE = &quot;contigName&quot;;

    /**
     * Consed rename comment header which tells us what the contig SHOULD 
     * be named instead of the given ID.
     */
<span class="fc" id="L78">    private static final Pattern CONTIG_RENAME_PATTERN = Pattern.compile(&quot;U(\\w+)&quot;);</span>
    
<span class="fc" id="L80">    private static final Pattern CONSED_ACE_PATTERN = Pattern.compile(&quot;((.+?)\\.)?ace(\\.(\\d+))?$&quot;);</span>
    
<span class="fc" id="L82">    private static final Pattern CONSED_ACE_VERSION_PATTERN = Pattern.compile(&quot;((.+?)\\.)?ace\\.(\\d+)$&quot;);</span>
    
<span class="fc" id="L84">    private static final Pattern ACE_CONTIG_ID_PATTERN = Pattern.compile(&quot;(\\S+)_(\\d+)_\\d+&quot;);</span>
    
<span class="nc" id="L86">    private ConsedUtil(){</span>
		//private constructor
<span class="nc" id="L88">	}</span>
    /**
     * Convert a string of basecalls with '*' to 
     * represent gaps (which is what consed uses) with '-' instead. 
     * @param basecallsWithAceGaps a string of basecalls with the '*' to 
     * represent gaps.
     * @return a new string with all the '*' converted into '-'.
     */
    public static String convertAceGapsToContigGaps(String basecallsWithAceGaps) {
<span class="fc" id="L97">        return basecallsWithAceGaps.replace('*', '-');</span>
    }
   
    public static PhdInfo generateDefaultPhdInfoFor(File traceFile, String readId,
			Date phdDate) {
		final String id;
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if(traceFile ==null){</span>
<span class="fc" id="L104">        	id= readId;</span>
        }else{
<span class="fc" id="L106">            final String extension = FileUtil.getExtension(traceFile.getName());</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if(&quot;sff&quot;.equals(extension)){        </span>
<span class="fc" id="L108">                id=&quot;sff:&quot;+traceFile.getName()+&quot;:&quot;+readId;</span>
            }
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            else if(&quot;scf&quot;.equals(extension)){        </span>
<span class="nc" id="L111">                id=traceFile.getName();</span>
            }
            else{
<span class="fc" id="L114">                id= readId;</span>
            }
        }
<span class="fc" id="L117">        return new PhdInfo(id, readId+&quot;.phd.1&quot;, phdDate);</span>
	}
    /**
     * Split a contig which may contain zero coverage areas (0x)
     * into multiple contigs which all have at least some coverage at every
     * location.  If the given contig is split, the new contigs will be named
     * {@code &lt;original_id&gt;_&lt;ungapped reference 1-based start&gt;_&lt;ungapped reference 1-based end&gt;}
     * &lt;p&gt;
     * Some Assemblers (mostly reference assemblers) create contigs with zero coverage
     * regions (0x) but that have the reference basecalls as the consensus in those 
     * areas. This method removes the parts of the contig which only have consensus. 
     * @param contigBuilder an {@link AceContig} that may have 0x regions.  Can not be null.
     * @param adjustIdCoordinates this contig id already has coordinates appended to the end
     * of the id, adjust these coordinates instead of appending new ones...
     * @return a {@link SortedMap} of (possibly new) AceContigs of the broken given contig.
     * The keys of the map are the Ranges into the original contig where these contigs
     * are placed and the values of the  map are the (possibly new) AceContigs.
     * If there are no 0x regions in the given contig, then a Map containing
     * one entry containing the Range covered and the reference of the given contig is returned.
     */
    public static SortedMap&lt;Range,AceContig&gt; split0xContig(AceContigBuilder contigBuilder, boolean adjustIdCoordinates){
<span class="fc" id="L138">        List&lt;Range&gt; coveredRegions = new ArrayList&lt;Range&gt;();</span>
<span class="fc" id="L139">        NucleotideSequence unSplitConsensus = contigBuilder.getConsensusBuilder().build();</span>
<span class="fc" id="L140">        CoverageMap&lt;AceAssembledReadBuilder&gt; coverageMap = new CoverageMapBuilder&lt;AceAssembledReadBuilder&gt;(contigBuilder.getAllAssembledReadBuilders())</span>
<span class="fc" id="L141">        															.build();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for(CoverageRegion&lt;AceAssembledReadBuilder&gt; region : coverageMap){</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            if(region.getCoverageDepth()&gt;0){</span>
                
<span class="fc" id="L145">                final Range contigRange =region.asRange();</span>
<span class="fc" id="L146">                coveredRegions.add(contigRange);</span>
            }
<span class="fc" id="L148">        }</span>
        
<span class="fc" id="L150">        List&lt;Range&gt; contigRanges =Ranges.merge(coveredRegions);</span>
<span class="fc" id="L151">        SortedMap&lt;Range, AceContig&gt; map = new TreeMap&lt;Range, AceContig&gt;(Range.Comparators.ARRIVAL);</span>
        
<span class="fc" id="L153">        String originalContigId= contigBuilder.getContigId();</span>
<span class="fc" id="L154">        int oldStart=1;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if(adjustIdCoordinates){</span>
<span class="fc" id="L156">            Matcher matcher = ACE_CONTIG_ID_PATTERN.matcher(originalContigId);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if(matcher.matches()){</span>
<span class="fc" id="L158">                originalContigId = matcher.group(1);</span>
<span class="fc" id="L159">                oldStart=Integer.parseInt(matcher.group(2));</span>
            }
        }
        
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if(contigRanges.size()==1){</span>
            //contig in 1 piece        	
<span class="fc" id="L165">        	Range gappedContigRange = contigRanges.get(0);</span>
<span class="fc" id="L166">			Range ungappedContigRange = AssemblyUtil.toUngappedRange(unSplitConsensus, gappedContigRange);</span>
        	//we might still have 0x regions at the edges so check
        	//to see if we're full (ungapped) size
<span class="fc bfc" id="L169" title="All 2 branches covered.">        	if(ungappedContigRange.getLength() &lt;unSplitConsensus.getUngappedLength()){</span>
<span class="fc" id="L170">        		String newContigId = computeSplitContigId(unSplitConsensus, originalContigId, oldStart, gappedContigRange);</span>
<span class="fc" id="L171">            	contigBuilder.setContigId(newContigId);</span>
        	}
<span class="fc" id="L173">        	map.put(gappedContigRange, contigBuilder.build());</span>
<span class="fc" id="L174">            return map;</span>
        }
<span class="fc bfc" id="L176" title="All 2 branches covered.">        for(Entry&lt;Range, AceContigBuilder&gt; splitContigEntry: contigBuilder.split(contigRanges).entrySet()){</span>
        	//id is now &lt;original_id&gt;_&lt;ungapped 1-based start&gt;_&lt;ungapped 1-based end&gt;
           
<span class="fc" id="L179">            AceContigBuilder splitContigBuilder = splitContigEntry.getValue();</span>
<span class="fc" id="L180">            Range contigRange = splitContigEntry.getKey();</span>
<span class="fc" id="L181">			String newContigId = computeSplitContigId(unSplitConsensus, originalContigId,</span>
    				oldStart, contigRange);
			
<span class="fc" id="L184">			splitContigBuilder.setContigId(newContigId);</span>
<span class="fc" id="L185">			map.put(contigRange, splitContigBuilder.build());</span>
<span class="fc" id="L186">        }</span>
        
<span class="fc" id="L188">        return map;</span>
    }
	private static String computeSplitContigId(NucleotideSequence consensus,
			String originalContigId, int oldStart, Range contigRange) {
<span class="fc" id="L192">		String contigId = String.format(&quot;%s_%d_%d&quot;,originalContigId, </span>
<span class="fc" id="L193">                oldStart + consensus.getUngappedOffsetFor((int) contigRange.getBegin()),</span>
<span class="fc" id="L194">                oldStart + consensus.getUngappedOffsetFor((int) contigRange.getEnd()));</span>
<span class="fc" id="L195">		return contigId;</span>
	}
    /**
     * Checks to see if the given {@link ConsensusAceTag} is denotes
     * that the contig has been renamed.
     * @param consensusTag the tag to check.
     * @return {@code true} if this tag denotes a contig rename; {@code false}
     * otherwise.
     * @throws NullPointerException if consensusTag is null.
     */
    public static boolean isContigRename(ConsensusAceTag consensusTag){
<span class="fc" id="L206">        return CONTIG_RENAME_TAG_TYPE.equals(consensusTag.getType());</span>
    }
    /**
     * Get the new name this contig should be named according to the given
     * rename tag.
     * @param contigRenameTag a {@link ConsensusAceTag} that denotes
     * the contig has been renamed.
     * @return the new name that the contig should be renamed to.
     * @throws NullPointerException if contigRenameTag is null.
     * @throws IllegalArgumentException if the given tag is not a contig rename
     * tag or if the tag text does not match the known pattern for 
     * contig renames.
     */
    public static String getRenamedContigId(ConsensusAceTag contigRenameTag){
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if(!isContigRename(contigRenameTag)){</span>
<span class="fc" id="L221">            throw new IllegalArgumentException(&quot;not a contig rename&quot;);</span>
        }
<span class="fc" id="L223">        String data= contigRenameTag.getData();</span>
<span class="fc" id="L224">        Matcher matcher = CONTIG_RENAME_PATTERN.matcher(data);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if(matcher.find()){</span>
<span class="fc" id="L226">            return matcher.group(1);</span>
        }
<span class="fc" id="L228">        throw new IllegalArgumentException(&quot;consensus tag does not contain rename info : &quot;+contigRenameTag);</span>
    }
    /**
     * Get the ace file from the given editDir
     * with the given ace file prefix and
     * the given version.
     * @param editDir the consed edit dir the ace file is in,
     * if this parameter is null, then no editDir exists.
     * @param filenamePrefix prefix to ace file name
     * before the &quot;.ace.$version&quot;; can not be null.
     * @param version the ace version number;
     * must be &amp;ge; 1
     * @return the {@link File} to that ace file;
     * or {@code null} if the specified ace does not exist
     * or the editDir is {@code null} .
     * @throws IllegalArgumentException if version &amp;lt; 1.
     */
    public static File getAceFile(File editDir, String filenamePrefix, int version){
<span class="nc bnc" id="L246" title="All 2 branches missed.">    	if(filenamePrefix == null){</span>
<span class="nc" id="L247">    		throw new NullPointerException(&quot;file name prefix can not be null&quot;);</span>
    	}
<span class="nc bnc" id="L249" title="All 2 branches missed.">    	if(version &lt;0){</span>
<span class="nc" id="L250">			throw new IllegalArgumentException(&quot;version must be &gt;= 1&quot;);</span>
		}
    	//don't need to check if edit_dir
    	//doesn't exist
    	//since we later check 
    	//if the ace exists
    	//which will also check if parent dir exists
    	//need to also check that it does not exist
<span class="nc bnc" id="L258" title="All 2 branches missed.">    	if(editDir==null){</span>
<span class="nc" id="L259">    		return null;</span>
    	}
<span class="nc" id="L261">    	File aceFile = new File(editDir, String.format(&quot;%s.ace.%d&quot;,filenamePrefix, version));</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    	if(aceFile.exists()){</span>
<span class="nc" id="L263">    		return aceFile;</span>
    	}
<span class="nc" id="L265">    	return null;</span>
    }
    /**
     * Gets the latest ace file with the given prefix in the given edit_dir.
     * 
     *&lt;p&gt;
     *Consed labels each version of the ace file with a incrementing     *
     *value so {@code prefix.ace.2} is newer than {@code prefix.ace.1}.
     *
     * @param editDir the consed edit_dir folder to inspect.
     * If this parameter is null, then this method will
     * return null.
     * @param filenamePrefix the beginning part of the file name to filter,
     * incase there are more than 1 groups of versioned assemblies.
     * 
     * @return the File object representing the latest version of the ace file
     * with the given prefix in the given edit_dir; {@code null}
     * if no such file exists or if editDir is also {@code null}.
     */
    public static File getLatestAceFile(File editDir, final String filenamePrefix){
    	//need to also check that it does not exist
<span class="pc bpc" id="L286" title="2 of 4 branches missed.">    	if(editDir==null || !editDir.exists()){</span>
<span class="nc" id="L287">    		return null;</span>
    	}
<span class="fc" id="L289">        int highestAceFileVersion=Integer.MIN_VALUE;</span>
<span class="fc" id="L290">        File highestAceFile=null;</span>
        try{
<span class="fc bfc" id="L292" title="All 2 branches covered.">        for(File file : editDir.listFiles(new FileFilter() {</span>
            
            @Override
            public boolean accept(File file) {
<span class="fc" id="L296">                String name = file.getName();</span>
<span class="fc bfc" id="L297" title="All 4 branches covered.">                return name.startsWith(filenamePrefix) &amp;&amp; CONSED_ACE_PATTERN.matcher(name).find();</span>
            }
        
     })){
           
<span class="fc" id="L302">            int version = getAceVersionFor(file);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if(version &gt; highestAceFileVersion){</span>
<span class="fc" id="L304">                highestAceFileVersion=version;</span>
<span class="fc" id="L305">                highestAceFile = file;</span>
            }
        }
<span class="fc" id="L308">        return highestAceFile;</span>
<span class="nc" id="L309">        }catch(NullPointerException e){</span>
<span class="nc" id="L310">        	throw e;</span>
        }
    }
    
    public static File generateNextAceFileFor(File editDir, String filenamePrefix){
<span class="nc" id="L315">    	File latestAceFile = getLatestAceFile(editDir, filenamePrefix);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">    	if(latestAceFile ==null){</span>
    		//no ace file make the .1
<span class="nc" id="L318">    		return new File(editDir, filenamePrefix + &quot;.ace.1&quot;);</span>
    	}
<span class="nc" id="L320">    	return new File(editDir, generateNextAceVersionNameFor(latestAceFile));</span>
    }
    
    
    public static File getPhdDirFor(File consedDir){
<span class="nc" id="L325">        verifyNotNull(consedDir);</span>
<span class="nc" id="L326">        return new File(consedDir,&quot;phd_dir&quot;);</span>
    }
	private static void verifyNotNull(File consedDir) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">		if(consedDir==null){</span>
<span class="nc" id="L330">            throw new NullPointerException(&quot;consedDir can not be null&quot;);</span>
        }
<span class="nc" id="L332">	}</span>
	/**
	 * Get the File representing the Consed
	 * &quot;edit_dir&quot; of this consed package.
	 * @param consedDir the consed dir to use;
	 * can not be null, but might not exist.
	 * @return a new File object with representing
	 * the edit_dir, this File may not exist on the file system.
	 * @throws NullPointerException if consedDir is null.
	 */
    public static File getEditDirFor(File consedDir){
<span class="nc" id="L343">        verifyNotNull(consedDir);</span>
<span class="nc" id="L344">        return new File(consedDir,&quot;edit_dir&quot;);</span>
    }
    public static File getChromatDirFor(File consedDir){
<span class="nc" id="L347">        verifyNotNull(consedDir);</span>
<span class="nc" id="L348">        return new File(consedDir,&quot;chromat_dir&quot;);</span>
    }
    public static File getPhdBallDirFor(File consedDir){
<span class="nc" id="L351">        verifyNotNull(consedDir);</span>
<span class="nc" id="L352">        return new File(consedDir,&quot;phdball_dir&quot;);</span>
    }
    public static int getAceVersionFor(File consedAceFile){
<span class="fc" id="L355">        String name = consedAceFile.getName();</span>
<span class="fc" id="L356">        Matcher matcher = CONSED_ACE_VERSION_PATTERN.matcher(name);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if(!matcher.matches()){</span>
<span class="nc" id="L358">            throw new IllegalArgumentException(&quot;could not parse version from &quot;+ name);</span>
        }
<span class="fc" id="L360">        return Integer.parseInt(matcher.group(3));</span>
    }
    /**
     * Get the root consed directory for the given 
     * ace file.
     * @param aceFile the ace file to use; can not be null
     * but does not have to exist.
     * @return a File which may or may not exist
     * @throws NullPointerException if aceFile is null.
     */
    public static File getConsedDirFor(File aceFile){
		//consed/edit_dir/ace.version
<span class="fc" id="L372">		return aceFile.getParentFile().getParentFile();</span>
    }
    /**
     * Gets the part of the ace file name
     * before the &quot;.ace&quot; part.  This method
     * works on files that end in either
     * &quot;.ace&quot; or &quot;.ace.\d+&quot;.
     * 
     * @param aceFile the ace {@link File} whose
     * name is to be parsed;
     * can not be null.
     * @return the part of the name before &quot;.ace&quot;.
     * @throws NullPointerException if aceFile is null.
     * 
     * @apiNote This is the same as
     * &lt;pre&gt;
     * {@code getAcePrefixFor(aceFile.getName())}
     * &lt;/pre&gt;
     * 
     * @see #getAcePrefixFor(String)
     */
    public static String getAcePrefixFor(File aceFile){
<span class="fc" id="L394">    	return getAcePrefixFor(aceFile.getName());</span>
    }
    /**
     * Gets the part of the ace file name
     * before the &quot;.ace&quot; part.  This method
     * works on files that end in either
     * &quot;.ace&quot; or &quot;.ace.\d+&quot;.
     * 
     * @param aceFileName the ace file name to parse;
     * can not be null.
     * @return the part of the name before &quot;.ace&quot;.
     * @throws NullPointerException if aceFileName is null.
     */
    public static String getAcePrefixFor(String aceFileName){
    	//supports both ace.version
    	//and just plain .ace
<span class="fc" id="L410">    	return aceFileName.replaceAll(&quot;\\.ace(\\.\\d+)?$&quot;, &quot;&quot;);</span>
    }
    
    public static String generateNextAceVersionNameFor(File consedAceFile){
<span class="fc" id="L414">        String name = consedAceFile.getName();</span>
<span class="fc" id="L415">        Matcher matcher = CONSED_ACE_VERSION_PATTERN.matcher(name);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if(!matcher.matches()){</span>
<span class="fc" id="L417">            throw new IllegalArgumentException(&quot;could not parse version from &quot;+ name);</span>
        }
<span class="fc" id="L419">        String prefix = matcher.group(2);</span>
<span class="fc" id="L420">        int version= Integer.parseInt(matcher.group(3));</span>
        
<span class="fc bfc" id="L422" title="All 2 branches covered.">        return String.format(&quot;%sace.%d&quot;,</span>
                prefix==null?&quot;&quot;: prefix+&quot;.&quot;, 
<span class="fc" id="L424">                        version+1);</span>
    }
    
    
    public static PhdDataStore createPhdDataStoreFor(File consedDir) throws IOException{
<span class="nc bnc" id="L429" title="All 2 branches missed.">    	if(consedDir == null){</span>
<span class="nc" id="L430">			throw new NullPointerException(&quot;consed dir can not be null&quot;);</span>
		}
<span class="nc" id="L432">		 File phdDir = ConsedUtil.getPhdDirFor(consedDir);</span>
<span class="nc" id="L433">         File phdballDir = ConsedUtil.getPhdBallDirFor(consedDir);</span>
<span class="nc" id="L434">         List&lt;PhdDataStore&gt; datastores = new ArrayList&lt;PhdDataStore&gt;();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">         if(phdDir.exists()){</span>
<span class="nc" id="L436">        	 datastores.add(new PhdDirDataStore(phdDir));</span>
         }
<span class="nc bnc" id="L438" title="All 2 branches missed.">         if(phdballDir.exists()){</span>
<span class="nc" id="L439">        	 datastores.add(new PhdDirDataStore(phdballDir));</span>
         }
<span class="nc" id="L441">         return DataStore.chain(PhdDataStore.class, datastores);</span>
    }
    
<span class="pc" id="L444">    public static enum ClipPointsType{</span>
<span class="fc" id="L445">    	VALID,</span>
<span class="fc" id="L446">    	NEGATIVE_VALID_RANGE,</span>
<span class="fc" id="L447">    	ALL_LOW_QUALITY,</span>
<span class="fc" id="L448">    	NO_HIGH_QUALITY_ALIGNMENT_INTERSECTION</span>
    	;
    	
    	public static ClipPointsType getType(int qualLeft, int qualRight,
				int alignLeft, int alignRight) {
<span class="pc bpc" id="L453" title="1 of 4 branches missed.">			if(qualLeft == -1 &amp;&amp; qualRight ==-1){</span>
<span class="fc" id="L454">				return ClipPointsType.ALL_LOW_QUALITY;</span>
	        }
<span class="fc bfc" id="L456" title="All 2 branches covered.">	        if((qualRight-qualLeft) &lt;0){</span>
	            //invalid converted ace file? 
<span class="fc" id="L458">	            return ClipPointsType.NEGATIVE_VALID_RANGE;</span>
	        }    
	        
	        //dkatzel 4/2011 - There have been cases when qual coords and align coords
	        //do not match; usually qual is a sub set of align
	        //but occasionally, qual goes beyond the align coords.
	        //I guess this happens in a referenced based alignment for
	        //reads at the edges when the reads have good quality 
	        //beyond the reference.
	        //It might also be possible that the read has been 
	        //edited and that could have changed the coordinates.
	        //Therefore intersect the qual and align coords
	        //to find the region we are interested in
<span class="fc" id="L471">	        Range qualityRange = Range.of(CoordinateSystem.RESIDUE_BASED, qualLeft,qualRight);</span>
<span class="fc" id="L472">	        Range alignmentRange = Range.of(CoordinateSystem.RESIDUE_BASED, alignLeft,alignRight);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">	        if(qualityRange.intersects(alignmentRange)){</span>
<span class="fc" id="L474">	        	return ClipPointsType.VALID;</span>
	        }else{	        
	        	//no intersection! 
	        	//I've only seen this on really bad quality
	        	//////////////////////////////////////////////////////////
	        	//dkatzel - 2012-01-26
	        	//email response from David Gordon (author of consed)
	        	//regarding what to do if these ranges don't overlap
	        	//From David Gordon:
	        	//the first 2 numbers indicate the high quality segment
	        	//(roughly corresponding to that above quality 13).
	        	//The last 2 numbers indicates the portion of the read aligned
	        	//to the consensus sequence.
	        	//
	        	//Hence there is a very short high quality segment 
	        	//634-649 (only 16 bases).  And the portion of the 
	        	//read aligned to the consensus is 851-1758 is very low quality.
	        	//
	        	//Consed treats these reads like any others.  
	        	//The &quot;dim&quot; menu on the Aligned Reads Window 
	        	//indicates what portion of the read to dim.  
	        	//If you set it on dim both low quality and unaligned, 
	        	//this entire read would be dimmed.
	        	/////////////////////////////////////////////////////////
	        	//dkatzel -therefore if consed dims the entire read
	        	//that's enough justification for me to throw the read out
<span class="fc" id="L500">	        	return ClipPointsType.NO_HIGH_QUALITY_ALIGNMENT_INTERSECTION;</span>
	        }
		}
    }
    
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>