<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MaxInfoTrimmer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trim.trimmomatic</a> &gt; <span class="el_source">MaxInfoTrimmer.java</span></div><h1>MaxInfoTrimmer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trim.trimmomatic;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.trim.QualityTrimmer;

/**
 * {@link QualityTrimmer} implementation of Trimomatic's MaximumInfo algorithm
 * which is an adaptive quality trimmer which balances read length and error
 * rate to maximize the value of each read. The algorithm tries to balance read
 * length and quality to maximize the unique alignment length.
 * &lt;p&gt;
 * From the Trimomatic Manual: &lt;blockquote&gt; For many applications, the “value”
 * of a read is a balance between three factors:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Minimal read length: The read needs to be long enough that it can be uniquely
 * located within the target sequence. Extremely short reads, which can be
 * placed into many different locations within the target sequence, provide
 * little value. The length required before a read is likely to be unique
 * depends on the size and complexity of the target sequence, but a typical
 * target length would be in the order of 40 bases.&lt;/li&gt;
 * &lt;li&gt;
 * Additional read length: There may be added value in retaining additional
 * bases, beyond those needed to uniquely place a read. This is dependent
 * primarily on the application. For pure counting applications, such as
 * RNA-Seq, unique placement is sufficient. For assembly or variant finding
 * tasks, additional bases provide extra evidence for or against putative
 * results, and thus can be valuable.&lt;/li&gt;
 * &lt;li&gt;
 * Error sensitivity: The downstream analysis can be more or less sensitive to
 * errors within the data. This is determined by the tools and settings used.
 * One extreme would be tools were a single base error would cause the entire
 * read to be ignored, which favours aggressive quality trimming. The other
 * extreme would be tools which can tolerate or even correct a large number of
 * errors, which favour retaining as much data as possible.&lt;/li&gt;
 * &lt;/ul&gt;
 * Two user provided values are used, the “target read length”, which affects
 * the first scoring factor, and the “strictness” which affects the balance
 * between the second and third factor. Trimming is applied to
 * 
 * &lt;/blockquote&gt;
 * 
 * @author dkatzel
 *
 * @since 5.2
 */
public class MaxInfoTrimmer implements QualityTrimmer{

<span class="fc" id="L72">    private static int MAX_READ_LENGTH = 1_000; // match trimmomatic which only goes to 1000 which might be too short</span>
    private final long[] qualLookup;
    private final long[] factorLookup;
    /**
     * Create a new Trimmer object.
     * @param targetLength Minimal read length: The read needs to be long enough that it can be uniquely located
within the target sequence. Extremely short reads, which can be placed into many
different locations within the target sequence, provide little value. The length required
before a read is likely to be unique depends on the size and complexity of the target
sequence, but a typical target length would be in the order of 40 bases. must be &amp;ge; 1.

     * @param strictness the a value between 0 and 1 that affects the balance between the allowed error rate
     * and additional length.
     */
<span class="fc" id="L86">    public MaxInfoTrimmer(int targetLength, double strictness){</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if(targetLength &lt;1){</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;target length must be &gt;=1&quot;);</span>
        }
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">        if(strictness &lt; 0 || strictness &gt;1){</span>
<span class="nc" id="L91">            throw new IllegalArgumentException(&quot;strictness must be between 0 and 1&quot;);</span>
        }
        
<span class="fc" id="L94">        double[] qualLookup = new double[PhredQuality.MAX_VALUE +1];</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        for(int i=0; i&lt; qualLookup.length; i++){</span>
<span class="fc" id="L96">           qualLookup[i] = Math.log(1-Math.pow(0.1, (0.5+i)/10.0))*strictness;</span>
        }
        
<span class="fc" id="L99">        double[] factorLookup = new double[MAX_READ_LENGTH];</span>
<span class="fc" id="L100">        double leniency = 1 - strictness;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for(int i=0; i&lt; MAX_READ_LENGTH; i++){            </span>
<span class="fc" id="L102">            factorLookup[i] = Math.log(1D /(1 + Math.exp(targetLength - i -1))) + (Math.log(i +1) * (leniency));</span>
        }
        //we have to match trimomatic 100% so we have to normalize exactly like they do
        //and use longs instead of doubles...
<span class="fc" id="L106">        double ratio = Math.max(calcNormalizationRatio(qualLookup, MAX_READ_LENGTH*2),</span>
<span class="fc" id="L107">                calcNormalizationRatio(factorLookup, MAX_READ_LENGTH*2)</span>
                );
<span class="fc" id="L109">        this.qualLookup = normalize(qualLookup, ratio);</span>
<span class="fc" id="L110">        this.factorLookup = normalize(factorLookup, ratio);</span>
        
<span class="fc" id="L112">    }</span>

    private static double calcNormalizationRatio(double array[], int margin)
    {
<span class="fc" id="L116">            double maxVal=array[0];</span>
    
<span class="fc bfc" id="L118" title="All 2 branches covered.">            for(int i=1;i&lt;array.length;i++)</span>
                    {
<span class="fc" id="L120">                    double val=Math.abs(array[i]);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                    if(val&gt;maxVal)</span>
<span class="fc" id="L122">                    maxVal=val;</span>
            }
    
<span class="fc" id="L125">            return Long.MAX_VALUE/(maxVal*margin);  </span>
    }
    
    private static long[] normalize(double array[], double ratio)
    {
<span class="fc" id="L130">            long out[]=new long[array.length];</span>
            
<span class="fc bfc" id="L132" title="All 2 branches covered.">            for(int i=0;i&lt;array.length;i++)</span>
<span class="fc" id="L133">                    out[i]=(long)(array[i]*ratio);</span>
                    
<span class="fc" id="L135">            return out;</span>
    }
    @Override
    public Range trim(QualitySequence qualities) {
<span class="fc" id="L139">        return trim(qualities.toArray());</span>

    }
    
    @Override
    public Range trim(QualitySequenceBuilder builder) {
<span class="nc" id="L145">        return trim(builder.toArray());</span>
    }
    
    private Range trim(byte[] quals){
<span class="fc" id="L149">        int bestOffset = -1;</span>
<span class="fc" id="L150">        double maxScore = -Double.MAX_VALUE;</span>
        
<span class="fc" id="L152">        long acumulativeQual=0;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        for(int i=0; i&lt; quals.length; i++){</span>
<span class="fc" id="L154">            acumulativeQual +=qualLookup[quals[i]];</span>
<span class="fc" id="L155">           long score= acumulativeQual + factorLookup[i];</span>
           
<span class="fc bfc" id="L157" title="All 2 branches covered.">           if(score &gt;= maxScore){</span>
<span class="fc" id="L158">               maxScore = score;</span>
<span class="fc" id="L159">               bestOffset =i;</span>
           }
        }

<span class="pc bpc" id="L163" title="2 of 4 branches missed.">        if(bestOffset &lt; 0 || maxScore ==0){</span>
<span class="nc" id="L164">            return Range.ofLength(0);</span>
        }
<span class="fc" id="L166">        return Range.ofLength(bestOffset +1);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>