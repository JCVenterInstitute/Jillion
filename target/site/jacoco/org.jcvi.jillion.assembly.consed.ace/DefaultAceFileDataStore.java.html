<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultAceFileDataStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.ace</a> &gt; <span class="el_source">DefaultAceFileDataStore.java</span></div><h1>DefaultAceFileDataStore.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.ace;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.datastore.DataStore;
import org.jcvi.jillion.core.datastore.DataStoreClosedException;
import org.jcvi.jillion.core.datastore.DataStoreEntry;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.datastore.DataStoreFilter;
import org.jcvi.jillion.core.datastore.DataStoreFilters;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.internal.core.datastore.DataStoreStreamingIterator;
/**
 * {@code DefaultAceFileDataStore} is a AceContigDataStore
 * implementation that stores all the {@link AceContig}s
 * in a Map.  This implementation is not very 
 * memory efficient and therefore should not be used
 * for large ace files.
 * @author dkatzel
 *
 *
 */
final class DefaultAceFileDataStore implements AceFileDataStore{

	/**
	 * {@link DataStore} wrapper of our {@link AceContig}s.
	 */
	private final DataStore&lt;AceContig&gt; delegate;
	/**
	 * The total number of reads in our datastore
	 * (sum of all the reads in the contigs).
	 */
    private final long totalNumberOfReads;
    /**
     * List of all the {@link WholeAssemblyAceTag}s
     * in the ace file in the order they are
     * declared in the file.
     */
    private final List&lt;WholeAssemblyAceTag&gt; wholeAssemblyTags;
    /**
     * List of all the {@link ConsensusAceTag}s
     * in the ace file in the order they are
     * declared in the file.
     */
    private final List&lt;ConsensusAceTag&gt; consensusTags;
    /**
     * List of all the {@link ReadAceTag}s
     * in the ace file in the order they are
     * declared in the file.
     */
    private final List&lt;ReadAceTag&gt; readTags;
    
    public static AceFileDataStore create(InputStream aceFileStream) throws IOException{
<span class="fc" id="L82">    	return create(aceFileStream, DataStoreFilters.alwaysAccept());</span>
    }
    
    public static AceFileDataStore create(InputStream aceFileStream, DataStoreFilter filter) throws IOException{
<span class="fc" id="L86">    	Visitor builder = new Visitor(filter);</span>
<span class="fc" id="L87">    	AceParser parser = AceFileParser.create(aceFileStream);</span>
<span class="fc" id="L88">    	parser.parse(builder);</span>
<span class="fc" id="L89">    	return new DefaultAceFileDataStore(builder);</span>
    }
    public static AceFileDataStore create(File aceFile) throws IOException{
<span class="fc" id="L92">    	return create(aceFile, DataStoreFilters.alwaysAccept());</span>
    }
    public static AceFileDataStore create(File aceFile, DataStoreFilter filter) throws IOException{
<span class="fc" id="L95">    	Visitor builder = new Visitor(filter);</span>
<span class="fc" id="L96">    	AceParser parser = AceFileParser.create(aceFile);</span>
<span class="fc" id="L97">    	parser.parse(builder);</span>
<span class="fc" id="L98">    	return new DefaultAceFileDataStore(builder);</span>
    }
    
<span class="fc" id="L101">	private DefaultAceFileDataStore(Visitor builder) {</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">		if(!builder.completed){</span>
<span class="nc" id="L103">			throw new IllegalStateException(&quot;did not completely parse ace file&quot;);</span>
		}
<span class="fc" id="L105">		this.delegate = DataStore.of(builder.map);</span>
<span class="fc" id="L106">		this.totalNumberOfReads = builder.totalNumberOfReads;</span>
<span class="fc" id="L107">		this.wholeAssemblyTags = builder.wholeAssemblyTags;</span>
<span class="fc" id="L108">		this.consensusTags = builder.consensusTags;</span>
<span class="fc" id="L109">		this.readTags = builder.readTags;</span>
<span class="fc" id="L110">	}	</span>
    
	
	@Override
	public StreamingIterator&lt;String&gt; idIterator() throws DataStoreException {
<span class="fc" id="L115">		return delegate.idIterator();</span>
	}


	@Override
	public AceContig get(String id) throws DataStoreException {
<span class="fc" id="L121">		return delegate.get(id);</span>
	}


	@Override
	public StreamingIterator&lt;DataStoreEntry&lt;AceContig&gt;&gt; entryIterator()
			throws DataStoreException {
<span class="nc" id="L128">		return delegate.entryIterator();</span>
	}

	@Override
	public boolean contains(String id) throws DataStoreException {
<span class="fc" id="L133">		return delegate.contains(id);</span>
	}


	@Override
	public long getNumberOfRecords() throws DataStoreException {
<span class="fc" id="L139">		return delegate.getNumberOfRecords();</span>
	}


	@Override
	public boolean isClosed() {
<span class="fc" id="L145">		return delegate.isClosed();</span>
	}


	@Override
	public StreamingIterator&lt;AceContig&gt; iterator() throws DataStoreException {
<span class="fc" id="L151">		return delegate.iterator();</span>
	}


	@Override
	public void close() throws IOException {
<span class="fc" id="L157">		delegate.close();</span>
		
<span class="fc" id="L159">	}</span>


	@Override
	public long getNumberOfTotalReads(){
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">		if(isClosed()){</span>
<span class="nc" id="L165">			throw new DataStoreClosedException(&quot;closed&quot;);</span>
		}
<span class="fc" id="L167">		return totalNumberOfReads;</span>
	}


	@Override
	public StreamingIterator&lt;WholeAssemblyAceTag&gt; getWholeAssemblyTagIterator()
			throws DataStoreException {
<span class="fc" id="L174">		return DataStoreStreamingIterator.create(this, wholeAssemblyTags.iterator());</span>
	}


	@Override
	public StreamingIterator&lt;ReadAceTag&gt; getReadTagIterator()
			throws DataStoreException {
<span class="fc" id="L181">		return DataStoreStreamingIterator.create(this, readTags.iterator());</span>
	}


	@Override
	public StreamingIterator&lt;ConsensusAceTag&gt; getConsensusTagIterator()
			throws DataStoreException {
<span class="fc" id="L188">		return DataStoreStreamingIterator.create(this, consensusTags.iterator());</span>
	}


	private static final class Visitor implements AceFileVisitor{

		private final DataStoreFilter filter;
		
		private Map&lt;String, AceContig&gt; map;
		/**
		 * The total number of reads in our datastore
		 * (sum of all the reads in the contigs).
		 */
	    private long totalNumberOfReads;
	    /**
	     * List of all the {@link WholeAssemblyAceTag}s
	     * in the ace file in the order they are
	     * declared in the file.
	     */
<span class="fc" id="L207">	    private final List&lt;WholeAssemblyAceTag&gt; wholeAssemblyTags = new ArrayList&lt;WholeAssemblyAceTag&gt;();</span>
	    /**
	     * List of all the {@link ConsensusAceTag}s
	     * in the ace file in the order they are
	     * declared in the file.
	     */
<span class="fc" id="L213">	    private final List&lt;ConsensusAceTag&gt; consensusTags = new ArrayList&lt;ConsensusAceTag&gt;();</span>
	    /**
	     * List of all the {@link ReadAceTag}s
	     * in the ace file in the order they are
	     * declared in the file.
	     */
<span class="fc" id="L219">	    private final List&lt;ReadAceTag&gt; readTags = new ArrayList&lt;ReadAceTag&gt;();</span>
	    
<span class="fc" id="L221">	    private boolean completed = false;</span>
	    
<span class="fc" id="L223">		public Visitor(DataStoreFilter filter) {</span>
<span class="fc" id="L224">			this.filter = filter;</span>
<span class="fc" id="L225">		}</span>

		@Override
		public void visitHeader(int numberOfContigs, long totalNumberOfReads) {
<span class="fc" id="L229">			this.map = new LinkedHashMap&lt;String, AceContig&gt;(numberOfContigs);</span>
<span class="fc" id="L230">		}</span>

		@Override
		public AceContigVisitor visitContig(AceFileVisitorCallback callback, final String contigId, int numberOfBases,
				int numberOfReads, int numberOfBaseSegments,
				boolean reverseComplemented) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">			if(filter.accept(contigId)){</span>
<span class="fc" id="L237">				return new AbstractAceContigBuilderVisitor(contigId, numberOfBases, numberOfReads) {</span>
					
					@Override
					protected void visitContig(AceContigBuilder builder) {
<span class="fc" id="L241">						totalNumberOfReads += builder.numberOfReads();</span>
<span class="fc" id="L242">						map.put(contigId, builder.build());</span>
						
<span class="fc" id="L244">					}</span>
				};
			}
			//skip 
<span class="fc" id="L248">			return null;</span>
		}

		@Override
		public void visitReadTag(String id, String type, String creator,
				long gappedStart, long gappedEnd, Date creationDate,
				boolean isTransient) {
<span class="fc" id="L255">			readTags.add(new ReadAceTag(id, type, creator, creationDate, </span>
<span class="fc" id="L256">                    Range.of(gappedStart,gappedEnd), isTransient));</span>
			
<span class="fc" id="L258">		}</span>

		@Override
		public AceConsensusTagVisitor visitConsensusTag(String id, String type,
				String creator, long gappedStart, long gappedEnd,
				Date creationDate, boolean isTransient) {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">			if(filter.accept(id)){</span>
<span class="fc" id="L265">				return new AbstractAceConsensusTagVisitor(id, type,creator, </span>
<span class="fc" id="L266">						gappedStart, gappedEnd, creationDate, isTransient) {</span>
					
					@Override
					protected void visitConsensusTag(ConsensusAceTag consensusTag) {
<span class="fc" id="L270">						consensusTags.add(consensusTag);						</span>
<span class="fc" id="L271">					}</span>
				};
			}
			//skip
<span class="nc" id="L275">			return null;</span>
		}

		@Override
		public void visitWholeAssemblyTag(String type, String creator,
				Date creationDate, String data) {
<span class="fc" id="L281">			wholeAssemblyTags.add(new WholeAssemblyAceTag(type, creator, creationDate, data.trim()));</span>
			
<span class="fc" id="L283">		}</span>

		@Override
		public void visitEnd() {
<span class="fc" id="L287">			completed = true;			</span>
<span class="fc" id="L288">		}</span>

		@Override
		public void halted() {
			//no-op			
<span class="nc" id="L293">		}		</span>
	}    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>