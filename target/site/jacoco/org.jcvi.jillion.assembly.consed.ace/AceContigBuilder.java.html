<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AceContigBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.ace</a> &gt; <span class="el_source">AceContigBuilder.java</span></div><h1>AceContigBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Feb 6, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.consed.ace;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.assembly.ContigBuilder;
import org.jcvi.jillion.assembly.util.CoverageMap;
import org.jcvi.jillion.assembly.util.CoverageMapBuilder;
import org.jcvi.jillion.assembly.util.CoverageRegion;
import org.jcvi.jillion.assembly.util.GapQualityValueStrategy;
import org.jcvi.jillion.assembly.util.Slice;
import org.jcvi.jillion.assembly.util.SliceBuilder;
import org.jcvi.jillion.assembly.util.consensus.ConsensusCaller;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.core.qual.QualitySequenceDataStore;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.util.MapUtil;
import org.jcvi.jillion.core.util.ThrowingStream;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.internal.assembly.DefaultContig;
/**
 * Builder
 * for {@link AceContig}s that allows
 * creating {@link AceContig} objects read by read by adding assembled reads
 * and setting a consensus.  An {@link AceContigBuilder}
 * can be used to create AceContig objects that 
 * have been created by an assembler or can be used
 * to create contigs from &quot;scratch&quot;.
 * There are additional methods to allow
 * the contig consensus or underlying
 * reads to be modified before
 * the creation of the {@link AceContig} instance
 * (which is immutable).
 * &lt;p&gt;
 * This class is not thread-safe.
 * @author dkatzel
 *
 *
 */
public final class  AceContigBuilder implements ContigBuilder&lt;AceAssembledRead,AceContig&gt;{
    /**
     * default quality value that every basecall will get
     * if consensus caller is used to recall the consensus
     * but no {@link QualitySequenceDataStore} is given.
     */
<span class="fc" id="L92">    private static final PhredQuality DEFAULT_QUALITY = PhredQuality.valueOf(30);</span>
	/**
	 * {@link ConsensusCaller} used to update the
	 * consensus during {@link #build()}.  If set to {@code null},
	 * then no recalling is to be done (null by default).
	 */
<span class="pc" id="L98">	private ConsensusCaller consensusCaller =null;</span>
	/**
	 * {@link QualitySequenceDataStore} used during
	 * consensus recalling.  Set to null if 
	 * no recalling is to be done. (null by default).
	 */
<span class="pc" id="L104">	private QualitySequenceDataStore qualityDataStore =null;</span>
	
<span class="pc" id="L106">	private GapQualityValueStrategy qualityValueStrategy=GapQualityValueStrategy.LOWEST_FLANKING;</span>
	
    private NucleotideSequence initialConsensus;
    private NucleotideSequenceBuilder mutableConsensus;
    private String contigId;
    private final Map&lt;String, AceAssembledReadBuilder&gt; aceReadBuilderMap;
<span class="pc" id="L112">    private int contigLeft= -1;</span>
<span class="pc" id="L113">    private int contigRight = -1;</span>
<span class="pc" id="L114">    private volatile boolean built=false;</span>
<span class="pc" id="L115">    private boolean complemented=false;</span>
<span class="pc" id="L116">    private boolean computeConsensusQualities=false;</span>
    
    private QualitySequenceBuilder mutableConsensusQualities;
    /**
     * Create a new {@link AceContigBuilder} for a contig with the given
     * contig id and starting with the given consensus.  Both the contig id
     * and the consensus can be changed by calling methods on the returned
     * builder.
     * @param contigId the initial contig id to use for this contig (may later be changed)
     * @param initialConsensus the initial contig consensus for this contig (may be changed later)
     * @throws NullPointerException if contigId or consensus are null.
     */
    public AceContigBuilder(String contigId, String initialConsensus){
<span class="fc" id="L129">       this(contigId,                   </span>
<span class="fc" id="L130">    		   new NucleotideSequenceBuilder(initialConsensus).build()</span>
        );
<span class="fc" id="L132">    }</span>
    
    public AceContigBuilder setInitialConsensusQualities(QualitySequence consensusQualities){
<span class="nc" id="L135">    	this.mutableConsensusQualities = new QualitySequenceBuilder(consensusQualities);</span>
<span class="nc" id="L136">    	return this;</span>
    }
    
    private QualitySequenceBuilder createDefaultQualitySequenceBuilder(int ungappedConsensusLength){
<span class="fc" id="L140">    	byte[] quals = new byte[ungappedConsensusLength];</span>
<span class="fc" id="L141">    	Arrays.fill(quals, DEFAULT_QUALITY.getQualityScore());</span>
<span class="fc" id="L142">    	return new QualitySequenceBuilder(quals);</span>
    }
    /**
     * Create a new {@link AceContigBuilder} for a contig with the given
     * contig id and starting with the given consensus.  Both the contig id
     * and the consensus can be changed by calling methods on the returned
     * builder.
     * @param contigId the initial contig id to use for this contig (may later be changed)
     * @param initialConsensus the initial contig consensus for this contig (may be changed later)
     * @throws NullPointerException if contigId or consensus are null.
     */
<span class="fc" id="L153">    public AceContigBuilder(String contigId, NucleotideSequence initialConsensus){</span>
<span class="fc" id="L154">        checkNotNull(contigId);</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if(initialConsensus ==null){</span>
<span class="nc" id="L156">            throw new NullPointerException(&quot;consensus can not be null&quot;);</span>
        }
<span class="fc" id="L158">    	this.initialConsensus = initialConsensus;</span>
<span class="fc" id="L159">    	 this.contigId = contigId;</span>
<span class="fc" id="L160">    	 this.mutableConsensus = new NucleotideSequenceBuilder(initialConsensus);</span>
<span class="fc" id="L161">    	 aceReadBuilderMap = new HashMap&lt;String, AceAssembledReadBuilder&gt;(200);</span>
<span class="fc" id="L162">    }</span>

	public void checkNotNull(String contigId) {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">		if(contigId ==null){</span>
<span class="nc" id="L166">            throw new NullPointerException(&quot;contig id can not be null&quot;);</span>
        }
<span class="fc" id="L168">	}</span>
    
<span class="fc" id="L170">    public AceContigBuilder(String contigId, ConsensusCaller consensusCaller){</span>
<span class="fc" id="L171">    	checkNotNull(contigId);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if(consensusCaller ==null){</span>
<span class="nc" id="L173">            throw new NullPointerException(&quot;consensusCaller can not be null&quot;);</span>
        }
<span class="fc" id="L175">    	 this.contigId = contigId;</span>
<span class="fc" id="L176">    	 this.mutableConsensus = null;</span>
<span class="fc" id="L177">    	 recallConsensus(consensusCaller);</span>
    	 
<span class="fc" id="L179">    	 aceReadBuilderMap = new HashMap&lt;String, AceAssembledReadBuilder&gt;(200);</span>
<span class="fc" id="L180">    }</span>
    /**
     * Create a new {@link AceContigBuilder} for a &lt;strong&gt;de novo&lt;/strong&gt; contig
     * that will have the given contig id.
     * There is initially, no consensus 
     * ({@link #getConsensusBuilder()} will return {@code null})
     * Once reads are added and the contig is built by calling
     * {@link #build()}
     * the consensus will be created by using the underlying
     * read information to call consensus using
     * the given {@link ConsensusCaller},
     *  {@link QualitySequenceDataStore} and {@link GapQualityValueStrategy}.
     * @param contigId the initial contig id to use for this contig (may later be changed)
     * {@link ConsensusCaller} and {@link QualitySequenceDataStore}
     * which contains the quality data for all of the reads in this ace contig.
     * The consensus will get recalled inside the {@link #build()}
     * and {@link #recallConsensusNow()}.
     * method before the {@link AceContig} instance is created.
     * @param consensusCaller the {@link ConsensusCaller}  instance to use
     * to recall the consensus of this contig; can not be null.
     * @param qualityDataStore the {@link QualitySequenceDataStore}
     * which contains all the quality data for all of the reads 
     * that &lt;strong&gt;will be added&lt;/strong&gt; to this contig; can not be null.
     * @param qualityValueStrategy the {@link GapQualityValueStrategy}
     * that will be used to compute the quality values of all
     * of the read's gaps.
     * @throws NullPointerException if any of the parameters are null.
     */
    public AceContigBuilder(String contigId, ConsensusCaller consensusCaller, 
    		QualitySequenceDataStore qualityDataStore,
<span class="nc" id="L210">    		GapQualityValueStrategy qualityValueStrategy){</span>
<span class="nc" id="L211">        checkNotNull(contigId);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if(consensusCaller ==null){</span>
<span class="nc" id="L213">            throw new NullPointerException(&quot;consensusCaller can not be null&quot;);</span>
        }
<span class="nc" id="L215">    	 this.contigId = contigId;</span>
<span class="nc" id="L216">    	 this.mutableConsensus = null;</span>
<span class="nc" id="L217">    	 recallConsensus(consensusCaller, qualityDataStore, qualityValueStrategy);</span>
    	 
<span class="nc" id="L219">    	 aceReadBuilderMap = new HashMap&lt;String, AceAssembledReadBuilder&gt;(200);</span>
<span class="nc" id="L220">    }</span>
    
    /**
     * Create a new {@link AceContigBuilder} for a contig with the given
     * contig id and starting with the given consensus.  Both the contig id
     * and the consensus can be changed by calling methods on the returned
     * builder.
     * @param contigId the initial contig id to use for this contig (may later be changed)
     * @param initialConsensus the initial contig consensus for this contig (may be changed later)
     * @param estimatedNumberOfReads expected number of reads that will be added to this
     * contig.  This value is only used to allocate the initial map sizes for internal
     * data structures as a performance optimization.  Must be &amp;ge;0.
     * 
     * @throws NullPointerException if contigId or consensus are null.
     * @throws IllegalArgumentException if estimatedNumberOfReads
     * is &amp;lt; 0
     */
    public AceContigBuilder(String contigId, NucleotideSequence initialConsensus,
<span class="fc" id="L238">    		int estimatedNumberOfReads){</span>
<span class="fc" id="L239">        checkNotNull(contigId);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if(initialConsensus ==null){</span>
<span class="nc" id="L241">            throw new NullPointerException(&quot;consensus can not be null&quot;);</span>
        }
<span class="fc" id="L243">    	this.initialConsensus = initialConsensus;</span>
<span class="fc" id="L244">    	 this.contigId = contigId;</span>
<span class="fc" id="L245">    	 this.mutableConsensus = new NucleotideSequenceBuilder(initialConsensus);</span>
<span class="fc" id="L246">    	 int capacity = MapUtil.computeMinHashMapSizeWithoutRehashing(estimatedNumberOfReads);</span>
<span class="fc" id="L247">    	 aceReadBuilderMap = new HashMap&lt;String, AceAssembledReadBuilder&gt;(capacity);</span>
<span class="fc" id="L248">    }</span>
    /**
     * Create a new instance of DefaultAceContigBuilder
     * whose initial state is an exact copy
     * of the given AceContig.
     * @param copy the {@link AceContig} to copy
     * can not be null.
     * @throws NullPointerException if copy is null.
     */
<span class="fc" id="L257">    public AceContigBuilder(AceContig copy){</span>
<span class="fc" id="L258">    	this.contigId=copy.getId();</span>
<span class="fc" id="L259">    	this.initialConsensus = copy.getConsensusSequence();</span>
<span class="fc" id="L260">    	this.mutableConsensus = new NucleotideSequenceBuilder(initialConsensus);</span>
<span class="fc" id="L261">    	aceReadBuilderMap = new HashMap&lt;String, AceAssembledReadBuilder&gt;(MapUtil.computeMinHashMapSizeWithoutRehashing(copy.getNumberOfReads()));</span>
<span class="fc" id="L262">    	StreamingIterator&lt;AceAssembledRead&gt; readIter =null;</span>
    	try{
<span class="fc" id="L264">    		readIter = copy.getReadIterator();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">    		while(readIter.hasNext()){</span>
<span class="fc" id="L266">    			this.addRead(readIter.next());</span>
    		}
    	}finally{
<span class="pc" id="L269">    		IOUtil.closeAndIgnoreErrors(readIter);</span>
<span class="fc" id="L270">    	}</span>
<span class="fc" id="L271">    }</span>
    /**
     * Set this contig as being complemented.
     * This does not actually modify either the consensus
     * or underlying read sequences.  If you wish
     * to actually reverse complement the basecalls
     * you must use call {@link NucleotideSequenceBuilder#reverseComplement()}
     * method on the consensus builder returned by {@link #getConsensusBuilder()}
     * and on each underlying read using {@link #getAllAssembledReadBuilders()}.
     * @param complemented is this ace contig complemented or not.
     * @return this
     */
    public AceContigBuilder setComplemented(boolean complemented){
<span class="nc" id="L284">        this.complemented = complemented;</span>
<span class="nc" id="L285">        return this;</span>
    }
    /**
     * Recall the consensus using the given
     * {@link ConsensusCaller} and {@link QualitySequenceDataStore}
     * which contains the quality data for all of the reads in this ace contig.
     * The consensus will get recalled inside the {@link #build()}
     * and {@link #recallConsensusNow()}.
     * method before the {@link AceContig} instance is created.
     * @param consensusCaller the {@link ConsensusCaller}  instance to use
     * to recall the consensus of this contig; can not be null.
     * @param qualityDataStore the {@link QualitySequenceDataStore}
     * which contains all the quality data for all of the reads
     * in this contig; can not be null. This value will override
     * the quality datastore set by {@link #computeConsensusQualities(QualitySequenceDataStore)}
     * and vice versa, last one called wins. (This is more for user's
     * convenience in case they don't want to do one or the other).
     * @param qualityValueStrategy the {@link GapQualityValueStrategy}
     * that will be used to compute the quality values of all
     * of the read's gaps.
     * @return this.
     * @throws NullPointerException if any parameter is null.
     */
    @Override
    public AceContigBuilder recallConsensus(ConsensusCaller consensusCaller, 
    		QualitySequenceDataStore qualityDataStore,
    		GapQualityValueStrategy qualityValueStrategy){
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    	if(consensusCaller ==null){</span>
<span class="nc" id="L313">    		throw new NullPointerException(&quot;consensus caller can not be null&quot;);</span>
    	}
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">    	if(qualityDataStore ==null){</span>
<span class="nc" id="L316">    		throw new NullPointerException(&quot;quality datastore can not be null&quot;);</span>
    	}
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">    	if(qualityValueStrategy ==null){</span>
<span class="nc" id="L319">    		throw new NullPointerException(&quot;quality value strategy can not be null&quot;);</span>
    	}
<span class="fc" id="L321">    	this.consensusCaller=consensusCaller;</span>
<span class="fc" id="L322">    	this.qualityDataStore = qualityDataStore;</span>
<span class="fc" id="L323">    	this.qualityValueStrategy = qualityValueStrategy;</span>
<span class="fc" id="L324">    	return this;</span>
    }
    
    public AceContigBuilder updateConsensusRecaller(ConsensusCaller consensusCaller){
<span class="nc bnc" id="L328" title="All 2 branches missed.">    	if(consensusCaller ==null){</span>
<span class="nc" id="L329">    		throw new NullPointerException(&quot;consensus caller can not be null&quot;);</span>
    	}
<span class="nc" id="L331">    	this.consensusCaller=consensusCaller;</span>
<span class="nc" id="L332">    	return this;</span>
    }
    /**
     * Compute the consensus Qualities using the same
     * algorithm that consed uses.    The read quality values
     * will be taken from the {@link QualitySequenceDataStore} set by
     * {@link #recallConsensus(ConsensusCaller, QualitySequenceDataStore, GapQualityValueStrategy)}.
     * If you do not wish to recall consensus, then use 
     * {@link #computeConsensusQualities(QualitySequenceDataStore)}.
     * If this method is not specified
     * AND {@link #setInitialConsensusQualities(QualitySequence)} is not
     * called, then the consensus qualities will be set to a dummy value
     * of all 30.
     * @return this
     * @see #computeConsensusQualities(QualitySequenceDataStore)
     * 
     */
    public AceContigBuilder computeConsensusQualities(){
<span class="nc" id="L350">    	this.computeConsensusQualities = true;</span>
<span class="nc" id="L351">    	return this;</span>
    }
    /**
     * Compute the consensus Qualities using the same
     * algorithm that consed uses.    The read quality values
     * will be taken from the given {@link QualitySequenceDataStore}.
     * If this method is not specified
     * AND {@link #setInitialConsensusQualities(QualitySequence)} is not
     * called, then the consensus qualities will be set to a dummy value
     * of all 30.
     * @param readQualityDataStore the {@link QualitySequenceDataStore}
     * to use to compute consensus qualities.  This value will override
     * the quality datastore set by {@link #recallConsensus(ConsensusCaller, QualitySequenceDataStore, GapQualityValueStrategy)}
     * and vice versa, last one called wins. (This is more for user's
     * convenience in case they don't want to do one or the other).
     * @return this
     * @throws NullPointerException if readQualityDataStore is null.
     */
    public AceContigBuilder computeConsensusQualities(QualitySequenceDataStore readQualityDataStore){
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">    	if(readQualityDataStore ==null){</span>
<span class="nc" id="L371">    		throw new NullPointerException(&quot;read quality datastore can not be null&quot;);</span>
    	}
<span class="fc" id="L373">    	this.computeConsensusQualities = true;</span>
    	
<span class="fc" id="L375">    	this.qualityDataStore = readQualityDataStore;</span>
<span class="fc" id="L376">    	return this;</span>
    }
    /**
     * Recall the consensus using the given
     * {@link ConsensusCaller} using faked quality data
     * where all basecalls (and gaps) all get the same quality value.
     * The consensus will get recalled inside the {@link #build()}
     * and from {@link #recallConsensusNow()}.
     * method before the {@link AceContig} instance is created.
     * @param consensusCaller the {@link ConsensusCaller}  instance to use
     * to recall the consensus of this contig; can not be null.
     * @return this.
     * @throws NullPointerException if any parameter is null.
     */
    @Override
    public AceContigBuilder recallConsensus(ConsensusCaller consensusCaller){
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">    	if(consensusCaller ==null){</span>
<span class="nc" id="L393">    		throw new NullPointerException(&quot;consensus caller can not be null&quot;);</span>
    	}
<span class="fc" id="L395">    	this.consensusCaller=consensusCaller;</span>
<span class="fc" id="L396">    	this.qualityDataStore = null;</span>
<span class="fc" id="L397">    	this.qualityValueStrategy = GapQualityValueStrategy.LOWEST_FLANKING;</span>
<span class="fc" id="L398">    	return this;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public AceContigBuilder setContigId(String contigId){
<span class="fc" id="L405">        checkNotNull(contigId);</span>
<span class="fc" id="L406">        this.contigId = contigId;</span>
<span class="fc" id="L407">        return this;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public String getContigId() {
<span class="fc" id="L414">        return contigId;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public int numberOfReads(){
<span class="fc" id="L421">        return aceReadBuilderMap.size();</span>
    }
    
    
    @Override
    public AceContigBuilder addRead(AceAssembledRead acePlacedRead) {
<span class="fc" id="L427">     return addRead(acePlacedRead.getId(),</span>
<span class="fc" id="L428">    		 acePlacedRead.getNucleotideSequence(),</span>
<span class="fc" id="L429">    		 (int)acePlacedRead.getGappedStartOffset(),</span>
<span class="fc" id="L430">    		 acePlacedRead.getDirection(),</span>
<span class="fc" id="L431">    		 acePlacedRead.getReadInfo().getValidRange(),</span>
<span class="fc" id="L432">    		 acePlacedRead.getPhdInfo(),</span>
<span class="fc" id="L433">    		 acePlacedRead.getReadInfo().getUngappedFullLength());</span>
    }
    
    /**
    * {@inheritDoc}
    */
    @Override
    public AceContigBuilder addAllReads(Iterable&lt;AceAssembledRead&gt; reads){
<span class="nc bnc" id="L441" title="All 2 branches missed.">        for(AceAssembledRead read : reads){</span>
<span class="nc" id="L442">            addRead(read);</span>
<span class="nc" id="L443">        }</span>
<span class="nc" id="L444">        return this;</span>
    }
	/**
    * {@inheritDoc}
    */
	@Override
    public Collection&lt;AceAssembledReadBuilder&gt; getAllAssembledReadBuilders(){
<span class="fc" id="L451">	    return aceReadBuilderMap.values();</span>
	}
    /**
    * {@inheritDoc}
    */
    @Override
    public AceAssembledReadBuilder getAssembledReadBuilder(String readId){
<span class="fc" id="L458">        return aceReadBuilderMap.get(readId);</span>
    }
    
    
    /**
    * {@inheritDoc}
    */
    @Override
    public AceContigBuilder removeRead(String readId) {
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if(readId==null){</span>
<span class="nc" id="L468">            throw new NullPointerException(&quot;read id can not be null&quot;);</span>
        }
<span class="fc" id="L470">        aceReadBuilderMap.remove(readId);</span>
<span class="fc" id="L471">        return this;</span>
    }
    
    /**
     * Add a read to this contig with the given values.  This read
     * can later get modified via the {@link #getAssembledReadBuilder(String)}.
     * The read to be added must be fully contained 
     * @param readId the id this read should have
     * @param validBases the gapped bases of this read that align (however well/badly)
     * to this contig and will be used as underlying sequence data for this contig.
     * @param offset the gapped start offset of this read into the contig
     * consensus.
     * @param dir the {@link Direction} of this read.
     * @param clearRange the ungapped clear range of the valid bases
     * relative to the full length non-trimmed raw full length
     * read from the sequence machine.
     * @param phdInfo the {@link PhdInfo} object for this read.
     * @param ungappedFullLength the ungapped full length
     * non-trimmed raw full length
     * read from the sequence machine.
     * @return this.
     * @throws NullPointerException if parameters are null
     * @throws IllegalArgumentException if a read with the same readId already exists in this contig.
     */
    public AceContigBuilder addRead(String readId, NucleotideSequence validBases, int offset,
            Direction dir, Range clearRange,PhdInfo phdInfo,int ungappedFullLength) {
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if(readId ==null){</span>
<span class="nc" id="L498">        	throw new NullPointerException(&quot;readId can not be null&quot;);</span>
        }
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if(aceReadBuilderMap.containsKey(readId)){</span>
<span class="nc" id="L501">        	throw new IllegalArgumentException(&quot;read with same id already in contig&quot; + readId);</span>
        }
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    	if(validBases ==null){</span>
<span class="nc" id="L504">    		throw new NullPointerException(&quot;valid bases can not be null&quot;);</span>
    	}
    	//contig left (and right) might be beyond consensus depending on how
        //trimmed the data is and what assembly/consensus caller is used.
        //force contig left and right to be within the called consensus
        //BCISD-211
<span class="fc" id="L510">        int correctedOffset = Math.max(0,offset);</span>
<span class="fc" id="L511">        adjustContigLeftAndRight(validBases, correctedOffset);</span>
<span class="fc" id="L512">        AceAssembledReadBuilder aceReadBuilder = createNewAceReadBuilder(readId, validBases, correctedOffset, dir, </span>
                    clearRange,phdInfo,ungappedFullLength);
            
            
<span class="fc" id="L516">            aceReadBuilderMap.put(readId,aceReadBuilder);</span>
        
<span class="fc" id="L518">        return this;</span>
    }
    private AceAssembledReadBuilder createNewAceReadBuilder(
            String readId, NucleotideSequence validBases, int offset,
            Direction dir, Range clearRange, PhdInfo phdInfo,int ungappedFullLength) {
<span class="fc" id="L523">        return DefaultAceAssembledRead.createBuilder(</span>
                readId,validBases,
                offset,
                dir,clearRange,phdInfo,ungappedFullLength, this);
    }
    private void adjustContigLeftAndRight(NucleotideSequence validBases, int offset) {
<span class="fc" id="L529">        adjustContigLeft(offset);</span>
<span class="fc" id="L530">        adjustContigRight(validBases, offset);</span>
<span class="fc" id="L531">    }</span>
    private void adjustContigRight(NucleotideSequence validBases, int offset) {
<span class="fc" id="L533">        final int endOfNewRead = offset+ (int)validBases.getLength()-1;</span>
<span class="fc" id="L534">        adjustContigRight(endOfNewRead);</span>
<span class="fc" id="L535">    }</span>
    private void adjustContigRight(int endOfNewRead) {
        
     //   if((initialConsensus ==null || endOfNewRead &lt;= initialConsensus.getLength()) &amp;&amp; (contigRight ==-1 || endOfNewRead &gt; contigRight)){
<span class="fc bfc" id="L539" title="All 4 branches covered.">    	 if(contigRight ==-1 || endOfNewRead &gt; contigRight){</span>
<span class="fc" id="L540">            contigRight = endOfNewRead ;</span>
        }
<span class="fc" id="L542">    }</span>
    private void adjustContigLeft(int offset) {
        
<span class="fc bfc" id="L545" title="All 4 branches covered.">        if(contigLeft ==-1 || offset &lt;contigLeft){</span>
<span class="fc" id="L546">            contigLeft = offset;</span>
        }
<span class="fc" id="L548">    }</span>
    
    
	void updatedReadRange(String id, long begin, long end) {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">		if(aceReadBuilderMap.containsKey(id)){</span>
<span class="fc" id="L553">			adjustContigLeft((int)begin);</span>
<span class="fc" id="L554">			adjustContigRight((int)end);</span>
		}
		
<span class="fc" id="L557">	}</span>

	/**
    * {@inheritDoc}
    */
    @Override
    public NucleotideSequenceBuilder getConsensusBuilder() {
<span class="fc" id="L564">        return mutableConsensus;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public AceContig build(){
<span class="fc bfc" id="L571" title="All 2 branches covered.">         if(built){</span>
<span class="fc" id="L572">             throw new IllegalStateException(&quot;this contig has already been built&quot;);</span>
         }
         
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if(numberOfReads()==0){</span>
            //force empty contig if no reads...
<span class="fc" id="L577">        	 built=true;</span>
<span class="fc" id="L578">            return new DefaultAceContigImpl(contigId, new NucleotideSequenceBuilder().build(),</span>
<span class="fc" id="L579">            		Collections.&lt;AceAssembledRead&gt;emptySet(),complemented,</span>
<span class="fc" id="L580">            		new QualitySequenceBuilder().build());</span>
        }
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if(consensusCaller !=null){</span>
<span class="fc" id="L583">			recallConsensusNow();</span>
        }
        
        
<span class="fc" id="L587">        SortedSet&lt;AceAssembledRead&gt; placedReads = new TreeSet&lt;AceAssembledRead&gt;(ConsedReadComparator.INSTANCE);</span>
        //contig left (and right) might be beyond consensus depending on how
        //trimmed the data is and what assembler/consensus caller is used.
        //force contig left and right to be within the called consensus
        //for example, reads that have negative start offsets
        //not AF records with negative values; actual negative alignment start offsets!
        //BCISD-211            
<span class="fc" id="L594">        contigLeft = Math.max(contigLeft, 0);</span>
<span class="fc" id="L595">        contigRight = Math.min(contigRight,(int)mutableConsensus.getLength()-1);</span>
        //here only include the gapped valid range consensus bases
        //throw away the rest            
<span class="fc" id="L598">        Range contigTrimRange = Range.of(contigLeft, contigRight);</span>
<span class="fc" id="L599">		NucleotideSequence validConsensus = mutableConsensus</span>
<span class="fc" id="L600">        		.copy()</span>
<span class="fc" id="L601">        		.trim(contigTrimRange)</span>
<span class="fc" id="L602">        		.build();</span>
		
<span class="fc bfc" id="L604" title="All 2 branches covered.">        for(AceAssembledReadBuilder aceReadBuilder : aceReadBuilderMap.values()){</span>
<span class="fc" id="L605">        	int newOffset = (int)aceReadBuilder.getBegin() - contigLeft;</span>
        	//turn off firing updates
        	//since we don't want to update contigLeft and right anymore
<span class="fc" id="L608">        	((DefaultAceAssembledRead.Builder)aceReadBuilder).setParentContigBuilder(null);</span>
<span class="fc" id="L609">            aceReadBuilder.setStartOffset(newOffset);</span>
<span class="fc" id="L610">            placedReads.add(aceReadBuilder.build(validConsensus));                </span>
<span class="fc" id="L611">        } </span>
       
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if(mutableConsensusQualities ==null){</span>
        	//no consensus qualities set
<span class="fc bfc" id="L615" title="All 2 branches covered.">        	if(computeConsensusQualities){</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        		if(qualityDataStore ==null){</span>
<span class="nc" id="L617">        			throw new NullPointerException(&quot;quality datastore can not be null&quot;);</span>
        		}
        		try {
<span class="fc" id="L620">					mutableConsensusQualities = new QualitySequenceBuilder(ConsedConsensusQualityComputer.computeConsensusQualities(mutableConsensus.build(), placedReads, qualityDataStore));</span>
<span class="nc" id="L621">				} catch (DataStoreException e) {</span>
<span class="nc" id="L622">					throw new IllegalStateException(&quot;error computing consensus quality sequence&quot;,e);</span>
<span class="fc" id="L623">				}</span>
        	}else{
<span class="fc" id="L625">        		mutableConsensusQualities = createDefaultQualitySequenceBuilder((int)mutableConsensus.getUngappedLength());</span>
        	}
        }else{
        	//make sure consensus quality length matches consensus ungapped length
<span class="nc" id="L629">        	long qualLength =mutableConsensusQualities.getLength();</span>
<span class="nc" id="L630">        	long ungappedLength = mutableConsensus.getUngappedLength();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        	if(qualLength != ungappedLength){</span>
<span class="nc" id="L632">        		throw new IllegalStateException(&quot;given consensus quality length does not match ungapped consensus length&quot;);</span>
        	}
        }
<span class="fc" id="L635">        NucleotideSequence fullConsensus = mutableConsensus.build();</span>
<span class="fc" id="L636">        Range ungappedContigTrimRange = Range.of(fullConsensus.getUngappedOffsetFor(contigLeft),</span>
<span class="fc" id="L637">        										fullConsensus.getUngappedOffsetFor(contigRight));</span>
<span class="fc" id="L638">        QualitySequence consensusQualitySequence = mutableConsensusQualities</span>
<span class="fc" id="L639">								        		.trim(ungappedContigTrimRange)</span>
<span class="fc" id="L640">								    			.build();</span>
<span class="fc" id="L641">        built=true;</span>
<span class="fc" id="L642">        aceReadBuilderMap.clear();</span>
<span class="fc" id="L643">        initialConsensus = null;</span>
        
<span class="fc" id="L645">        return new DefaultAceContigImpl(contigId, validConsensus,placedReads,complemented, consensusQualitySequence);</span>
    }
    /**
     * Recompute the contig
     * consensus now using the current reads in the contig
     * using the {@link ConsensusCaller} and optional quality data
     * that was set by
     * {@link #recallConsensus(ConsensusCaller)} or
     * {@link #recallConsensus(ConsensusCaller, QualitySequenceDataStore, GapQualityValueStrategy)}.
     * Only regions of the contig that have read coverage 
     * get recalled.  The Consensus of &quot;0x&quot; regions
     * remains unchanged.
     * 
     * If this method is called without first
     * setting a {@link ConsensusCaller}, then this
     * method will throw an {@link IllegalStateException}.
     * &lt;p&gt;
     * Recomputing the contig consensus may be computationally
     * expensive and time consuming.  So this method
     * should not be called on a regular basis.
     * Also, the contig consensus will always
     * get recalled during {@link #build()}
     * even if this method has already been called
     * since it is too hard to track if any underlying read changes occurred
     * in between.
     * @return this.
     * @throws IllegalStateException if a consensus caller
     * was not first set using {@link #recallConsensus(ConsensusCaller)} or
     * {@link #recallConsensus(ConsensusCaller, QualitySequenceDataStore, GapQualityValueStrategy)}.
     * @see #build()
     */
    @Override
    public AceContigBuilder recallConsensusNow() {
<span class="fc bfc" id="L678" title="All 2 branches covered.">    	if(consensusCaller==null){</span>
<span class="fc" id="L679">    		throw new IllegalStateException(&quot;must set consensus caller&quot;);</span>
    	}
    	final SliceBuilder builders[];
<span class="fc bfc" id="L682" title="All 2 branches covered.">    	if(mutableConsensus==null){</span>
<span class="fc" id="L683">    		builders = initializeSliceBuilders(contigRight+1);</span>
    	}else{
<span class="fc" id="L685">    		builders = initializeSliceBuilders(mutableConsensus.build());</span>
    	}
<span class="fc bfc" id="L687" title="All 2 branches covered.">    	for(AceAssembledReadBuilder aceReadBuilder : aceReadBuilderMap.values()){</span>
<span class="fc" id="L688">    		int start = (int)aceReadBuilder.getBegin();</span>
			
<span class="fc" id="L690">			String id =aceReadBuilder.getId();</span>
<span class="fc" id="L691">			Direction dir = aceReadBuilder.getDirection();</span>
<span class="fc" id="L692">			QualitySequence fullQualities =null;</span>
			
<span class="fc bfc" id="L694" title="All 2 branches covered.">			if(qualityDataStore!=null){</span>
				try {
<span class="fc" id="L696">					fullQualities = qualityDataStore.get(id);</span>
<span class="nc" id="L697">				} catch (DataStoreException e) {</span>
<span class="nc" id="L698">					throw new IllegalStateException(&quot;error recalling consensus&quot;,e);</span>
<span class="fc" id="L699">				}</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">    			if(fullQualities ==null){</span>
<span class="nc" id="L701">    				throw new NullPointerException(&quot;could not get qualities for &quot;+id);</span>
    			}
			}
<span class="fc" id="L704">			NucleotideSequence readSequence = aceReadBuilder.getCurrentNucleotideSequence();</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">			if(fullQualities==null){</span>
<span class="fc" id="L706">				byte[] qualArray = new byte[aceReadBuilder.getUngappedFullLength()];</span>
<span class="fc" id="L707">				Arrays.fill(qualArray, DEFAULT_QUALITY.getQualityScore());</span>
<span class="fc" id="L708">				fullQualities = new QualitySequenceBuilder(qualArray).build();</span>
			}
<span class="fc" id="L710">			QualitySequence gappedValidRangequalities = </span>
<span class="fc" id="L711">					qualityValueStrategy.getGappedValidRangeQualitySequenceFor(readSequence, fullQualities, </span>
<span class="fc" id="L712">							aceReadBuilder.getClearRange(), dir);	</span>
			
<span class="fc" id="L714">			Iterator&lt;Nucleotide&gt; baseIter = readSequence.iterator();</span>
<span class="fc" id="L715">			Iterator&lt;PhredQuality&gt; qualIter = gappedValidRangequalities.iterator();</span>
<span class="fc" id="L716">			int i=0;</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">			while(baseIter.hasNext()){</span>
<span class="fc" id="L718">				Nucleotide base = baseIter.next();</span>
<span class="fc" id="L719">				PhredQuality quality = qualIter.next();</span>
<span class="fc" id="L720">				builders[start+i].add(id, base, quality, dir);</span>
<span class="fc" id="L721">				i++;</span>
<span class="fc" id="L722">			}</span>
			
<span class="fc" id="L724">    	}</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">    	if(mutableConsensus ==null){</span>
<span class="fc" id="L726">    		mutableConsensus = new NucleotideSequenceBuilder(builders.length);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">    		for(int i=0; i&lt;builders.length; i++){</span>
<span class="fc" id="L728">	    		SliceBuilder builder = builders[i];</span>
<span class="fc" id="L729">    			Slice slice = builder.build();            </span>
<span class="fc" id="L730">	    		mutableConsensus.append(consensusCaller.callConsensus(slice).getConsensus());</span>
	    	}
    	}else{
<span class="fc bfc" id="L733" title="All 2 branches covered.">	    	for(int i=0; i&lt;builders.length; i++){</span>
<span class="fc" id="L734">	    		SliceBuilder builder = builders[i];</span>
	    		//skip 0x
<span class="fc bfc" id="L736" title="All 2 branches covered.">	    		if(builder.getCurrentCoverageDepth()&gt;0){</span>
<span class="fc" id="L737">	    			Slice slice = builder.build();            </span>
<span class="fc" id="L738">		    		mutableConsensus.replace(i,consensusCaller.callConsensus(slice).getConsensus());</span>
	    		}
	    	}
    	}
<span class="fc" id="L742">    	return this;</span>
	}
    private SliceBuilder[] initializeSliceBuilders(int length){
<span class="fc" id="L745">    	SliceBuilder builders[] = new SliceBuilder[length];</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">    	for(int i=0; i&lt;length; i++){</span>
<span class="fc" id="L747">    		builders[i] = new SliceBuilder();</span>
    	}
<span class="fc" id="L749">    	return builders;</span>
    }
    private SliceBuilder[] initializeSliceBuilders(NucleotideSequence consensus){
<span class="fc" id="L752">    	SliceBuilder builders[] = new SliceBuilder[(int)consensus.getLength()];</span>
<span class="fc" id="L753">		int i=0;</span>
<span class="fc" id="L754">		Iterator&lt;Nucleotide&gt; iter = consensus.iterator();</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">		while(iter.hasNext()){</span>
<span class="fc" id="L756">			builders[i++] = new SliceBuilder().setConsensus(iter.next());</span>
		}
<span class="fc" id="L758">    	return builders;</span>
    }
    /**
     * Split the contents of the current ContigBuilder into possibly multiple
     * new ContigBuilders.  The returned ContigBuilders will be new
     * instances which only contain the reads and consensus of the initial
     * contig that intersects the input rangesToKeep.  If a {@link ConsensusCaller}
     * and related {@link QualitySequenceDataStore} and {@link GapQualityValueStrategy}
     * were set via {@link #recallConsensus(ConsensusCaller)} or {@link #recallConsensus(ConsensusCaller, QualitySequenceDataStore, GapQualityValueStrategy)}
     * then those values are copied as well.
     * @param rangesToKeep The {@link Range}s of the contig to make into new
     * contigs.  For each range given, a new ContigBuilder instance is created
     * which contains only the reads and portion of the consensus sequence
     * that intersects that range in the original contig.  If a read
     * extends beyond the input range, then that read sequence is trimmed.
     * If a read spans multiple input ranges, then it will exist (but trimmed)
     * in multiple returned contig Builders.  If the given ranges to keep are overlapping, then the returned
     * contigBuilders will also be overlapping.  Each returned contigBuilder will have all
     * have the same contig id this contigBuilder. 
     * &lt;strong&gt;It is up to the client to modify or remove reads and change the returned
     * contig ids so that the final contigs meet the desired 
     * uniqueness constraints &lt;/strong&gt;   
     * @return a new Map, sorted by Range arrival, each entry value in the map is a new contigBuilder
     * which contains only the portion of this contig at that particular entry key range.  The same id
     * is used for all the returned split contigBuilders so be sure to rename them using 
     * {@link #setContigId(String)} to make them unique.
     */
    public SortedMap&lt;Range, AceContigBuilder&gt; split(Collection&lt;Range&gt; rangesToKeep){
<span class="fc" id="L786">    	SortedMap&lt;Range, AceContigBuilder&gt; splitContigs = new TreeMap&lt;Range, AceContigBuilder&gt;(Range.Comparators.ARRIVAL);</span>
    	
<span class="fc" id="L788">    	CoverageMap&lt;AceAssembledReadBuilder&gt; coverageMap = new CoverageMapBuilder&lt;AceAssembledReadBuilder&gt;(aceReadBuilderMap.values()).build();</span>
    	
<span class="fc bfc" id="L790" title="All 2 branches covered.">    	for(Range rangeTokeep :rangesToKeep){</span>
    		 AceContigBuilder splitContig;
<span class="fc bfc" id="L792" title="All 2 branches covered.">    		if(mutableConsensus==null){</span>
<span class="fc" id="L793">    			splitContig = new AceContigBuilder(contigId, consensusCaller);</span>
    		}else{
<span class="fc" id="L795">	            NucleotideSequence contigConsensus =mutableConsensus</span>
<span class="fc" id="L796">	            									.copy()</span>
<span class="fc" id="L797">													.trim(rangeTokeep)</span>
<span class="fc" id="L798">													.build();</span>
<span class="fc" id="L799">	            splitContig = new AceContigBuilder(contigId, contigConsensus);</span>
<span class="fc" id="L800">	            splitContig.consensusCaller = this.consensusCaller;            </span>
    		}
<span class="fc" id="L802">            splitContig.qualityDataStore = this.qualityDataStore;</span>
<span class="fc" id="L803">            splitContig.qualityValueStrategy = this.qualityValueStrategy;</span>
            
            
<span class="fc" id="L806">            Set&lt;String&gt; contigReads = new HashSet&lt;String&gt;();            </span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">            for(CoverageRegion&lt;AceAssembledReadBuilder&gt; region : coverageMap.getRegionsWhichIntersect(rangeTokeep)){</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">                for(AceAssembledReadBuilder read : region){</span>
<span class="fc" id="L809">                    contigReads.add(read.getId());</span>
<span class="fc" id="L810">                }</span>
<span class="fc" id="L811">            }</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">            for(String readId : contigReads){</span>
            	//create a copy so we 
            	//can modify our version without
            	//affecting original
<span class="fc" id="L816">            	AceAssembledReadBuilder readBuilder = aceReadBuilderMap.get(readId)</span>
<span class="fc" id="L817">            											.copy();</span>
<span class="fc" id="L818">            	Range.Builder readTrimRangeBuilder = new Range.Builder(readBuilder.asRange().intersection(rangeTokeep))</span>
<span class="fc" id="L819">            						.shift(-readBuilder.getBegin()); //adjust trim range to be relative of read start</span>
            						
            	
            	//VHTNGS-910 : check that the new trim region
            	//doesn't start or end in gaps.
            	//if so trim more.
<span class="fc" id="L825">            	NucleotideSequence untrimmedReadSequence = readBuilder.getCurrentNucleotideSequence();</span>
<span class="fc" id="L826">            	int firstNonGapTrimOffset =AssemblyUtil.getRightFlankingNonGapIndex(untrimmedReadSequence, (int) readTrimRangeBuilder.getBegin());</span>
<span class="fc" id="L827">            	int lastNonGapTrimOffset =AssemblyUtil.getLeftFlankingNonGapIndex(untrimmedReadSequence, (int) readTrimRangeBuilder.getEnd());</span>
            	
            	
            	
            	//null out copy's parent contigBuilder
            	//to avoid erroneous trim calls
            	//to the wrong contig builder.
            	//(we don't want to alter the original contig)
            	//we discard this read builder anyway when
            	//we add the final trimmed data to our new builder anyway.
<span class="fc" id="L837">            	((DefaultAceAssembledRead.Builder)readBuilder).setParentContigBuilder(null);</span>
            	
            	
            	//trim updated
            	//valid range sequence
            	//and clear range
            	//so we can just use the returned values
            	//when adding this adjusted read to the split
            	//contig.
<span class="fc" id="L846">        		readBuilder.trim(Range.of(firstNonGapTrimOffset, lastNonGapTrimOffset));</span>
            	
            	
<span class="fc" id="L849">            	splitContig.addRead(readId, </span>
<span class="fc" id="L850">            			readBuilder.getCurrentNucleotideSequence(), </span>
<span class="fc" id="L851">            			(int)(readBuilder.getBegin() - rangeTokeep.getBegin()), </span>
<span class="fc" id="L852">            			readBuilder.getDirection(), </span>
<span class="fc" id="L853">            			readBuilder.getClearRange(), </span>
<span class="fc" id="L854">            			readBuilder.getPhdInfo(), </span>
<span class="fc" id="L855">            			readBuilder.getUngappedFullLength());</span>
<span class="fc" id="L856">            }</span>
<span class="fc" id="L857">            splitContigs.put(rangeTokeep, splitContig);</span>
<span class="fc" id="L858">    	}</span>
    	
<span class="fc" id="L860">    	return splitContigs;</span>
    }

	/**
     * Comparator singleton that sorts reads like consed does when outputing ace files.
     * @author dkatzel
     *
     */
<span class="pc" id="L868">    private static enum ConsedReadComparator implements Comparator&lt;AceAssembledRead&gt;{</span>
<span class="fc" id="L869">		INSTANCE;</span>
		
		@Override
		public int compare(AceAssembledRead o1, AceAssembledRead o2) {
<span class="fc" id="L873">			int comp= Range.Comparators.ARRIVAL.compare(o1.asRange(),o2.asRange());</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">			if(comp!=0){</span>
<span class="fc" id="L875">				return comp;</span>
			}
			//ranges the same order by id
<span class="fc" id="L878">			return o1.getId().compareTo(o2.getId());</span>
		}

	}
    
    private static final class  DefaultAceContigImpl implements AceContig{

    	
        private final boolean complemented;
        private final QualitySequence consensusQualities;
        
        private final Contig&lt;AceAssembledRead&gt; contig;
        private DefaultAceContigImpl(String id, NucleotideSequence consensus,
                Set&lt;AceAssembledRead&gt; reads,boolean complemented,
<span class="fc" id="L892">                QualitySequence consensusQualities) {</span>
<span class="fc" id="L893">            contig = new DefaultContig&lt;AceAssembledRead&gt;(id, consensus, reads);</span>
<span class="fc" id="L894">            this.complemented = complemented;</span>
<span class="fc" id="L895">            this.consensusQualities = consensusQualities;</span>
<span class="fc" id="L896">        }</span>
       
        
        
        @Override
		public ThrowingStream&lt;AceAssembledRead&gt; reads() {
<span class="nc" id="L902">			return contig.reads();</span>
		}



		@Override
		public QualitySequence getConsensusQualitySequence() {
<span class="fc" id="L909">			return consensusQualities;</span>
		}



		/**
        * {@inheritDoc}
        */
        @Override
        public boolean isComplemented() {
<span class="fc" id="L919">            return complemented;</span>
        }



		@Override
		public String getId() {
<span class="fc" id="L926">			return contig.getId();</span>
		}



		@Override
		public long getNumberOfReads() {
<span class="fc" id="L933">			return contig.getNumberOfReads();</span>
		}



		@Override
		public NucleotideSequence getConsensusSequence() {
<span class="fc" id="L940">			return contig.getConsensusSequence();</span>
		}



		@Override
		public AceAssembledRead getRead(String id) {
<span class="fc" id="L947">			return contig.getRead(id);</span>
		}



		@Override
		public boolean containsRead(String readId) {
<span class="fc" id="L954">			return contig.containsRead(readId);</span>
		}



		@Override
		public StreamingIterator&lt;AceAssembledRead&gt; getReadIterator() {
<span class="fc" id="L961">			return contig.getReadIterator();</span>
		}



		@Override
		public int hashCode() {
<span class="nc" id="L968">			final int prime = 31;</span>
<span class="nc" id="L969">			int result = 1;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">			result = prime * result + (complemented ? 1231 : 1237);</span>
<span class="nc" id="L971">			result = prime * result + contig.hashCode();</span>
<span class="nc" id="L972">			return result;</span>
		}



		@Override
		public boolean equals(Object obj) {
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L980">				return true;</span>
			}
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L983">				return false;</span>
			}
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">			if (!(obj instanceof AceContig)) {</span>
<span class="nc" id="L986">				return false;</span>
			}
<span class="fc" id="L988">			AceContig other = (AceContig) obj;</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">			if (complemented != other.isComplemented()) {</span>
<span class="nc" id="L990">				return false;</span>
			}
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">			if (!contig.getId().equals(other.getId())) {</span>
<span class="nc" id="L993">				return false;</span>
			}
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">			if (!contig.getConsensusSequence().equals(other.getConsensusSequence())) {</span>
<span class="nc" id="L996">				return false;</span>
			}
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">			if (contig.getNumberOfReads()!=other.getNumberOfReads()) {</span>
<span class="nc" id="L999">				return false;</span>
			}

<span class="pc" id="L1002">			try(StreamingIterator&lt;AceAssembledRead&gt; readIter = contig.getReadIterator()){</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">				while(readIter.hasNext()){</span>
<span class="fc" id="L1004">					AceAssembledRead read = readIter.next();</span>
<span class="fc" id="L1005">					String readId = read.getId();</span>
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">					if(!other.containsRead(readId)){</span>
<span class="nc" id="L1007">						return false;</span>
					}
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">					if(!read.equals(other.getRead(readId))){</span>
<span class="nc" id="L1010">						return false;</span>
					}
<span class="fc" id="L1012">				}</span>
<span class="pc bpc" id="L1013" title="14 of 16 branches missed.">			}			</span>
<span class="fc" id="L1014">			return true;</span>
		}
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>