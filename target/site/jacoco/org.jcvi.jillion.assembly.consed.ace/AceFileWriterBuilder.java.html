<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AceFileWriterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.ace</a> &gt; <span class="el_source">AceFileWriterBuilder.java</span></div><h1>AceFileWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.ace;

import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.jcvi.jillion.assembly.consed.phd.PhdDataStore;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
/**
 * {@code AceFileWriterBuilder} 
 * is a builder
 * for creating new
 * {@link AceFileWriter} instances
 * that handles
 * writing out correctly formatted
 * ace files that can be viewed
 * with consed.
 * Since some portions of an ace file,
 * such as the header line contain information
 * that can not be known until the entire file
 * is written, this implementation will first
 * write out data to a temporary file.
 * The location of the temporary file
 * can be configured via {@link #tmpDir(File)}.
 * @author dkatzel
 *
 */
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(
		value = {&quot;VA_FORMAT_STRING_USES_NEWLINE&quot;},
		justification = &quot;\n character is required for .ace format (?) &quot;
						+ &quot;we don't want to accidentally put in a \r\n on diffent OS&quot;
						+ &quot;and break consed&quot;)
public final class AceFileWriterBuilder{
	
<span class="fc" id="L65">		private boolean createBsRecords=false;</span>
		private final PhdDataStore phdDataStore;
		private final OutputStream out;
		private File tmpDir;
		
	
		/**
		 * Create a new Builder instance
		 * which will build a new instance of 
		 * {@link AceFileWriterBuilder} with the given required
		 * parameters.
		 * @param outputAceFile a {@link File} representating
		 * the path to the output of the ace file to write.
		 * 
		 * @param datastore the {@link PhdDataStore}
		 * needed to write out the ace data.
		 * The {@link PhdDataStore} needs to be consulted
		 * to get the quality values of the reads
		 * to compute consensus quality values,
		 * get the full length nucleotide sequences of the reads
		 * in the contigs and 
		 * to format the full length nucleotide sequences
		 * by encoding high vs low quality values by using
		 * upper vs lowercase letters respectively.
		 * @throws IOException  if there is a problem creating
		 * output file.
		 */
<span class="fc" id="L92">		public AceFileWriterBuilder(File outputAceFile,PhdDataStore datastore) throws IOException{</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">			if(outputAceFile ==null){</span>
<span class="nc" id="L94">				throw new NullPointerException(&quot;output ace file can not be null&quot;);	</span>
			}
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">			if(datastore==null){</span>
<span class="nc" id="L97">				throw new NullPointerException(&quot;datastore can not be null&quot;);				</span>
			}
<span class="fc" id="L99">			IOUtil.mkdirs(outputAceFile.getParentFile());</span>
<span class="fc" id="L100">			this.phdDataStore = datastore;</span>
<span class="fc" id="L101">			this.out=new FileOutputStream(outputAceFile);</span>
<span class="fc" id="L102">		}</span>
		
		/**
		 * Change the temporary directory used
		 * to keep temp files during the writing process.
		 * If this option is not specified,
		 * then the system's default temp dir area is used.
		 * @param tmpDir the path to the tmpDirectory.
		 * @return this
		 * @throws IOException if there is a problem creating the temp directory
		 * if it does not exist.
		 * @throws NullPointerException if tmpDir is null.
		 * @throws IllegalArgumentException if tmpDir exists but is not
		 * a directory.
		 */
		public AceFileWriterBuilder tmpDir(File tmpDir) throws IOException{
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">			if(tmpDir==null){</span>
<span class="nc" id="L119">				throw new NullPointerException(&quot;tmp dir path can not be null&quot;);</span>
			}
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">			if(tmpDir.exists() &amp;&amp; !tmpDir.isDirectory()){</span>
<span class="nc" id="L122">				throw new IllegalArgumentException(&quot;tmp dir must be a directory&quot;);</span>
			}
<span class="fc" id="L124">			IOUtil.mkdirs(tmpDir);</span>
<span class="fc" id="L125">			this.tmpDir = tmpDir;</span>
<span class="fc" id="L126">			return this;</span>
		}
		
		/**
		 * Legacy versions of consed
		 * required ace contigs to include information
		 * that indicated which read phrap had chosen to be 
		 * the consensus at a particular offset.  This information
		 * is no longer required by current versions of consed since
		 * it is phrap specific.  Including
		 * Base Segments is not recommended since generating
		 * them is computationally expensive and can throw
		 * RuntimeExceptions if there is no read that matches the consensus
		 * at a particular offset (for example a 0x region or if the consensus
		 * is an ambiguity).
		 * @return this.
		 */
		public AceFileWriterBuilder includeBaseSegments(){
<span class="fc" id="L144">			createBsRecords=true;</span>
<span class="fc" id="L145">			return this;</span>
		}
		/**
		 * Create a new instance of {@link AceFileWriterBuilder}
		 * with the given paramters.
		 * @return a new instance; never null.
		 * @throws IOException if there is a problem
		 * creating the temp directory (it doesn't
		 * already exist) or the temp file.
		 * 
		 */
		public AceFileWriter build() throws IOException {
<span class="fc" id="L157">			return new DefaultAceFileWriter(out, phdDataStore, </span>
					tmpDir,
					createBsRecords);
		}

/**
 * Private implementation of {@link AceFileWriter}.
 * @author dkatzel
 *
 */
private static final class DefaultAceFileWriter extends AbstractAceFileWriter{
	
	private final PhdDataStore phdDatastore;
	private final OutputStream out;
	private final File tempFile;
<span class="fc" id="L172">	private long numberOfContigs=0;</span>
<span class="fc" id="L173">	private long numberOfReads=0;</span>
	private final Writer tempWriter;
	
<span class="fc" id="L176">	ByteArrayOutputStream tagOutputStream = new ByteArrayOutputStream(DEFAULT_BUFFER_SIZE);</span>
	
<span class="fc" id="L178">	private volatile boolean isOpen = true;</span>
	
	private DefaultAceFileWriter(OutputStream out, PhdDataStore phdDatastore,File tmpDir,
			boolean createBsRecords) throws IOException {
<span class="fc" id="L182">		super(createBsRecords);</span>
<span class="fc" id="L183">		this.out = new BufferedOutputStream(out,DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L184">		this.phdDatastore = phdDatastore;</span>
<span class="fc" id="L185">		IOUtil.mkdirs(tmpDir);</span>
<span class="fc" id="L186">		this.tempFile = File.createTempFile(&quot;aceWriter&quot;, null, tmpDir);</span>
<span class="fc" id="L187">		tempFile.deleteOnExit();</span>
<span class="fc" id="L188">		tempWriter = new BufferedWriter(</span>
				new OutputStreamWriter(new FileOutputStream(tempFile), IOUtil.UTF_8),
				DEFAULT_BUFFER_SIZE);
<span class="fc" id="L191">	}</span>

	@Override
	public void close() throws IOException {
		//2014-09-04:
		//only close once!
		//any additional calls to close
		//should be no-op
<span class="fc bfc" id="L199" title="All 2 branches covered.">		if(isOpen){</span>
<span class="fc" id="L200">			isOpen=false;</span>
<span class="fc" id="L201">			tempWriter.close();</span>
<span class="fc" id="L202">			writeAceFileHeader();</span>
<span class="fc" id="L203">			copyTempFileData();</span>
<span class="fc" id="L204">			copyTagData();</span>
<span class="fc" id="L205">			out.close();</span>
<span class="fc" id="L206">			IOUtil.deleteIgnoreError(tempFile);</span>
		}
		
<span class="fc" id="L209">	}</span>

	private void copyTagData() throws IOException {
<span class="fc bfc" id="L212" title="All 2 branches covered.">		if(tagOutputStream.size()&gt;0){</span>
<span class="fc" id="L213">			out.write(tagOutputStream.toByteArray());</span>
		}
<span class="fc" id="L215">	}</span>

	private void copyTempFileData() throws FileNotFoundException, IOException {
<span class="fc" id="L218">		InputStream in = new FileInputStream(tempFile);</span>
		try{
<span class="fc" id="L220">			IOUtil.copy(in, out);</span>
		}finally{
<span class="pc" id="L222">			IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L223">		}</span>
<span class="fc" id="L224">	}</span>
	
	 private void writeAceFileHeader() throws IOException{
<span class="fc" id="L227">	     out.write(String.format(&quot;AS %d %d%s%s&quot;, numberOfContigs, numberOfReads,CR,CR).getBytes(IOUtil.UTF_8));</span>
<span class="fc" id="L228">	 }</span>
	 
	@Override
	public void write(AceContig contig) throws IOException {
<span class="fc" id="L232">		numberOfContigs++;</span>
<span class="fc" id="L233">		numberOfReads+=contig.getNumberOfReads();</span>
<span class="fc" id="L234">		write(tempWriter, contig, phdDatastore);</span>
		
<span class="fc" id="L236">	}</span>
	
	
	@Override
	public void write(ReadAceTag readTag) throws IOException {
<span class="fc" id="L241">		Range range = readTag.asRange();</span>
<span class="fc" id="L242">    	String formattedTag =String.format(&quot;RT{\n%s %s %s %d %d %s\n}\n&quot;, </span>
<span class="fc" id="L243">                        readTag.getId(),</span>
<span class="fc" id="L244">                        readTag.getType(),</span>
<span class="fc" id="L245">                        readTag.getCreator(),</span>
<span class="fc" id="L246">                        range.getBegin(),</span>
<span class="fc" id="L247">                        range.getEnd(),</span>
<span class="fc" id="L248">                        AceFileUtil.formatTagDate(readTag.getCreationDate()));</span>
    	
<span class="fc" id="L250">    	tagOutputStream.write(formattedTag.getBytes(IOUtil.UTF_8));</span>
<span class="fc" id="L251">	}</span>

	@Override
	public void write(ConsensusAceTag consensusTag) throws IOException {
<span class="fc" id="L255">		 StringBuilder tagBodyBuilder = new StringBuilder();</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">	        if(consensusTag.getData() !=null){</span>
<span class="fc" id="L257">	            tagBodyBuilder.append(consensusTag.getData());</span>
	        }
<span class="fc bfc" id="L259" title="All 2 branches covered.">	        if(!consensusTag.getComments().isEmpty()){</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">	            for(String comment :consensusTag.getComments()){</span>
<span class="fc" id="L261">	                tagBodyBuilder.append(String.format(&quot;COMMENT{\n%sC}\n&quot;,comment));            </span>
<span class="fc" id="L262">	            }</span>
	        }
<span class="fc" id="L264">	        Range range = consensusTag.asRange();</span>
<span class="fc" id="L265">	        String formattedTag=String.format(&quot;CT{\n%s %s %s %d %d %s%s\n%s}\n&quot;, </span>
<span class="fc" id="L266">	                consensusTag.getId(),</span>
<span class="fc" id="L267">	                consensusTag.getType(),</span>
<span class="fc" id="L268">	                consensusTag.getCreator(),</span>
<span class="fc" id="L269">	                range.getBegin(),</span>
<span class="fc" id="L270">	                range.getEnd(),</span>
<span class="fc" id="L271">	                AceFileUtil.formatTagDate(consensusTag.getCreationDate()),</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">	                consensusTag.isTransient()?&quot; NoTrans&quot;:&quot;&quot;,</span>
<span class="fc" id="L273">	                        tagBodyBuilder.toString());</span>
	        
<span class="fc" id="L275">	        tagOutputStream.write(formattedTag.getBytes(IOUtil.UTF_8));</span>
		
<span class="fc" id="L277">	}</span>

	@Override
	public void write(WholeAssemblyAceTag wholeAssemblyTag) throws IOException {
<span class="fc" id="L281">		String formattedTag =String.format(&quot;WA{\n%s %s %s\n%s\n}\n&quot;, </span>
<span class="fc" id="L282">                wholeAssemblyTag.getType(),</span>
<span class="fc" id="L283">                wholeAssemblyTag.getCreator(),                </span>
<span class="fc" id="L284">                AceFileUtil.formatTagDate(wholeAssemblyTag.getCreationDate()),</span>
<span class="fc" id="L285">                wholeAssemblyTag.getData());</span>
		
<span class="fc" id="L287">		tagOutputStream.write(formattedTag.getBytes(IOUtil.UTF_8));</span>
		
<span class="fc" id="L289">	}</span>
}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>