<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BaseSegmentUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.ace</a> &gt; <span class="el_source">BaseSegmentUtil.java</span></div><h1>BaseSegmentUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.ace;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.ReferenceMappedNucleotideSequence;
import org.jcvi.jillion.core.util.MapValueComparator;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.PeekableIterator;
import org.jcvi.jillion.core.util.iter.PeekableStreamingIterator;
/**
 * Utility class for working with
 * Consed's legacy &quot;BestSegment&quot;.
 * @author dkatzel
 *
 */
final class BaseSegmentUtil {
	
<span class="nc" id="L48">	private BaseSegmentUtil(){</span>
		//can not instantiate
<span class="nc" id="L50">	}</span>
	/**
	 * Compute the BestSegments
	 * for the given contig
	 * @param contig the contig to look at; can not be null.
	 * 
	 * @return a List of BestSegments;
	 * 
	 * @throws NoReadMatchesConsensusException if there no aligned
	 * read has an exact basecall match to the consensus.  This
	 * can often happen when the consensus has ambiguity values
	 * and the underlying sequences are the bases
	 * that make up the ambiguity.
	 * 
	 * @throws NullPointerException if contig is null.
	 */
	public static List&lt;AceBaseSegment&gt; computeBestSegmentsFor(AceContig contig){
<span class="fc" id="L67">		List&lt;AceBaseSegment&gt; baseSegments = new ArrayList&lt;AceBaseSegment&gt;();</span>
<span class="fc" id="L68">		NucleotideSequence consensus =contig.getConsensusSequence();</span>
<span class="fc" id="L69">		PeekableIterator&lt;Nucleotide&gt; consensusIterator = IteratorUtil.createPeekableIterator(consensus.iterator());</span>
<span class="fc" id="L70">		PeekableStreamingIterator&lt;AceAssembledRead&gt; readIter = IteratorUtil.createPeekableStreamingIterator(contig.getReadIterator());</span>
		
<span class="fc" id="L72">		SortedMap&lt;String,Range&gt; sortedReadRanges = createSortedRangeMapFor(readIter,0);			</span>
<span class="fc" id="L73">		Nucleotide consensusBase = consensusIterator.peek();</span>
<span class="fc" id="L74">		CurrentMatchingRead currentMatchingRead = findFirstReadThatMatchesConsensus(contig, sortedReadRanges,consensusBase);</span>

<span class="fc" id="L76">		long consensusOffsetToBeCovered = computeNextBaseSegment(baseSegments,</span>
													0, 
													consensusIterator,
													currentMatchingRead);
<span class="fc bfc" id="L80" title="All 2 branches covered.">		while(consensusIterator.hasNext()){</span>
<span class="fc" id="L81">			consensusBase = consensusIterator.peek();</span>
<span class="fc" id="L82">			sortedReadRanges = createSortedRangeMapFor(readIter,consensusOffsetToBeCovered,sortedReadRanges);</span>
<span class="fc" id="L83">			currentMatchingRead = findReadThatMatchesConsensus(contig, sortedReadRanges,consensusBase,consensusOffsetToBeCovered);</span>
			
<span class="fc" id="L85">			consensusOffsetToBeCovered = computeNextBaseSegment(baseSegments,</span>
													consensusOffsetToBeCovered, 
													consensusIterator,
													currentMatchingRead);
		}
<span class="fc" id="L90">		return baseSegments;</span>
	}
	private static long computeNextBaseSegment(
			List&lt;AceBaseSegment&gt; bestSegments, long offset,
			PeekableIterator&lt;Nucleotide&gt; consensusIterator,
			CurrentMatchingRead currentMatchingRead) {
		Nucleotide consensusBase;
<span class="fc" id="L97">		boolean stillMatches=true;</span>
<span class="fc" id="L98">		long consensusOffsetToBeCovered = offset;</span>
<span class="fc bfc" id="L99" title="All 6 branches covered.">		while(consensusIterator.hasNext() &amp;&amp; currentMatchingRead.getBaseIterator().hasNext() &amp;&amp; stillMatches){</span>
			
<span class="fc" id="L101">			consensusBase = consensusIterator.peek();</span>
<span class="fc" id="L102">			Nucleotide readBase = currentMatchingRead.getBaseIterator().next();</span>
<span class="fc" id="L103">			stillMatches = consensusBase.equals(readBase);	</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">			if(stillMatches){</span>
<span class="fc" id="L105">				consensusOffsetToBeCovered++;</span>
<span class="fc" id="L106">				consensusIterator.next();</span>
			}
<span class="fc" id="L108">		}</span>
		//here we have a current matching read that no longer matches
<span class="fc" id="L110">		bestSegments.add(new DefaultAceBaseSegment(currentMatchingRead.getRead().getId(), </span>
<span class="fc" id="L111">				Range.of(currentMatchingRead.getStartMatchOffset(), consensusOffsetToBeCovered-1)));</span>
<span class="fc" id="L112">		return consensusOffsetToBeCovered;</span>
	}

	private static SortedMap&lt;String, Range&gt; createSortedRangeMapFor(
			PeekableStreamingIterator&lt;AceAssembledRead&gt; readIter, long offset,
			SortedMap&lt;String, Range&gt; sortedReadRanges) {
		//remove any reads that no longer provide coverage
		//this map should be sorted by end offset
		//so if we see a read that still covers
		//then the rest of the reads do too.
		//this is an optimization over having to compute
		//and then iterate over a coverage map and slice map for each slice
<span class="fc" id="L124">		Iterator&lt;Entry&lt;String, Range&gt;&gt; iter = sortedReadRanges.entrySet().iterator();</span>
		//our new map
<span class="fc" id="L126">		Map&lt;String, Range&gt; map = new LinkedHashMap&lt;String, Range&gt;();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">		while(iter.hasNext()){</span>
<span class="fc" id="L128">			Entry&lt;String, Range&gt; entry =iter.next();</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">			if(entry.getValue().getEnd()&lt;offset){</span>
<span class="fc" id="L130">				iter.remove();</span>
			}else{
<span class="fc" id="L132">				map.put(entry.getKey(),entry.getValue());</span>
			}
<span class="fc" id="L134">		}</span>
<span class="fc" id="L135">		boolean done=false;</span>
		
<span class="fc bfc" id="L137" title="All 4 branches covered.">		while(readIter.hasNext() &amp;&amp; !done){</span>
			//we peek incase we get to a read that starts beyond
			//our current consensus offset
<span class="fc" id="L140">			AceAssembledRead currentRead = readIter.peek();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">			if(currentRead.getGappedStartOffset()&lt;=offset){</span>
<span class="fc" id="L142">				readIter.next();</span>
<span class="fc" id="L143">				map.put(currentRead.getId(), currentRead.asRange());</span>
			}else{
<span class="fc" id="L145">				done=true;</span>
			}
<span class="fc" id="L147">		}</span>
		
<span class="fc" id="L149">		return MapValueComparator.sortAscending(map, Range.Comparators.DEPARTURE);</span>
	}

	private static CurrentMatchingRead findFirstReadThatMatchesConsensus(AceContig contig,
			SortedMap&lt;String, Range&gt; sortedReadRanges,
			Nucleotide consensusBase) {
<span class="fc" id="L155">		return findReadThatMatchesConsensus(contig, sortedReadRanges, consensusBase, 0);</span>
	}
	private static CurrentMatchingRead findReadThatMatchesConsensus(AceContig contig,
			SortedMap&lt;String, Range&gt; sortedReadRanges,
			Nucleotide consensusBase, long consensusOffset) {
<span class="fc" id="L160">		Iterator&lt;String&gt; idIterator = sortedReadRanges.keySet().iterator();</span>
<span class="fc" id="L161">		boolean foundMatch=false;</span>
<span class="fc" id="L162">		AceAssembledRead currentBestRead=null;</span>
<span class="fc bfc" id="L163" title="All 4 branches covered.">		while(!foundMatch &amp;&amp; idIterator.hasNext()){</span>
<span class="fc" id="L164">			String id = idIterator.next();</span>
<span class="fc" id="L165">			AceAssembledRead read = contig.getRead(id);</span>
<span class="fc" id="L166">			ReferenceMappedNucleotideSequence readSequence =read.getNucleotideSequence();</span>
<span class="fc" id="L167">			long gappedStartOffset = read.getGappedStartOffset();</span>
<span class="fc" id="L168">			long readOffset = consensusOffset-gappedStartOffset;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">			if(readSequence.getLength()&gt;readOffset){</span>
<span class="fc" id="L170">				Nucleotide base =readSequence.get(readOffset);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">				if(base.equals(consensusBase)){</span>
<span class="fc" id="L172">					foundMatch=true;</span>
<span class="fc" id="L173">					currentBestRead = read;</span>
				}
			}
<span class="fc" id="L176">		}</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">		if(currentBestRead==null){</span>
<span class="fc" id="L178">			throw new NoReadMatchesConsensusException(consensusBase,consensusOffset);</span>
		}
<span class="fc" id="L180">		Range readRange = Range.of(consensusOffset- currentBestRead.getGappedStartOffset(), currentBestRead.getGappedEndOffset()- currentBestRead.getGappedStartOffset());</span>
<span class="fc" id="L181">		return new CurrentMatchingRead(currentBestRead, </span>
<span class="fc" id="L182">				currentBestRead.getNucleotideSequence().iterator(readRange),</span>
				consensusOffset);
	}
	private static SortedMap&lt;String, Range&gt; createSortedRangeMapFor(
			PeekableStreamingIterator&lt;AceAssembledRead&gt; readIter, long offset) {
<span class="fc" id="L187">		return createSortedRangeMapFor(readIter, offset, new TreeMap&lt;String, Range&gt;());</span>
	}
	
	public static class NoReadMatchesConsensusException extends IllegalStateException{
		/**
		 * 
		 */
		private static final long serialVersionUID = 2738190645917425718L;

		NoReadMatchesConsensusException(Nucleotide consensusBase, long offset){
<span class="fc" id="L197">			super(String.format(&quot;consensus ='%s' at offset %d&quot;,consensusBase, offset));</span>
<span class="fc" id="L198">		}</span>
	}
	
	private static class CurrentMatchingRead{
		private final AceAssembledRead read;
		private final Iterator&lt;Nucleotide&gt; baseIterator;
		private final long startMatchOffset;
		
		public CurrentMatchingRead(AceAssembledRead read,
				Iterator&lt;Nucleotide&gt; baseIterator,
<span class="fc" id="L208">				long startMatchOffset) {</span>
<span class="fc" id="L209">			this.read = read;</span>
<span class="fc" id="L210">			this.baseIterator = baseIterator;</span>
<span class="fc" id="L211">			this.startMatchOffset = startMatchOffset;</span>
<span class="fc" id="L212">		}</span>
		protected final AceAssembledRead getRead() {
<span class="fc" id="L214">			return read;</span>
		}
		protected final Iterator&lt;Nucleotide&gt; getBaseIterator() {
<span class="fc" id="L217">			return baseIterator;</span>
		}
		protected final long getStartMatchOffset() {
<span class="fc" id="L220">			return startMatchOffset;</span>
		}
		
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>