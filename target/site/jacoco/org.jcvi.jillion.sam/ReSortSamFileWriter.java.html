<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReSortSamFileWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">ReSortSamFileWriter.java</span></div><h1>ReSortSamFileWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.PeekableStreamingIterator;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.internal.core.util.iter.AbstractBlockingStreamingIterator;
import org.jcvi.jillion.internal.sam.index.BamIndexer;
import org.jcvi.jillion.sam.attribute.SamAttributeValidator;
import org.jcvi.jillion.sam.header.SamHeader;
/**
 * {@code ReSortSamFileWriter}
 * is a {@link SamWriter} implementation
 * that can take {@link SamRecord}s given to it via
 * the {@link SamWriter#writeRecord(SamRecord)}
 * in ANY ORDER and write out the SAM or BAM file
 * sorted by the specified manner.
 * Subclasses handle the actual SAM/BAM encoding.
 * &lt;p&gt;
 * Algorithm: Keep an array of records in memory
 * (size of array specified by user).  When we
 * have filled the array, sort the in memory records
 * and write out a SAM/BAM file to a temp file and
 * clear the in memory array to make room for more
 * records.
 * When {@link SamWriter#close()} is called,
 * write the combined sorted
 * records to the specified output file.
 * Since 
 * we know each temp file and the in memory array are 
 * each sorted, we can use a merge sort like algorithm
 * to combine the records into one giant sorted list. 
 * &lt;/p&gt;
 * @author dkatzel
 *
 */
class ReSortSamFileWriter implements SamWriter {

	private final SamHeader header;
	private final Comparator&lt;SamRecord&gt; recordComparator;
	private final File tmpDir;
	private final File outputFile;
	
	private SamRecord[] inMemoryArray;
	private int currentInMemSize;
	private final int maxRecordsToKeepInMemory;
<span class="fc" id="L77">	private final List&lt;File&gt; tempFiles = new ArrayList&lt;File&gt;();</span>
	private final SamAttributeValidator attributeValidator;
	
	private final Encoding encoding;
	private final BamIndexer indexer;
	private final boolean includeIndexMetaData;
	
	
	/**
	 * 
	 * @param outputFile The output File to write.
	 * @param tmpDirRoot the root directory to create child temp directories to write temp data to.
	 * @param header the {@link SamHeader} to use in the output file.
	 * @param maxRecordsToKeepInMemory the max number of SamRecords to keep in memory at a time.  When 
	 * more than this amount of records have been written to memory, they will be flushed to a temp file under the tmpDirRoot.
	 * Value must be &amp;ge; 0.
	 * 
	 * @param attributeValidator the {@link SamAttributeValidator} to use to validate the records to be written;
	 * can not be null.
	 * 
	 * @param encodingToUse The {@link Encoding} to use to write the output file; can not be null.
	 * @param indexer the {@link BamIndexer} to use to index the files
	 * @param includeIndexMetaData  should the index also include metadata.
	 * 
	 * @throws NullPointerException if any of the parameters that can't be null are null.
	 * @throws IllegalArgumentException if maxRecordsToKeepInMemory is negative.
	 * 
	 * @throws IOException if there is a problem creating the output file or creating a temp directory under tmpDirRoot.
	 */
	ReSortSamFileWriter(File outputFile, File tmpDirRoot, SamHeader header, 
	        int maxRecordsToKeepInMemory, SamAttributeValidator attributeValidator,
<span class="fc" id="L108">	        Encoding encodingToUse, BamIndexer indexer, boolean includeIndexMetaData) throws IOException {</span>
		
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">		if(maxRecordsToKeepInMemory &lt;0){</span>
<span class="nc" id="L111">			throw new IllegalArgumentException(&quot;max records to keep in memory must be &gt;=1&quot;);</span>
		}
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">		if(attributeValidator ==null){</span>
<span class="nc" id="L114">			throw new NullPointerException(&quot;attribute valiator can not be null&quot;);</span>
		}
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">		if(encodingToUse ==null){</span>
<span class="nc" id="L117">			throw new NullPointerException(&quot;Encoding can not be null&quot;);</span>
		}
<span class="fc" id="L119">		this.maxRecordsToKeepInMemory = maxRecordsToKeepInMemory;</span>
		
<span class="fc" id="L121">		this.header = header;</span>
<span class="fc" id="L122">		recordComparator = createRecordComparatorFor(header);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">		if(recordComparator ==null){</span>
<span class="nc" id="L124">			throw new NullPointerException(&quot;SortOrder must create a non-null comparator &quot; + header.getSortOrder());</span>
		}
		
<span class="fc" id="L127">		IOUtil.mkdirs(outputFile.getParentFile());</span>
<span class="fc" id="L128">		tmpDir = IOUtil.createTempDir(&quot;jillion&quot;, &quot;samWriterTmp&quot;, tmpDirRoot);		</span>
<span class="fc" id="L129">        inMemoryArray = new SamRecord[maxRecordsToKeepInMemory];</span>
<span class="fc" id="L130">        currentInMemSize=0;</span>
<span class="fc" id="L131">        this.outputFile = outputFile;</span>
<span class="fc" id="L132">        this.attributeValidator = attributeValidator;</span>
<span class="fc" id="L133">        this.encoding = encodingToUse;</span>
<span class="fc" id="L134">        this.indexer = indexer;</span>
        
<span class="fc" id="L136">        this.includeIndexMetaData = includeIndexMetaData;</span>
<span class="fc" id="L137">	}</span>


	 private static Comparator&lt;SamRecord&gt; createRecordComparatorFor(SamHeader header){
<span class="fc" id="L141">	     SortOrder sortOrder = header.getSortOrder();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">             if(sortOrder ==null){</span>
<span class="nc" id="L143">                     return null;</span>
             }
<span class="fc" id="L145">             return sortOrder.createComparator(header);</span>
     }
	
	@Override
	public void writeRecord(SamRecord record) throws IOException {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">		if(record==null){</span>
<span class="nc" id="L151">			throw new NullPointerException(&quot;record can not be null&quot;);</span>
		}
<span class="fc" id="L153">		persistInMemoryCacheIfNeeded();</span>
		try{
<span class="fc" id="L155">			header.validateRecord(record, attributeValidator);</span>
<span class="nc" id="L156">		}catch(SamValidationException e){</span>
<span class="nc" id="L157">			throw new IOException(&quot;can not write record due to validation error(s)&quot;,e);</span>
<span class="fc" id="L158">		}</span>
		
<span class="fc" id="L160">		inMemoryArray[currentInMemSize++] = record;</span>
<span class="fc" id="L161">	}</span>

	/**
	 * Write all the records currently in memory
	 * to a temp file encoded using the given encoding
	 * @throws IOException
	 */
	private void persistInMemoryCacheIfNeeded() throws IOException {
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">		if(currentInMemSize == maxRecordsToKeepInMemory){</span>
			
<span class="nc" id="L171">			sortInMemoryRecords();</span>
			
<span class="nc" id="L173">			File tempFile= File.createTempFile(outputFile.getName(), encoding.getSuffix(), tmpDir);</span>
<span class="nc" id="L174">			tempFiles.add(tempFile);</span>
			//never pass indexer to temp files
			//only use in final if at all.
<span class="nc" id="L177">			SamWriter writer = encoding.createPreSortedNoValidationOutputWriter(tempFile, header,null, false);</span>
			try{
<span class="nc bnc" id="L179" title="All 2 branches missed.">				for(int i=0; i&lt;currentInMemSize; i++){</span>
<span class="nc" id="L180">					writer.writeRecord(inMemoryArray[i]);</span>
				}
			}finally{
<span class="nc" id="L183">				IOUtil.closeAndIgnoreErrors(writer);</span>
<span class="nc" id="L184">				clearInMemoryArray();</span>
<span class="nc" id="L185">			}</span>
			
		}
		
<span class="fc" id="L189">	}</span>


	private void clearInMemoryArray() {
<span class="fc" id="L193">		currentInMemSize=0;</span>
		//clear references to free up GC
<span class="fc" id="L195">		Arrays.fill(inMemoryArray, null);</span>
<span class="fc" id="L196">	}</span>


	private void sortInMemoryRecords() {
		//sort records while they are still in memory
		//our comparators in SortOrder
		//handle nulls and sort them last
		//so we don't have to worry about those
		//throwing NPE.
<span class="fc" id="L205">		Arrays.sort(inMemoryArray, recordComparator);</span>
<span class="fc" id="L206">	}</span>


	
	
	@Override
	public void close() throws IOException {
<span class="fc" id="L213">		List&lt;PeekableStreamingIterator&lt;SamRecord&gt;&gt; iterators =new ArrayList&lt;PeekableStreamingIterator&lt;SamRecord&gt;&gt;(1 + tempFiles.size());</span>
<span class="fc" id="L214">		SamWriter writer =null;</span>
		try{
<span class="fc" id="L216">			sortInMemoryRecords();</span>

<span class="fc" id="L218">			iterators.add(IteratorUtil.createPeekableStreamingIterator(new InMemoryStreamingIterator(currentInMemSize)));</span>
			
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">			for(File tempFile : tempFiles){</span>
<span class="nc" id="L221">				iterators.add(IteratorUtil.createPeekableStreamingIterator(new StreamingSamRecordIterator(tempFile, encoding)));</span>
<span class="nc" id="L222">			}</span>
			
<span class="fc" id="L224">			Iterator&lt;SamRecord&gt; sortedIterator = new MergedSortedRecordIterator(iterators, recordComparator);</span>
<span class="fc" id="L225">			writer = encoding.createPreSortedNoValidationOutputWriter(outputFile, header, indexer, includeIndexMetaData);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">			while(sortedIterator.hasNext()){</span>
<span class="fc" id="L227">				writer.writeRecord(sortedIterator.next());</span>
			}
		}finally{
<span class="pc bpc" id="L230" title="2 of 4 branches missed.">			for(StreamingIterator&lt;?&gt; iter : iterators){</span>
<span class="pc" id="L231">				IOUtil.closeAndIgnoreErrors(iter);</span>
<span class="pc" id="L232">			}</span>
<span class="pc" id="L233">			IOUtil.closeAndIgnoreErrors(writer);</span>
<span class="pc" id="L234">			clearInMemoryArray();</span>
			//delete temp dir
<span class="pc" id="L236">			IOUtil.recursiveDelete(tmpDir);</span>
<span class="fc" id="L237">		}</span>
		
<span class="fc" id="L239">	}</span>


	

	

	private final class InMemoryStreamingIterator implements StreamingIterator&lt;SamRecord&gt;{

		private final int length;
<span class="fc" id="L249">		private int counter=0;</span>
		
<span class="fc" id="L251">		InMemoryStreamingIterator(int numOfInMemoryRecords){</span>
<span class="fc" id="L252">			this.length = numOfInMemoryRecords;</span>
<span class="fc" id="L253">		}</span>
		
		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L257" title="All 2 branches covered.">			return counter&lt;length;</span>
		}

		@Override
		public void close() {
			//no-op
			
<span class="fc" id="L264">		}</span>

		@Override
		public SamRecord next() {
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">			if(!hasNext()){</span>
<span class="nc" id="L269">				throw new NoSuchElementException();</span>
			}
<span class="fc" id="L271">			return inMemoryArray[counter++];</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L276">			throw new UnsupportedOperationException();</span>
			
		}
		
	}
	/**
	 * Combine a list of pre-sorted Iterators into a single sorted iterator.
	 * Each call to {@link #next()} will peek at the next elements in the wrapped
	 * iterators and return the value that has the lowest sort value as determined
	 * by the comparator (and advance that iterator).
	 * @author dkatzel
	 *
	 */
	public static class MergedSortedRecordIterator implements Iterator&lt;SamRecord&gt; {
			private final List&lt;PeekableStreamingIterator&lt;SamRecord&gt;&gt; iterators;
			
			private SamRecord next;
			private final SortedSamRecordElementComparator comparator;
			private final List&lt;SortedSamRecordElement&gt; elementList;
			
			
<span class="fc" id="L297">			public MergedSortedRecordIterator(List&lt;PeekableStreamingIterator&lt;SamRecord&gt;&gt; iterators, Comparator&lt;SamRecord&gt; comparator) {</span>
<span class="fc" id="L298">				this.iterators = iterators;</span>
<span class="fc" id="L299">				this.comparator = new SortedSamRecordElementComparator(comparator);</span>
<span class="fc" id="L300">				elementList = new ArrayList&lt;SortedSamRecordElement&gt;(iterators.size());</span>
				
<span class="fc" id="L302">				next= getNext();</span>
<span class="fc" id="L303">			}</span>
			
			private SamRecord getNext(){
<span class="fc" id="L306">				elementList.clear();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">				for(PeekableStreamingIterator&lt;SamRecord&gt; iter : iterators){</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">					if(iter.hasNext()){</span>
						//we peek instead of next()
						//incase we don't pick this record yet
<span class="fc" id="L311">						elementList.add(new SortedSamRecordElement(iter.peek(), iter));</span>
					}
<span class="fc" id="L313">				}</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">				if(elementList.isEmpty()){</span>
<span class="fc" id="L315">					return null;</span>
				}
<span class="fc" id="L317">				Collections.sort(elementList, comparator);</span>
<span class="fc" id="L318">				SortedSamRecordElement element= elementList.get(0);</span>
				//advance iterator
<span class="fc" id="L320">				element.source.next();</span>
<span class="fc" id="L321">				return element.record;</span>
			}

			@Override
			public boolean hasNext() {
<span class="fc bfc" id="L326" title="All 2 branches covered.">				return next!=null;</span>
			}
			
			
			@Override
			public SamRecord next() {
				//don't need to check has next
				//since we can make sure we don't call it incorrectly
<span class="fc" id="L334">				SamRecord ret= next;</span>
<span class="fc" id="L335">				next = getNext();</span>
<span class="fc" id="L336">				return ret;</span>
			}
			
			@Override
			public void remove() {
<span class="nc" id="L341">				throw new UnsupportedOperationException();				</span>
			}

	}
	/**
	 * Struct that has a {@link SamRecord} and which
	 * iterator that record belong to so we can advance
	 * the iterator if selected.
	 * @author dkatzel
	 *
	 */
	private static class SortedSamRecordElement{
		SamRecord record;
		Iterator&lt;SamRecord&gt; source;
		
		public SortedSamRecordElement(SamRecord record,
<span class="fc" id="L357">				Iterator&lt;SamRecord&gt; source) {</span>
<span class="fc" id="L358">			this.record = record;</span>
<span class="fc" id="L359">			this.source = source;</span>
<span class="fc" id="L360">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L364">			return &quot;SortedSamRecordElement [record=&quot; + record + &quot;, source=&quot;</span>
					+ source + &quot;]&quot;;
		}
		
	}
	
	private static class SortedSamRecordElementComparator implements Comparator&lt;SortedSamRecordElement&gt;{
		private final Comparator&lt;SamRecord&gt; comparator;
		

<span class="fc" id="L374">		public SortedSamRecordElementComparator(Comparator&lt;SamRecord&gt; comparator) {</span>
<span class="fc" id="L375">			this.comparator = comparator;</span>
<span class="fc" id="L376">		}</span>


		@Override
		public int compare(SortedSamRecordElement o1, SortedSamRecordElement o2) {
<span class="nc" id="L381">			return comparator.compare(o1.record, o2.record);</span>
		}
		
	}
	/**
	 * Iterates over a sam (or bam) encoded file as a {@link StreamingIterator}.
	 * @author dkatzel
	 *
	 */
	private static class StreamingSamRecordIterator extends AbstractBlockingStreamingIterator&lt;SamRecord&gt;{

		private final File samFile;
		private final Encoding encoding;
		
<span class="nc" id="L395">		public StreamingSamRecordIterator(File samFile, Encoding encoding) {</span>
<span class="nc" id="L396">			this.samFile = samFile;</span>
<span class="nc" id="L397">			this.encoding = encoding;</span>
<span class="nc" id="L398">			this.start();</span>
<span class="nc" id="L399">		}</span>


		@Override
		protected void backgroundThreadRunMethod() throws RuntimeException {
			try {
<span class="nc" id="L405">				encoding.createNewNoValidationSamParser(samFile).parse(new SamVisitor() {</span>
					
					
					@Override
					public void visitRecord(SamVisitorCallback callback, SamRecord record,
							VirtualFileOffset start, VirtualFileOffset end) {
<span class="nc" id="L411">						StreamingSamRecordIterator.this.blockingPut(record);</span>
						
<span class="nc" id="L413">					}</span>
					
					
					@Override
					public void visitHeader(SamVisitorCallback callback, SamHeader header) {
						//no-op
						
<span class="nc" id="L420">					}</span>
					
					@Override
					public void visitEnd() {
						//no-op
						
<span class="nc" id="L426">					}</span>
					@Override
					public void halted() {
						
<span class="nc" id="L430">					}</span>



					
				});
<span class="nc" id="L436">			} catch (IOException e) {</span>
<span class="nc" id="L437">				throw new RuntimeException(&quot;error parsing temp sam file &quot; + samFile.getAbsolutePath(), e);</span>
<span class="nc" id="L438">			}</span>
			
<span class="nc" id="L440">		}</span>
		
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>