<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BamFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">BamFileParser.java</span></div><h1>BamFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.FileUtil;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.TextLineParser;
import org.jcvi.jillion.internal.sam.SamUtil;
import org.jcvi.jillion.sam.SamVisitor.SamVisitorCallback.SamVisitorMemento;
import org.jcvi.jillion.sam.attribute.InvalidAttributeException;
import org.jcvi.jillion.sam.attribute.ReservedAttributeValidator;
import org.jcvi.jillion.sam.attribute.SamAttribute;
import org.jcvi.jillion.sam.attribute.SamAttributeKey;
import org.jcvi.jillion.sam.attribute.SamAttributeKeyFactory;
import org.jcvi.jillion.sam.attribute.SamAttributeType;
import org.jcvi.jillion.sam.attribute.SamAttributeValidator;
import org.jcvi.jillion.sam.cigar.Cigar;
import org.jcvi.jillion.sam.cigar.CigarOperation;
import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamHeaderBuilder;
import org.jcvi.jillion.sam.header.SamReferenceSequenceBuilder;
/**
 * {@code BamFileParser} is a {@link SamParser}
 * that can parse BAM encoded files.
 * @author dkatzel
 *
 */
class BamFileParser extends AbstractSamFileParser {

	
<span class="fc" id="L66">	private static final VirtualFileOffset BEGINNING_OF_FILE = new VirtualFileOffset(0);</span>
	protected final File bamFile;
	protected final SamAttributeValidator validator;
	protected final String[] refNames;
	protected final SamHeader header;
	
	
	public BamFileParser(File bamFile) throws IOException {
<span class="nc" id="L74">		this(bamFile, ReservedAttributeValidator.INSTANCE);</span>
<span class="nc" id="L75">	}</span>
<span class="fc" id="L76">	public BamFileParser(File bamFile, SamAttributeValidator validator) throws IOException {</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">		if(bamFile ==null){</span>
<span class="nc" id="L78">			throw new NullPointerException(&quot;bam file can not be null&quot;);</span>
		}
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">		if(!&quot;bam&quot;.equals(FileUtil.getExtension(bamFile))){</span>
<span class="nc" id="L81">			throw new IllegalArgumentException(&quot;must be .bam file&quot; + bamFile.getAbsolutePath());</span>
		}
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">		if(!bamFile.exists()){</span>
<span class="nc" id="L84">			throw new FileNotFoundException(bamFile.getAbsolutePath());</span>
		}
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">		if(!bamFile.canRead()){</span>
<span class="nc" id="L87">			throw new IllegalArgumentException(&quot;bam file not readable &quot; + bamFile.getAbsolutePath());</span>
		}
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">		if(validator ==null){</span>
<span class="nc" id="L90">			throw new NullPointerException(&quot;validator can not be null&quot;);</span>
		}
<span class="fc" id="L92">		this.bamFile = bamFile;</span>
<span class="fc" id="L93">		this.validator = validator;</span>
		
<span class="pc" id="L95">		try(BgzfInputStream in = new BgzfInputStream(bamFile)){</span>
			
<span class="fc" id="L97">			verifyMagicNumber(in);</span>
			
<span class="fc" id="L99">			SamHeaderBuilder headerBuilder = parseHeader(new TextLineParser(IOUtil.toInputStream(readPascalString(in))));</span>
<span class="fc" id="L100">			refNames = parseReferenceNamesAndAddToHeader(in, headerBuilder);</span>
<span class="fc" id="L101">			header = headerBuilder.build();</span>
<span class="pc bpc" id="L102" title="6 of 8 branches missed.">		}</span>
<span class="fc" id="L103">	}</span>
	
	
	
	@Override
	public SamHeader getHeader() throws IOException {
<span class="fc" id="L109">		return header;</span>
	}
	@Override
	public boolean canParse() {
<span class="nc" id="L113">		return true;</span>
	}
	
	
	private void verifyReferenceInHeader(String referenceName){
<span class="fc" id="L118">		Objects.requireNonNull(referenceName);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">		if(header.getReferenceSequence(referenceName) == null){</span>
<span class="nc" id="L120">			throw new IllegalArgumentException(&quot;no reference with name '&quot;+ referenceName +&quot;' contained in Bam file&quot;);</span>
		}
<span class="fc" id="L122">	}</span>
	
	@Override
    public void parse(SamParserOptions options, SamVisitor visitor)
            throws IOException {
	    Predicate&lt;SamRecord&gt; predicate;
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if(options.getReferenceName().isPresent()){</span>
           
            
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if(options.getReferenceRange().isPresent()){</span>
<span class="nc" id="L132">                _parse(options.getReferenceName().get(), options.getReferenceRange().get(), options.shouldCreateMementos(), visitor);</span>
            }else{
<span class="nc" id="L134">                _parse(options.getReferenceName().get(), options.shouldCreateMementos(), visitor);</span>
                
            }
<span class="nc" id="L137">            return;</span>
        }else{
<span class="nc" id="L139">            predicate = record -&gt; true;</span>
        }
<span class="nc" id="L141">        accept(visitor, options.shouldCreateMementos(), predicate);</span>
        
<span class="nc" id="L143">    }</span>
	

	protected void _parse(String referenceName, Range alignmentRange, boolean shouldCreateMementos, SamVisitor visitor) throws IOException{
<span class="fc" id="L147">	    verifyReferenceInHeader(referenceName);</span>
<span class="fc" id="L148">            accept(visitor, shouldCreateMementos, SamUtil.alignsToReference(referenceName, alignmentRange));</span>
<span class="fc" id="L149">	}</span>
	protected void _parse(String referenceName, boolean shouldCreateMementos, SamVisitor visitor ) throws IOException{
<span class="fc" id="L151">            verifyReferenceInHeader(referenceName);</span>
<span class="fc" id="L152">            accept(visitor, shouldCreateMementos, SamUtil.alignsToReference(referenceName));</span>
<span class="fc" id="L153">        }</span>
	
    @Override
	public void parse(String referenceName, SamVisitor visitor) throws IOException {
<span class="fc" id="L157">		 _parse(referenceName, false, visitor);</span>
<span class="fc" id="L158">	}</span>
	@Override
	public void parse(String referenceName, Range alignmentRange, SamVisitor visitor) throws IOException {
<span class="fc" id="L161">	    _parse(referenceName, alignmentRange, false, visitor);		</span>
<span class="fc" id="L162">	}</span>
	
	@Override
	public void parse(SamVisitor visitor) throws IOException {
<span class="fc" id="L166">		accept(visitor, false, (record)-&gt;true);</span>
<span class="fc" id="L167">	}</span>
	
	@Override
	public void parse(SamVisitor visitor, SamVisitorMemento memento) throws IOException {
<span class="nc" id="L171">		Objects.requireNonNull(visitor);</span>
<span class="nc" id="L172">		Objects.requireNonNull(memento);</span>
		
<span class="nc bnc" id="L174" title="All 2 branches missed.">		if( !(memento instanceof BamFileMemento)){</span>
<span class="nc" id="L175">			throw new IllegalArgumentException(&quot;memento must be for bam file&quot;);</span>
		}
<span class="nc" id="L177">		BamFileMemento bamMemento = (BamFileMemento)memento;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">		if(this != bamMemento.parserInstance){</span>
<span class="nc" id="L179">			throw new IllegalArgumentException(&quot;memento must be for this exact bam parser instance&quot;);</span>
		}
		
<span class="nc bnc" id="L182" title="All 2 branches missed.">		if(bamMemento.encodedFileOffset ==0){</span>
			//start from beginning
<span class="nc" id="L184">			parse(visitor);</span>
<span class="nc" id="L185">			return;</span>
		}
		
<span class="nc" id="L188">		VirtualFileOffset vfs = new VirtualFileOffset(bamMemento.encodedFileOffset);</span>
		
		
		
<span class="nc" id="L192">		try(BgzfInputStream in = BgzfInputStream.create(bamFile, vfs)){</span>
<span class="nc" id="L193">			AtomicBoolean keepParsing = new AtomicBoolean(true);</span>

<span class="nc" id="L195">			parseBamRecords(visitor, (record)-&gt;true, (v)-&gt;true, in, keepParsing, new MementoLessBamCallback(keepParsing));</span>
<span class="nc bnc" id="L196" title="All 8 branches missed.">		}</span>
		
<span class="nc" id="L198">	}</span>
	
	
	
	private void accept(SamVisitor visitor, boolean enableMementos, Predicate&lt;SamRecord&gt; filter) throws IOException {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">		if(visitor ==null){</span>
<span class="nc" id="L204">			throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
		}
<span class="fc" id="L206">		try(BgzfInputStream in=new BgzfInputStream(bamFile)){			</span>
			
<span class="fc" id="L208">			parseBamFromBeginning(visitor, enableMementos, filter, (vfs)-&gt;true, in);</span>
<span class="pc bpc" id="L209" title="4 of 8 branches missed.">		}</span>
<span class="fc" id="L210">	}</span>
	
	protected void parseBamFromBeginning(SamVisitor visitor, boolean enableMementos, Predicate&lt;SamRecord&gt; filter, Predicate&lt;VirtualFileOffset&gt; keepParsingPredicate, BgzfInputStream in) throws IOException {
<span class="fc" id="L213">		verifyMagicNumber(in);</span>
		//have to keep parsing header again for now
		//since it updates the file pointer in our bgzf stream
		//probably not worth seeking/skipping for now...
<span class="fc" id="L217">		SamHeaderBuilder headerBuilder = parseHeader(new TextLineParser(IOUtil.toInputStream(readPascalString(in))));</span>
		
<span class="fc" id="L219">		parseReferenceNamesAndAddToHeader(in, headerBuilder);</span>
<span class="fc" id="L220">		AtomicBoolean keepParsing = new AtomicBoolean(true);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		AbstractBamCallback callback = enableMementos ? new BamCallback(keepParsing) : new MementoLessBamCallback(keepParsing);</span>
<span class="fc" id="L222">		visitor.visitHeader(callback, header);</span>
		
<span class="fc" id="L224">		parseBamRecords(visitor, filter, keepParsingPredicate, in, keepParsing, callback);</span>
<span class="fc" id="L225">	}</span>
	
	protected void parseBamRecords(SamVisitor visitor, Predicate&lt;SamRecord&gt; filter, Predicate&lt;VirtualFileOffset&gt; keepParsingPredicate, BgzfInputStream in, AtomicBoolean keepParsing, AbstractBamCallback callback) throws IOException {
		
<span class="fc" id="L229">		boolean canceledByPredicate=false;</span>
		
		try{
<span class="fc" id="L232">			VirtualFileOffset start = in.getCurrentVirutalFileOffset();</span>
<span class="pc bpc" id="L233" title="1 of 4 branches missed.">			while(keepParsing.get() &amp;&amp; in.hasMoreData()){	</span>
<span class="fc" id="L234">				SamRecord record = parseNextSamRecord(in, refNames, header);</span>
				
<span class="fc" id="L236">				VirtualFileOffset end = in.getCurrentVirutalFileOffset();</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">				if(keepParsingPredicate.test(start)){</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">					if(filter.test(record)){</span>
<span class="fc" id="L239">					    callback.updateCurrentPosition(start);</span>
<span class="fc" id="L240">					    visitor.visitRecord(callback, record, start,end);</span>
					}
				}else{
<span class="nc" id="L243">					keepParsing.set(false);</span>
<span class="nc" id="L244">					canceledByPredicate=true;</span>
				}
				
				//update start to be old end
<span class="fc" id="L248">				start = end;</span>
<span class="fc" id="L249">			}</span>
<span class="fc" id="L250">		}catch(EOFException e){</span>
			//ignore, we can't tell if we've hit
			//EOF until after we hit it otherwise
			//we will mess up the offset computations
<span class="fc" id="L254">		}</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">		if(canceledByPredicate || keepParsing.get()){</span>
<span class="fc" id="L256">			visitor.visitEnd();</span>
		}else{
<span class="fc" id="L258">			visitor.halted();</span>
		}
<span class="fc" id="L260">	}</span>
	
	private SamRecord parseNextSamRecord(InputStream in, String[] refNames, SamHeader header) throws IOException {
		//next alignment
<span class="fc" id="L264">		int blockSize = getSignedInt(in);</span>
<span class="fc" id="L265">		SamRecordBuilder builder = new SamRecordBuilder(header, validator);</span>
		
<span class="fc" id="L267">		int refId = getSignedInt(in);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">		if(refId &gt;=0){</span>
<span class="fc" id="L269">			builder.setReferenceName(refNames[refId]);</span>
		}
		//NOTE bam is 0-based while
		//SAM is 1-based
<span class="fc" id="L273">		int startPos = getSignedInt(in)+1;</span>
<span class="fc" id="L274">		builder.setStartPosition(startPos);</span>
<span class="fc" id="L275">		long binMqReadLength = getUnsignedInt(in);</span>
		//don't care about bin we can recompute it 
		//if we need it
		//int bin = (int)((binMqReadLength&gt;&gt;16) &amp; 0xFFFF);

<span class="fc" id="L280">		byte mapQuality = (byte)((binMqReadLength&gt;&gt;8) &amp; 0xFF);</span>
<span class="fc" id="L281">		builder.setMappingQuality(mapQuality);</span>
<span class="fc" id="L282">		int readNameLength = (int)(binMqReadLength &amp; 0xFF);</span>
		
<span class="fc" id="L284">		long flagsNumCigarOps = getUnsignedInt(in);</span>
<span class="fc" id="L285">		int bitFlags = (int)((flagsNumCigarOps&gt;&gt;16) &amp; 0xFFFF);</span>
		
<span class="fc" id="L287">		builder.setFlags(bitFlags);</span>
<span class="fc" id="L288">		int numCigarOps = (int)(flagsNumCigarOps &amp; 0xFFFF);</span>
<span class="fc" id="L289">		int seqLength = getSignedInt(in);</span>
		
		
<span class="fc" id="L292">		int nextRefId = getSignedInt(in);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">		if(nextRefId &gt;=0){</span>
<span class="fc" id="L294">			builder.setNextReferenceName(refNames[nextRefId]);</span>
		}
		//NOTE bam is 0-based while
		//SAM is 1-based
<span class="fc" id="L298">		builder.setNextPosition(getSignedInt(in)+1);</span>
<span class="fc" id="L299">		builder.setObservedTemplateLength(getSignedInt(in));</span>
		
<span class="fc" id="L301">		String readId = readNullTerminatedString(in, readNameLength);</span>
<span class="fc" id="L302">		builder.setQueryName(readId);</span>
		
		
<span class="fc bfc" id="L305" title="All 2 branches covered.">		if(numCigarOps &gt;0){</span>
<span class="fc" id="L306">			Cigar cigar = parseCigar(in, numCigarOps);</span>
<span class="fc" id="L307">			builder.setCigar(cigar);</span>
		}
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">		if(seqLength &gt;0){			</span>
<span class="fc" id="L310">			NucleotideSequence seq = SamUtil.readBamEncodedSequence(in,seqLength);</span>
<span class="fc" id="L311">			builder.setSequence(seq);</span>
<span class="fc" id="L312">			builder.setQualities(readQualities(in, seqLength));			</span>
		}
		//bytes read so far
		//8*int32s + char[readNameLength) + int32[numCigarOps] +uint8[(l_seq+1)/2] +char[l_seq])
<span class="fc" id="L316">		int bytesReadSoFar = 32+ 4*numCigarOps + readNameLength+ (seqLength+1)/2+ seqLength;</span>

<span class="fc" id="L318">		parseAttributesIfAnyAndAddToBuilder(in, builder, blockSize,	bytesReadSoFar);</span>
		
		
<span class="fc" id="L321">		return builder.build();</span>
	}
	private Cigar parseCigar(InputStream in, int numCigarOps)
			throws IOException {
<span class="fc" id="L325">		Cigar.Builder cigarBuilder = new Cigar.Builder(numCigarOps);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">		for(int i=0; i&lt;numCigarOps; i++){</span>
<span class="fc" id="L327">			long bits = getUnsignedInt(in);</span>
<span class="fc" id="L328">			int opCode = (int)(bits &amp;0xF);</span>
<span class="fc" id="L329">			int length = (int)(bits&gt;&gt;4);</span>
<span class="fc" id="L330">			cigarBuilder.addElement(CigarOperation.parseBinary(opCode), length);</span>
		}
<span class="fc" id="L332">		return cigarBuilder.build();</span>
	}
	private void parseAttributesIfAnyAndAddToBuilder(InputStream in,
			SamRecordBuilder builder, int blockSize, int bytesReadSoFar)
			throws IOException {
<span class="fc" id="L337">		int attributeByteLength =  blockSize - bytesReadSoFar;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">		if(attributeByteLength &gt;0){</span>
			//to simplify parsing
			//to slurp up the all the bytes for the attributes
			//and read through them as a new InputStream
<span class="fc" id="L342">			byte[] attributeBytes = new byte[attributeByteLength];</span>
<span class="fc" id="L343">			IOUtil.blockingRead(in, attributeBytes);</span>
<span class="fc" id="L344">			OpenAwareInputStream attributeStream = new OpenAwareInputStream(new ByteArrayInputStream(attributeBytes));</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">			while(attributeStream.isOpen()){</span>
				
<span class="fc" id="L347">				SamAttribute attribute = parseAttribute(attributeStream);</span>
				try {
<span class="fc" id="L349">					builder.addAttribute(attribute);</span>
<span class="nc" id="L350">				} catch (InvalidAttributeException e) {</span>
<span class="nc" id="L351">					throw new IOException(&quot;invalid attribute &quot; + attribute, e);</span>
<span class="fc" id="L352">				}</span>
<span class="fc" id="L353">			}</span>
		}
<span class="fc" id="L355">	}</span>
	private String[] parseReferenceNamesAndAddToHeader(InputStream in,
			SamHeaderBuilder headerBuilder) throws IOException {
<span class="fc" id="L358">		int referenceCount = getSignedInt(in);</span>
		//The reference names
		//are only given by 
		//index in the SAM records
		//below, so we will need to
		//keep an array of the names
		//in the correct order so we know
		//what everything is named.
<span class="fc" id="L366">		String[] refNames = new String[referenceCount];</span>
		
		
<span class="fc bfc" id="L369" title="All 2 branches covered.">		for(int i=0; i&lt;referenceCount; i++){</span>
<span class="fc" id="L370">			String name = readPascalString(in);</span>
<span class="fc" id="L371">			refNames[i] = name;</span>
<span class="fc" id="L372">			int length = getSignedInt(in);</span>
			//add ref to header if not yet present
<span class="fc bfc" id="L374" title="All 2 branches covered.">			if(!headerBuilder.hasReferenceSequence(name)){</span>
<span class="fc" id="L375">				headerBuilder.addReferenceSequence(new SamReferenceSequenceBuilder(name,length)</span>
<span class="fc" id="L376">													.build());</span>
			}
		
			
		}
<span class="fc" id="L381">		return refNames;</span>
	}
	private SamAttribute parseAttribute(OpenAwareInputStream in) throws IOException {
<span class="fc" id="L384">		SamAttributeKey key = SamAttributeKeyFactory.getKey((char) in.read(), (char) in.read());</span>
		
<span class="fc" id="L386">		char type = (char) in.read();</span>
<span class="pc bpc" id="L387" title="9 of 12 branches missed.">		switch(type){</span>
		//all single integer types are actually just SIGNED_INT in SAM
<span class="nc" id="L389">			case 'i' :  return new SamAttribute(key, SamAttributeType.SIGNED_INT,  IOUtil.readSignedInt(in));</span>
<span class="nc" id="L390">			case 'I' : return new SamAttribute(key, SamAttributeType.UNSIGNED_INT, IOUtil.readUnsignedInt(in));</span>

<span class="fc" id="L392">			case 'Z' : return new SamAttribute(key, SamAttributeType.STRING, readNullTerminatedStringAttribute(in));</span>
<span class="nc" id="L393">			case 'B' : return handleArray(key,in);</span>
			case 'A':
<span class="nc" id="L395">				return new SamAttribute(key, SamAttributeType.PRINTABLE_CHARACTER,  Character.valueOf((char)in.read()));</span>
			case 'c':
<span class="fc" id="L397">				return new SamAttribute(key, SamAttributeType.SIGNED_INT,  in.read());</span>
<span class="fc" id="L398">			case 'C' : return new SamAttribute(key, SamAttributeType.SIGNED_INT,  IOUtil.readUnsignedByte(in));</span>
<span class="nc" id="L399">			case 's' : return new SamAttribute(key, SamAttributeType.SIGNED_INT,  IOUtil.readSignedShort(in));</span>
<span class="nc" id="L400">			case 'S' : return new SamAttribute(key, SamAttributeType.SIGNED_INT,  IOUtil.readUnsignedShort(in));</span>
			
<span class="nc" id="L402">			case 'f' : return new SamAttribute(key, SamAttributeType.FLOAT,  IOUtil.readFloat(in));</span>
			
			
<span class="nc" id="L405">			case 'H' : return new SamAttribute(key, SamAttributeType.BYTE_ARRAY_IN_HEX,  toByteArray(readNullTerminatedStringAttribute(in))); </span>
<span class="nc" id="L406">			default : throw new IOException(&quot;unknown type : &quot; + type);</span>
		}
		
	}
	
	
	private SamAttribute handleArray(SamAttributeKey key, OpenAwareInputStream in) throws IOException {
<span class="nc" id="L413">		char arrayType = (char) in.read();</span>
<span class="nc" id="L414">		int length = IOUtil.readSignedInt(in);</span>
		//for memory packing, we read everything as
		//signed primitives. The SamAttributeType
		//class will handle converting the signed to unsigned
		//values for us without having to take up 2x the memory.
<span class="nc bnc" id="L419" title="All 8 branches missed.">		switch(arrayType){</span>
<span class="nc" id="L420">			case 'i' : return new SamAttribute(key, SamAttributeType.SIGNED_INT_ARRAY, IOUtil.readIntArray(in, length));</span>
<span class="nc" id="L421">			case 'I' : return new SamAttribute(key, SamAttributeType.UNSIGNED_INT_ARRAY, IOUtil.readIntArray(in, length));</span>
			
			case 'c':
<span class="nc" id="L424">				return new SamAttribute(key, SamAttributeType.SIGNED_BYTE_ARRAY, IOUtil.readByteArray(in, length));</span>
<span class="nc" id="L425">			case 'C' : return new SamAttribute(key, SamAttributeType.UNSIGNED_BYTE_ARRAY, IOUtil.readByteArray(in, length));</span>
<span class="nc" id="L426">			case 's' : return new SamAttribute(key, SamAttributeType.SIGNED_SHORT_ARRAY, IOUtil.readShortArray(in, length));</span>
<span class="nc" id="L427">			case 'S' : return new SamAttribute(key, SamAttributeType.UNSIGNED_SHORT_ARRAY, IOUtil.readShortArray(in, length));</span>
			
<span class="nc" id="L429">			case 'f' : return new SamAttribute(key, SamAttributeType.FLOAT_ARRAY, IOUtil.readFloatArray(in, length));</span>
			
<span class="nc" id="L431">			default : throw new IOException(&quot;unknown array type : &quot; + arrayType);</span>
		}

	}

	private byte[] toByteArray(String hex) {
		//2 chars per byte
<span class="nc" id="L438">		byte[] array = new byte[hex.length()/2];</span>
<span class="nc" id="L439">		char[] chars = hex.toCharArray();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">		for(int i=0; i&lt;chars.length; i+=2){</span>
<span class="nc" id="L441">			array[i] = Byte.parseByte(new String(chars, i, 2),16);</span>
		}
<span class="nc" id="L443">		return array;</span>
	}
	
	private String readNullTerminatedStringAttribute(OpenAwareInputStream in) throws IOException {
		//it looks like Strings are just null terminated
		//the length is not encoded
		//so just keep reading till we get to '\0'
<span class="fc" id="L450">		boolean done = false;</span>
<span class="fc" id="L451">		StringBuilder builder = new StringBuilder();</span>
		do{
<span class="fc" id="L453">			int value = in.read();</span>
<span class="pc bpc" id="L454" title="1 of 4 branches missed.">			if(value == -1 || value ==0){</span>
<span class="fc" id="L455">				done =true;</span>
			}else{
<span class="fc" id="L457">				builder.append((char)value);</span>
			}
<span class="pc bpc" id="L459" title="1 of 4 branches missed.">		}while(!done &amp;&amp; in.isOpen());</span>
<span class="fc" id="L460">		return builder.toString();</span>
	}
	
	
	private QualitySequence readQualities(InputStream in, int seqLength) throws IOException{
<span class="fc" id="L465">		byte[] bytes = new byte[seqLength];</span>
<span class="fc" id="L466">		IOUtil.blockingRead(in, bytes);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">		if(bytes[0] == -1){</span>
			//assume all values are negative
			/*
			//check all neg
			for(int i=1; i&lt;bytes.length; i++){
				if(bytes[i] != -1){
					throw new IllegalStateException(&quot;invalid qualities some but not all values are set&quot;);
				}
			}
			*/
			//if we are here all are -1 (not set)
<span class="fc" id="L478">			return null;</span>
		}
<span class="fc" id="L480">		return new QualitySequenceBuilder(bytes)</span>
					//we turn off data compression since we
					//usually stream through millions of these records and
					//often throw the results away
					//so we don't care if temporarily we take up more memory
<span class="fc" id="L485">					.turnOffDataCompression(true)</span>
<span class="fc" id="L486">					.build();</span>
	}
	private long getUnsignedInt(InputStream in) throws IOException {
<span class="fc" id="L489">		return IOUtil.readUnsignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
	}
	private int getSignedInt(InputStream in) throws IOException {
<span class="fc" id="L492">		return (int) IOUtil.readUnsignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
	}
	private void verifyMagicNumber(InputStream in) throws IOException {
<span class="fc" id="L495">		byte[] header = new byte[4];</span>
<span class="fc" id="L496">		IOUtil.blockingRead(in, header);</span>
		
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">		if(!SamUtil.matchesBamMagicNumber(header)){</span>
<span class="nc" id="L499">			throw new IOException(&quot;invalid bam magic number header : &quot; + Arrays.toString(header));</span>
		}
<span class="fc" id="L501">	}</span>

	private String readPascalString(InputStream in ) throws IOException{
<span class="fc" id="L504">		int length =getSignedInt(in);</span>
<span class="fc" id="L505">		return readNullTerminatedString(in, length);</span>
	}
	private String readNullTerminatedString(InputStream in, int lengthIncludingNull) throws IOException {
<span class="fc bfc" id="L508" title="All 2 branches covered.">		if(lengthIncludingNull ==0){</span>
<span class="fc" id="L509">			return &quot;&quot;;</span>
		}
		//TODO spec says char[] does
		//but looks like ASCII bytes so 1 byte per char?
<span class="fc" id="L513">		byte[] data = new byte[lengthIncludingNull];</span>
<span class="fc" id="L514">		IOUtil.blockingRead(in, data);</span>
		//don't include \0 at end of string
<span class="fc" id="L516">		return new String(data, 0, lengthIncludingNull-1,IOUtil.UTF_8);</span>
		
	}
	
	protected final class MementoLessBamCallback extends AbstractBamCallback{
<span class="fc" id="L521">	    public MementoLessBamCallback(AtomicBoolean keepParsing){</span>
<span class="fc" id="L522">                super(keepParsing);</span>
<span class="fc" id="L523">	    }</span>

            @Override
            public boolean canCreateMemento() {
<span class="nc" id="L527">                return false;</span>
            }
    
            @Override
            public SamVisitorMemento createMemento() {
<span class="nc" id="L532">                throw new UnsupportedOperationException();</span>
            }
    
            @Override
            public void updateCurrentPosition(VirtualFileOffset currentPosition) {
                //no-op            
<span class="fc" id="L538">            }</span>
	    
	}
	
	protected abstract class AbstractBamCallback extends AbstractCallback {
<span class="fc" id="L543">            public AbstractBamCallback(AtomicBoolean keepParsing) {</span>
<span class="fc" id="L544">                super(keepParsing);</span>
<span class="fc" id="L545">            }</span>

            public abstract void updateCurrentPosition(VirtualFileOffset currentPosition);
	}
	protected final class BamCallback extends AbstractBamCallback{
		private VirtualFileOffset offset;
		public BamCallback(AtomicBoolean keepParsing){
<span class="nc" id="L552">			this(keepParsing,BEGINNING_OF_FILE);</span>
<span class="nc" id="L553">		}</span>
<span class="nc" id="L554">		public BamCallback(AtomicBoolean keepParsing, VirtualFileOffset currentPosition) {</span>
<span class="nc" id="L555">			super(keepParsing);</span>
<span class="nc" id="L556">			this.offset = currentPosition;</span>
<span class="nc" id="L557">		}</span>
		@Override
		public void updateCurrentPosition(VirtualFileOffset currentPosition){
<span class="nc" id="L560">		    this.offset = currentPosition;</span>
<span class="nc" id="L561">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L565">			return true;</span>
		}

		@Override
		public SamVisitorMemento createMemento() {
<span class="nc" id="L570">			return new BamFileMemento(BamFileParser.this, offset.getEncodedValue());</span>
		}
		
	}
	
	private static final class BamFileMemento implements SamVisitorMemento{
		private final BamFileParser parserInstance;
		private final long encodedFileOffset;
		
<span class="nc" id="L579">		public BamFileMemento(BamFileParser parserInstance, long position) {</span>
<span class="nc" id="L580">			this.parserInstance = parserInstance;</span>
<span class="nc" id="L581">			this.encodedFileOffset = position;</span>
<span class="nc" id="L582">		}</span>

		@Override
		public int hashCode() {
<span class="nc" id="L586">			final int prime = 31;</span>
<span class="nc" id="L587">			int result = 1;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">			result = prime</span>
					* result
<span class="nc" id="L590">					+ ((parserInstance == null) ? 0 : parserInstance.hashCode());</span>
<span class="nc" id="L591">			result = prime * result + (int) (encodedFileOffset ^ (encodedFileOffset &gt;&gt;&gt; 32));</span>
<span class="nc" id="L592">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L597" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L598">				return true;</span>
			}
<span class="nc bnc" id="L600" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L601">				return false;</span>
			}
<span class="nc bnc" id="L603" title="All 2 branches missed.">			if (!(obj instanceof BamFileMemento)) {</span>
<span class="nc" id="L604">				return false;</span>
			}
<span class="nc" id="L606">			BamFileMemento other = (BamFileMemento) obj;</span>
			//has to be EXACT same instance
<span class="nc bnc" id="L608" title="All 2 branches missed.">			if (parserInstance != other.parserInstance) {</span>
<span class="nc" id="L609">				return false;</span>
			}
<span class="nc bnc" id="L611" title="All 2 branches missed.">			if (encodedFileOffset != other.encodedFileOffset) {</span>
<span class="nc" id="L612">				return false;</span>
			}
<span class="nc" id="L614">			return true;</span>
		}
		
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>