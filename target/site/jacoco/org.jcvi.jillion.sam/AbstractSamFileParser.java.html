<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractSamFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">AbstractSamFileParser.java</span></div><h1>AbstractSamFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.io.IOException;
import java.text.ParseException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.internal.core.io.LineParser;
import org.jcvi.jillion.internal.sam.SamUtil;
import org.jcvi.jillion.sam.SamVisitor.SamVisitorCallback;
import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamHeaderBuilder;
import org.jcvi.jillion.sam.header.SamProgramBuilder;
import org.jcvi.jillion.sam.header.SamReadGroup.PlatformTechnology;
import org.jcvi.jillion.sam.header.SamReadGroupBuilder;
import org.jcvi.jillion.sam.header.SamReferenceSequenceBuilder;
import org.jcvi.jillion.sam.header.SamVersion;

abstract class AbstractSamFileParser implements SamParser{

	static final String COMMENT_KEY = &quot;@CO&quot;;

	static final String PROGRAM_KEY = &quot;@PG&quot;;

	static final String READ_GROUP_KEY = &quot;@RG&quot;;

	static final String SEQUENCE_DICTIONARY_KEY = &quot;@SQ&quot;;



	static final String HEADER_KEY = &quot;@HD&quot;;
	private static final String HEADER_VERSION_TAG = &quot;VN&quot;;
	private static final String HEADER_SORT_TAG = &quot;SO&quot;;
	
<span class="fc" id="L61">	private static final Pattern HEADER_TAG_VALUE_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]):([ -~]+)&quot;);</span>
	
	
	public AbstractSamFileParser() {
<span class="fc" id="L65">		super();</span>
<span class="fc" id="L66">	}</span>

	protected SamHeaderBuilder parseHeader(LineParser parser) throws IOException {
		
<span class="fc" id="L70">		SamHeaderBuilder headerBuilder = new SamHeaderBuilder();</span>
<span class="fc" id="L71">		String currentLine = parser.peekLine();</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">		if(currentLine ==null){</span>
<span class="fc" id="L73">			return headerBuilder;</span>
		}
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">		if(currentLine.startsWith(HEADER_KEY)){</span>
<span class="fc" id="L76">			handleHeaderLine(currentLine, headerBuilder);</span>
			//actually consume the line we just peeked.
<span class="fc" id="L78">			parser.nextLine();</span>
			//next line			
<span class="fc" id="L80">			currentLine = parser.peekLine();</span>
		}
<span class="fc" id="L82">		boolean inHeader = true;</span>
<span class="fc bfc" id="L83" title="All 4 branches covered.">		while(currentLine !=null &amp;&amp; inHeader){</span>
<span class="fc" id="L84">			String trimmedLine = currentLine.trim();</span>
			//not sure if blank lines allowed?
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">			if(!trimmedLine.isEmpty()){</span>
					
<span class="fc bfc" id="L88" title="All 2 branches covered.">				if(currentLine.startsWith(SEQUENCE_DICTIONARY_KEY)){</span>
<span class="fc" id="L89">					handleSequenceDictionary(currentLine, headerBuilder);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">				}else if(currentLine.startsWith(READ_GROUP_KEY)){</span>
<span class="fc" id="L91">					handleReadGroup(currentLine, headerBuilder);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">				}else if(currentLine.startsWith(PROGRAM_KEY)){</span>
<span class="fc" id="L93">					handleProgram(currentLine, headerBuilder);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">				}else if(currentLine.startsWith(COMMENT_KEY)){</span>
<span class="fc" id="L95">					handleComment(currentLine, headerBuilder);</span>
				}else{
					//not in header?
<span class="fc" id="L98">					inHeader = false;</span>
				}
			}
<span class="fc bfc" id="L101" title="All 2 branches covered.">			if(inHeader){</span>
				//actually consume the line we just peeked.
<span class="fc" id="L103">				parser.nextLine();</span>
<span class="fc" id="L104">				currentLine = parser.peekLine();</span>
			}
<span class="fc" id="L106">		}</span>
<span class="fc" id="L107">		return headerBuilder;</span>
	}

	private void handleHeaderLine(String firstLine,
			SamHeaderBuilder headerBuilder) {
<span class="fc" id="L112">		Map&lt;String,String&gt; tags = parseTags(firstLine);</span>
		//version required
<span class="fc" id="L114">		SamVersion version = SamVersion.parseVersion(tags.get(HEADER_VERSION_TAG));</span>
<span class="fc" id="L115">		headerBuilder.setVersion(version);</span>
		
<span class="fc" id="L117">		headerBuilder.setSortOrder(SortOrder.parseSortOrder(tags.get(HEADER_SORT_TAG)));</span>
		
<span class="fc" id="L119">	}</span>
	
	private Map&lt;String, String&gt; parseTags(String line){
<span class="fc" id="L122">		Matcher matcher = HEADER_TAG_VALUE_PATTERN.matcher(line);</span>
<span class="fc" id="L123">		Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">		while(matcher.find()){</span>
<span class="fc" id="L125">			String tag = matcher.group(1);</span>
<span class="fc" id="L126">			String value = matcher.group(2);</span>
<span class="fc" id="L127">			map.put(tag, value);</span>
<span class="fc" id="L128">		}</span>
<span class="fc" id="L129">		return map;</span>
	}
	
	void handleComment(String line, SamHeaderBuilder headerBuilder) {
		//trim off first 3 characters to get rid of @CO
<span class="fc" id="L134">		headerBuilder.addComment(line.substring(3).trim());</span>
		
<span class="fc" id="L136">	}</span>

	void handleProgram(String line, SamHeaderBuilder headerBuilder) {
<span class="fc" id="L139">		Map&lt;String,String&gt; tags = parseTags(line);</span>
<span class="fc" id="L140">		String id = tags.get(&quot;ID&quot;);</span>
<span class="fc" id="L141">		SamProgramBuilder builder = new SamProgramBuilder(id);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;PN&quot;)){</span>
<span class="nc" id="L143">			builder.setName(tags.get(&quot;PN&quot;));</span>
		}
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;CL&quot;)){</span>
<span class="fc" id="L146">			builder.setCommandLine(tags.get(&quot;CL&quot;));</span>
		}
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;PP&quot;)){</span>
<span class="nc" id="L149">			builder.setPrevousProgramId(tags.get(&quot;PP&quot;));</span>
		}
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;DS&quot;)){</span>
<span class="nc" id="L152">			builder.setDescription(tags.get(&quot;DS&quot;));</span>
		}
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;VN&quot;)){</span>
<span class="nc" id="L155">			builder.setVersion(tags.get(&quot;VN&quot;));</span>
		}
<span class="fc" id="L157">		headerBuilder.addProgram(builder.build());</span>
		
<span class="fc" id="L159">	}</span>

	void handleReadGroup(String line, SamHeaderBuilder headerBuilder) {
<span class="fc" id="L162">		Map&lt;String,String&gt; tags = parseTags(line);</span>
<span class="fc" id="L163">		String id = tags.get(&quot;ID&quot;);</span>
<span class="fc" id="L164">		SamReadGroupBuilder builder = new SamReadGroupBuilder(id);</span>
		
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;CN&quot;)){</span>
<span class="fc" id="L167">			builder.setSequencingCenter(tags.get(&quot;CN&quot;));</span>
		}
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;DS&quot;)){</span>
<span class="nc" id="L170">			builder.setDescription(tags.get(&quot;DS&quot;));</span>
		}
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;DT&quot;)){</span>
			try {
<span class="fc" id="L174">				Date date = SamUtil.toDate(tags.get(&quot;DT&quot;));</span>
<span class="fc" id="L175">				builder.setRunDate(date);</span>
<span class="nc" id="L176">			} catch (ParseException e) {</span>
<span class="nc" id="L177">				throw new IllegalStateException(&quot;invalid date format : &quot; + tags.get(&quot;DT&quot;), e);</span>
<span class="fc" id="L178">			}</span>
		}
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;FO&quot;)){</span>
<span class="nc" id="L181">			NucleotideSequence flowOrder = new NucleotideSequenceBuilder(tags.get(&quot;FO&quot;)).build();</span>
<span class="nc" id="L182">			builder.setFlowOrder(flowOrder);</span>
		}
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;KS&quot;)){</span>
<span class="nc" id="L185">			NucleotideSequence keySequence = new NucleotideSequenceBuilder(tags.get(&quot;KS&quot;)).build();</span>
<span class="nc" id="L186">			builder.setKeySequence(keySequence);</span>
		}
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;LB&quot;)){</span>
<span class="fc" id="L189">			builder.setLibrary(tags.get(&quot;LB&quot;));</span>
		}
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;PG&quot;)){</span>
<span class="nc" id="L192">			builder.setPrograms(tags.get(&quot;PG&quot;));</span>
		}
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;PI&quot;)){</span>
<span class="fc" id="L195">			int insertSize = Integer.parseInt(tags.get(&quot;PI&quot;));</span>
<span class="fc" id="L196">			builder.setPredictedInsertSize(insertSize);</span>
		}
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;PL&quot;)){</span>
<span class="fc" id="L199">			String value = tags.get(&quot;PL&quot;);</span>
<span class="fc" id="L200">			PlatformTechnology platform = PlatformTechnology.parse(value);</span>
<span class="fc" id="L201">			builder.setPlatform(platform);</span>
		}
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;PU&quot;)){</span>
<span class="fc" id="L204">			builder.setPlatformUnit(tags.get(&quot;PU&quot;));</span>
		}
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;SM&quot;)){</span>
<span class="fc" id="L207">			builder.setSampleOrPoolName(tags.get(&quot;SM&quot;));</span>
		}
		
<span class="fc" id="L210">		headerBuilder.addReadGroup(builder.build());</span>
		
<span class="fc" id="L212">	}</span>

	void handleSequenceDictionary(String line,
			SamHeaderBuilder headerBuilder) {
<span class="fc" id="L216">		Map&lt;String,String&gt; tags = parseTags(line);</span>
		
<span class="fc" id="L218">		String name = tags.get(&quot;SN&quot;);</span>
<span class="fc" id="L219">		int length = Integer.parseInt(tags.get(&quot;LN&quot;));</span>
<span class="fc" id="L220">		SamReferenceSequenceBuilder builder = new SamReferenceSequenceBuilder(name, length);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		if(tags.containsKey(&quot;AS&quot;)){</span>
<span class="nc" id="L222">			builder.setGenomeAssemblyId(tags.get(&quot;AS&quot;));</span>
		}
<span class="fc bfc" id="L224" title="All 2 branches covered.">		if(tags.containsKey(&quot;M5&quot;)){</span>
<span class="fc" id="L225">			builder.setMd5(tags.get(&quot;M5&quot;));</span>
		}
<span class="fc bfc" id="L227" title="All 2 branches covered.">		if(tags.containsKey(&quot;SP&quot;)){</span>
<span class="fc" id="L228">			builder.setSpecies(tags.get(&quot;SP&quot;));</span>
		}
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if(tags.containsKey(&quot;UR&quot;)){</span>
<span class="fc" id="L231">			builder.setUri(tags.get(&quot;UR&quot;));</span>
		}
		
<span class="fc" id="L234">		headerBuilder.addReferenceSequence(builder.build());</span>
		
<span class="fc" id="L236">	}</span>
	
	
	abstract static class AbstractCallback implements SamVisitorCallback{
		private final AtomicBoolean keepParsing;		
		

<span class="fc" id="L243">		public AbstractCallback(AtomicBoolean keepParsing) {</span>
<span class="fc" id="L244">			this.keepParsing = keepParsing;</span>
<span class="fc" id="L245">		}</span>

		@Override
		public void haltParsing() {
<span class="fc" id="L249">			keepParsing.set(false);</span>
			
<span class="fc" id="L251">		}</span>
		
		public boolean keepParsing(){
<span class="nc" id="L254">			return keepParsing.get();</span>
		}
		
	}
	
	public SamHeader getHeader() throws IOException {
<span class="fc" id="L260">		final SamHeader[] headerArray = new SamHeader[1];</span>
<span class="fc" id="L261">		this.parse(new AbstractSamVisitor() {</span>
			
			@Override
			public void visitHeader(SamVisitorCallback callback, SamHeader header) {
<span class="fc" id="L265">				headerArray[0] = header;</span>
<span class="fc" id="L266">				callback.haltParsing();</span>
				
<span class="fc" id="L268">			}</span>
		
		});
<span class="fc" id="L271">		return headerArray[0];</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>