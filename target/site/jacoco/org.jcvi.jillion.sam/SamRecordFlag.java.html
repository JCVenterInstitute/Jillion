<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SamRecordFlag.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">SamRecordFlag.java</span></div><h1>SamRecordFlag.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.util.EnumSet;
import java.util.Set;
/**
 * {@code SamRecordFlags} is an object representation
 * of the SAM bit flags column for each record.
 * @author dkatzel
 *
 */
<span class="pc" id="L31">public enum SamRecordFlag {</span>

	/*
	 * 0x1 template having multiple segments in sequencing
0x2 each segment properly aligned according to the aligner
0x4 segment unmapped
0x8 next segment in the template unmapped
0x10 SEQ being reverse complemented
0x20 SEQ of the next segment in the template being reversed
0x40 the first segment in the template
0x80 the last segment in the template
0x100 secondary alignment
0x200 not passing quality controls
0x400 PCR or optical duplicate
0x800 supplementary alignment
	 */
	
	//primary alignment flag = 100100000000 0x900 &amp; FLAG = 0
	//0x800 = supp align	   100000000000
	//0x100 secondary align 	  100000000
	//                             10100011
	//                              1010011
	//                         100000010000
	/**
	 *  Notes that the read multi-mapped
	 * and so will have multiple alignment records.
	 */
<span class="fc" id="L58">	HAS_MATE_PAIR(1),</span>
<span class="fc" id="L59">	EACH_SEGMENT_PROPERLY_ALIGNED(2),</span>
	/**
	 * This is the only reliable place to 
	 * tell whether the read is unmapped. If {@link #READ_UNMAPPED} is set,
	 *  no assumptions can be made about {@link SamRecord#getReferenceName()},
	 *  {@link SamRecord#getStartPosition()}, {@link SamRecord#getCigar()},
	 *  {@link SamRecord#getMappingQuality()} and the {@link SamRecordFlags} :
	 *  {@link #EACH_SEGMENT_PROPERLY_ALIGNED}, {@link #REVERSE_COMPLEMENTED},
	 *  {@link #SECONDARY_ALIGNMENT}, {@link #SUPPLEMENTARY_ALIGNMENT}
	 *  and {@link #MATE_REVERSE_COMPLEMENTED}
	 * of the previous read in the template.
	 */
<span class="fc" id="L71">	READ_UNMAPPED(4),</span>
	/**
	 * Does this read's mate have its
	 * {@link #READ_UNMAPPED} flag set.
	 */
<span class="fc" id="L76">	MATE_UNMAPPED(8),</span>
	/**
	 * Is this read reverse complemented.
	 * If this flag is present,
	 * then this read's {@link org.jcvi.jillion.core.Direction}
	 * is {@link org.jcvi.jillion.core.Direction#REVERSE};
	 * otherwise it's  {@link org.jcvi.jillion.core.Direction#FORWARD}.
	 */
<span class="fc" id="L84">	REVERSE_COMPLEMENTED(0x10),</span>
	/**
	 * Does this read's mate have its
	 * {@link #REVERSE_COMPLEMENTED} flag set.
	 */
<span class="fc" id="L89">	MATE_REVERSE_COMPLEMENTED(0x20),</span>
	/**
	 * This the first read of a mate 
	 * pair.
	 */
<span class="fc" id="L94">	FIRST_MATE_OF_PAIR(0x40),</span>
	/**
	 * This the second read of a mate pair.
	 */
<span class="fc" id="L98">	SECOND_MATE_OF_PAIR(0x80),</span>
	/**
	 * Marks the alignment not to be used in certain 
	 * analyses when the tools in use are
	 * aware of this. It is typically used to 
	 * flag alternative mappings when multiple mappings
	 * are presented in a SAM.
	 */
<span class="fc" id="L106">	SECONDARY_ALIGNMENT(0x100),</span>
	/**
	 * This read has failed some kind
	 * of QC check.
	 */
<span class="fc" id="L111">	FAILED_QC(0x200),</span>
<span class="fc" id="L112">	DUPLICATE(0x400),</span>
	/**
	 * Indicates that the corresponding alignment line
	 *  is part of a chimeric alignment.
	 *  A line flagged with this is called as a supplementary line.
	 */
<span class="fc" id="L118">	SUPPLEMENTARY_ALIGNMENT(0x800)</span>
	
	;
	
	private final short value;

<span class="fc" id="L124">	private SamRecordFlag(int value) {</span>
<span class="fc" id="L125">		this.value = (short) value;</span>
<span class="fc" id="L126">	}</span>
	
	public int getBitFlags(){
<span class="fc" id="L129">	    return value;</span>
	}
	
	public boolean matches(int bitflags){
<span class="fc bfc" id="L133" title="All 2 branches covered.">		return value == (bitflags &amp; value);</span>
	}
	
	/**
	 * Parse the given bit flags (as an int)
	 * into the equivalent Set of {@link SamRecordFlags}.
	 * The input of this method should be
	 * the output of {@link #asBits(Set)}
	 * and vice versa.
	 * @param bitFlags the bitFlag representation as an int;
	 * msut be &gt;=0.
	 * @return a Set of {@link SamRecordFlags};
	 * will never be null but may be empty
	 * if no flags are set (bitFlags ==0 ).
	 * @throws IllegalArgumentException if bitFlags is negative.
	 * @see #asBits(Set)
	 */
	public static Set&lt;SamRecordFlag&gt; parseFlags(int bitFlags){
<span class="fc bfc" id="L151" title="All 2 branches covered.">		if(bitFlags &lt;0){</span>
<span class="fc" id="L152">			throw new IllegalArgumentException(&quot;bit flags value can not be negative&quot;);</span>
		}
<span class="fc" id="L154">		EnumSet&lt;SamRecordFlag&gt; set = EnumSet.noneOf(SamRecordFlag.class);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">		for(SamRecordFlag flag : values()){</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			if(flag.matches(bitFlags)){</span>
<span class="fc" id="L157">				set.add(flag);</span>
			}
		}
<span class="fc" id="L160">		return set;</span>
	}
	/**
	 * Compute the integer bit flag value
	 * of the given Set of {@link SamRecordFlags}.
	 * The input of this method should be
	 * the output of {@link #parseFlags(int)}
	 * and vice versa.
	 * @param flags the flags to set;
	 * can not be null
	 * @return an int, will never be &lt; 0.
	 * @throws NullPointerException if flags is null.
	 * @see SamRecordFlags#parseFlags(int)
	 */
	public static int asBits(Set&lt;SamRecordFlag&gt; flags){
<span class="fc" id="L175">		int value=0;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		for(SamRecordFlag flag : flags){</span>
<span class="fc" id="L177">			value |= flag.value;</span>
<span class="fc" id="L178">		}</span>
<span class="fc" id="L179">		return value;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>