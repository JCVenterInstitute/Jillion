<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BgzfOutputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">BgzfOutputStream.java</span></div><h1>BgzfOutputStream.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.zip.CRC32;
import java.util.zip.Deflater;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.sam.IndexerCallback;
/**
 * {@code BgzfOutputStream} is an {@link OutputStream}
 * implementation that writes out data as
 * a set of concatenated GZIP blocks with the 
 * appropriate Extra fields set in the header
 * to conform to the BGZF format
 * specified in the BAM file format specification.
 * &lt;p&gt;
 * NOT THREAD SAFE
 * &lt;/p&gt;
 * @author dkatzel
 *
 */
final class BgzfOutputStream extends OutputStream{
	
	/**
	 * Max compressed block size should never be &gt; max uncompressed block size.
	 * Since the maximum size that an uncompressed GZIP block
	 * can be in a BGZF file is imposed
	 * by the virtual file offsets  when indexing
	 * BAM files whose largest offset is (1&lt;&lt;16) -1
	 * we can make the max length 1&lt;&lt;16.
	 */
	private static final int MAX_COMPRESSED_BLOCK_SIZE = 1 &lt;&lt;16;
	/**
	 * Size of BGZF block not counting the actual compressed data
	 */
	private static final int BGZF_BLOCK_FULL_HEADER_LENGTH = 26;
	/**
	 * Maximum size that an uncompressed GZIP block
	 * can be in a BGZF file. This limit is imposed
	 * by the virtual file offsets when indexing
	 * BAM files to at most (1&lt;&lt;16) -1.
	 */
	private static final int MAX_UNCOMPRESSED_BLOCK_SIZE = MAX_COMPRESSED_BLOCK_SIZE - BGZF_BLOCK_FULL_HEADER_LENGTH;
	
	/**
	 * Use the compression level SAMTool's Picard uses,
	 * not sure why they use {@value} instead of the default.
	 */
	private static final int GZIP_COMPRESSION_LEVEL = 5;
	
	/**
	 * Common header to all BGZF encoded blocks
	 * that contains most of the GZIP header specified
	 * in RFC1952 as well as most of the extra fields
	 * required by BGZF encoded data.
	 * To make a valid BGZF block, append to this header:
	 * &lt;ol&gt;
	 * &lt;li&gt;The total length of this block minus 1&lt;/li&gt;
	 * &lt;li&gt; the GZIP compressed data&lt;/li&gt;
	 * &lt;li&gt; the GZIP compressed data which should be the total length of this block minus 20&lt;/li&gt;
	 * &lt;li&gt;the CRC-32 value of the compressed data as an uint32&lt;/li&gt;
	 * &lt;li&gt;The length of the uncompressed data as an uint32&lt;/li&gt;
	 * &lt;/ol&gt;
	 */
<span class="fc" id="L91">	private static final byte[] BGZF_BLOCK_HEADER = new byte[]{</span>
		
		0x1F , (byte)0x8B , 		//gzip ID
		0x08 ,						//compressionMode
		0x04 ,						//Flag bits set indicating Extra fields present
		0x00 , 0x00 ,0x00 ,0x00 ,	//unknown timestamp
		0x00 ,						//no extra flags
		(byte)0xff ,				//unknown OS
		0x06 ,	0x00 ,				//Extra field length = 6 bytes (little Endian)
		0x42 ,  0x43 ,				//BGZF id
		0x02 ,	0x00 ,				//subfield length = 2 bytes (little Endian)
	};
	/**
	 * An End of File Trailer block written to the end
	 * of BAM files so that unintended file truncation can be easily detected.
	 */
	private static final byte[] EOF_MARKER;	
	
<span class="fc" id="L109">	private final CRC32 currentCrc32 = new CRC32();</span>
	/**
	 * The number of bytes written to our uncompressedBuffer
	 * so far that have not yet been flushed.
	 * This value is updated on calls to write().
	 */
<span class="fc" id="L115">	private int currentUsedBufferLength=0;</span>
	/**
	 * The amount of bytes written out so far to the 
	 * wrapped OutputStream in the form of BGZF blocks.
	 * This value is updated on calls to {@link #flush()}.
	 */
<span class="fc" id="L121">	private long compressedBytesWrittenSoFar=0;</span>
	/**
	 * Our buffer storing the bytes to be flushed to our
	 * wrapped outputStream.
	 */
<span class="fc" id="L126">	private final byte[] uncompressedBuffer = new byte[MAX_UNCOMPRESSED_BLOCK_SIZE];</span>
	/**
	 * Temparary buffer to store our compressed version of the 
	 * uncompressed data when we are flushing.
	 * This can be made into a local variable of {@link #flush()}
	 * but this way we don't have to worry about
	 * extra allocations.
	 */
<span class="fc" id="L134">	private final byte[] compressedBuffer = new byte[MAX_COMPRESSED_BLOCK_SIZE];</span>
	/**
	 * The {@link OutputStream} we flush
	 * the compressed data to.
	 */
	private final OutputStream out;
	/**
	 * Reference to a {@link IndexerCallback}
	 * if an observer is interested in where
	 * each call to write() is written in the wrapped
	 * outputStream.  May be {@code null}
	 * if there is no callback.
	 */
	private final IndexerCallback callback;
	/**
	 * Used by {@link #write(int)}
	 * to reduce extra variable creation
	 * by always reusing the same array.
	 * @see #write(int)
	 */
<span class="fc" id="L154">	private final byte[] singleByteArray = new byte[1];</span>
	

	static{
<span class="fc" id="L158">		EOF_MARKER = new byte[28];</span>
		//start with same BGZF block header
<span class="fc" id="L160">		System.arraycopy(BGZF_BLOCK_HEADER, 0, EOF_MARKER,  0, BGZF_BLOCK_HEADER.length);</span>
		//the rest of the block is all zeros except for
		//these two bytes
<span class="fc" id="L163">		EOF_MARKER[16] = 0x1b;  	//BSIZE - 1 = EOF_MARKER.length - 1</span>
<span class="fc" id="L164">		EOF_MARKER[18] = 0x03;		//first byte of compressed data ?</span>
<span class="fc" id="L165">	}</span>
	
	/**
	 * Create a new {@link BgzfOutputStream}
	 * that will write BGZF encoded data to the given
	 * outputStream.
	 * @param outputBam the {@link File} to write to;
	 * can not be null.  If the file, or any parent directories
	 * do not exist, then they will be created.
	 * @param callback the {@link IndexerCallback} to call back to
	 * on during when writing to this {@link BgzfOutputStream};
	 * if {@code null} then no callbacks will be called.
	 * 
	 * @throws NullPointerException if out is null.
	 * @throws IOException if there is a problem creating the output file.
	 */
<span class="fc" id="L181">	BgzfOutputStream(File outputBam, IndexerCallback callback) throws IOException {</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		if(outputBam ==null){</span>
<span class="nc" id="L183">			throw new NullPointerException(&quot;output can not be null&quot;);</span>
		}
<span class="fc" id="L185">		IOUtil.mkdirs(outputBam.getParentFile());</span>
<span class="fc" id="L186">		this.out = new BufferedOutputStream(new FileOutputStream(outputBam), MAX_COMPRESSED_BLOCK_SIZE);</span>
<span class="fc" id="L187">		this.callback = callback;</span>
<span class="fc" id="L188">	}</span>
	
	/**
	 * {@inheritDoc}.
	 */
	@SuppressWarnings(&quot;PMD.SingularField&quot;)
	@Override
	public void write(int b) throws IOException {
<span class="nc" id="L196">		singleByteArray[0] = (byte)b;</span>
<span class="nc" id="L197">		handleWrite(singleByteArray, 0, 1);</span>
		
<span class="nc" id="L199">	}</span>
	
	/**
	 * {@inheritDoc}.
	 */
	@Override
	public void write(byte[] b) throws IOException {
<span class="fc" id="L206">		handleWrite(b, 0, b.length);</span>
<span class="fc" id="L207">	}</span>
	/**
	 * {@inheritDoc}.
	 */
	@Override
	public void write(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L213">		handleWrite(b, off, len);</span>
<span class="nc" id="L214">	}</span>
	/**
	 * Take the given bytes to be written and
	 * try to write them to our in memory buffer.
	 * If the in memory buffer fills up, 
	 * then compress in memory buffer and write
	 * the compressed data to the wrapped
	 * OutputStream as one or more BGZF blocks
	 * and call the callback if there is one.
	 * 
	 * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
	 * @throws IOException if there is a problem encoding or writing out the data.
	 */
	private void handleWrite(byte[] b, int off, int bytesToWriteLength) throws IOException{
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">		if(bytesToWriteLength &lt;0){</span>
			//follow OutputStream spec and throw Exception
<span class="nc" id="L232">			throw new IndexOutOfBoundsException(&quot;length can not be negative : &quot;+ bytesToWriteLength);</span>
		}
<span class="fc bfc" id="L234" title="All 2 branches covered.">		if(callback ==null){</span>
<span class="fc" id="L235">			handleWriteBody(b, off, bytesToWriteLength);</span>
		}else{
			//get before and after values
			//for our callback
<span class="fc" id="L239">			VirtualFileOffset start = getVirtualFileOffset();</span>
			
<span class="fc" id="L241">			handleWriteBody(b, off, bytesToWriteLength);</span>
			
<span class="fc" id="L243">			VirtualFileOffset end = getVirtualFileOffset();</span>
			
			
<span class="fc" id="L246">			callback.encodedIndex(start, end);</span>
		}
		
<span class="fc" id="L249">	}</span>
	
	
	public VirtualFileOffset getVirtualFileOffset(){
<span class="fc" id="L253">		return VirtualFileOffset.create(compressedBytesWrittenSoFar, currentUsedBufferLength);</span>
	}
	/**
	 * Take the given bytes to be written and
	 * try to write them to our in memory buffer.
	 * If the in memory buffer fills up, 
	 * then compress in memory buffer and write
	 * the compressed data to the wrapped
	 * OutputStream as one or more BGZF blocks.
	 * 
	 * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
	 * @throws IOException if there is a problem encoding or writing out the data.
	 */
	private void handleWriteBody(byte[] b, int off, int bytesToWriteLength) throws IOException{
		//this method is only called by handleWrite()
		//which has done all the range checks already
		//so we don't have to.
		
		
		//loop through the data in chunks that fit
		//into the current uncompressedBuffer
		//and write potentially multiple concatenated blocks.
		//There isn't anything in the BGZF spec
		//that says
		//a record can't span multiple blocks
		//so I think we can arbitrarily 
		//break blocks whenever we need.
<span class="fc" id="L282">		int currentOffset = off;</span>
<span class="fc" id="L283">		int bytesLeftToWrite = bytesToWriteLength;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">		while(bytesLeftToWrite &gt; 0){</span>
<span class="fc" id="L285">			int bytesFreeInBuffer = MAX_UNCOMPRESSED_BLOCK_SIZE - currentUsedBufferLength;</span>
<span class="fc" id="L286">			int bytesToWriteIntoCurrentBuffer = Math.min(bytesLeftToWrite,bytesFreeInBuffer);</span>
			
<span class="fc" id="L288">			System.arraycopy(b, currentOffset, uncompressedBuffer, currentUsedBufferLength, bytesToWriteIntoCurrentBuffer);</span>
			
<span class="fc" id="L290">			currentUsedBufferLength += bytesToWriteIntoCurrentBuffer;</span>
<span class="fc" id="L291">			currentOffset += bytesToWriteIntoCurrentBuffer;</span>
<span class="fc" id="L292">			bytesLeftToWrite -= bytesToWriteIntoCurrentBuffer;</span>
			
<span class="fc bfc" id="L294" title="All 2 branches covered.">			if(currentUsedBufferLength == MAX_UNCOMPRESSED_BLOCK_SIZE){</span>
				//we have filled our uncompressedBuffer
				//write one block to the wrapped outputStream
<span class="fc" id="L297">				flush();</span>
			}
<span class="fc" id="L299">		}</span>
		
<span class="fc" id="L301">	}</span>
	
	/**
	 * Flush the current buffer out to the wrapped {@link OutputStream}
	 * as concatenated BGZF blocks - 
	 * &lt;strong&gt;This method should not be called directly.&lt;/strong&gt;
	 */
	@Override
	public void flush() throws IOException {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">		if(currentUsedBufferLength &gt;0){</span>
			//create a new Deflater each time.
			//There were problems caused by re-using
			//the deflater across blocks
			//probably because we call finish() ?
<span class="fc" id="L315">			Deflater currentDeflater = new Deflater(GZIP_COMPRESSION_LEVEL, true);</span>
			
<span class="fc" id="L317">			currentDeflater.setInput(uncompressedBuffer, 0, currentUsedBufferLength);</span>
<span class="fc" id="L318">			currentDeflater.finish();</span>
			
<span class="fc" id="L320">			int compressedLength =currentDeflater.deflate(compressedBuffer);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">			if(!currentDeflater.finished()){</span>
<span class="nc" id="L322">				Deflater noCompresessionDeflater = new Deflater(Deflater.NO_COMPRESSION, true);</span>
<span class="nc" id="L323">				noCompresessionDeflater.setInput(uncompressedBuffer, 0, currentUsedBufferLength);</span>
<span class="nc" id="L324">				noCompresessionDeflater.finish();</span>
				
<span class="nc" id="L326">				compressedLength =noCompresessionDeflater.deflate(compressedBuffer);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">				if(!noCompresessionDeflater.finished()){</span>
					//shouldn't happen
<span class="nc" id="L329">					throw new IOException(&quot;could not compress block to fit max size&quot;);</span>
				}
			}
<span class="fc" id="L332">			currentCrc32.reset();</span>
			//CRC is the check sum of the UNCOMPRESSED data
<span class="fc" id="L334">			currentCrc32.update(uncompressedBuffer, 0, currentUsedBufferLength);</span>

<span class="fc" id="L336">			ByteBuffer bgzfBlockBuffer = ByteBuffer.allocate(compressedLength + BGZF_BLOCK_FULL_HEADER_LENGTH);</span>
<span class="fc" id="L337">			bgzfBlockBuffer.order(ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L338">			bgzfBlockBuffer.put(BGZF_BLOCK_HEADER);</span>
			//spec says write BSIZE -1
			//I guess to make sure the 
			//size will always fit in unsigned short.
			//
			//since we don't write out empty blocks
			//in this format subtracting 1 will never make a negative number.
<span class="fc" id="L345">			bgzfBlockBuffer.putShort((short)(bgzfBlockBuffer.capacity() -1));</span>
<span class="fc" id="L346">			bgzfBlockBuffer.put(compressedBuffer,0,compressedLength);</span>
<span class="fc" id="L347">			bgzfBlockBuffer.putInt((int)currentCrc32.getValue());</span>
<span class="fc" id="L348">			bgzfBlockBuffer.putInt(currentUsedBufferLength);</span>
<span class="fc" id="L349">			bgzfBlockBuffer.flip();</span>
<span class="fc" id="L350">			byte[] asBytes = new byte[bgzfBlockBuffer.remaining()];</span>
<span class="fc" id="L351">			bgzfBlockBuffer.get(asBytes);</span>
<span class="fc" id="L352">			out.write(asBytes);</span>
			//out.flush();
			//update counters
<span class="fc" id="L355">			compressedBytesWrittenSoFar += asBytes.length;</span>
			//reset buffer
<span class="fc" id="L357">			currentUsedBufferLength = 0;</span>
		}
<span class="fc" id="L359">	}</span>

	@Override
	public void close() throws IOException {
<span class="fc" id="L363">		flush();</span>
<span class="fc" id="L364">		out.write(EOF_MARKER);</span>
<span class="fc" id="L365">		out.close();</span>
<span class="fc" id="L366">	}</span>

	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>