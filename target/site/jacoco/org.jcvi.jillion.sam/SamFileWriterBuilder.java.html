<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SamFileWriterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">SamFileWriterBuilder.java</span></div><h1>SamFileWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.io.File;
import java.io.IOException;

import org.jcvi.jillion.core.io.FileUtil;
import org.jcvi.jillion.internal.sam.index.BamIndexer;
import org.jcvi.jillion.sam.attribute.ReservedAttributeValidator;
import org.jcvi.jillion.sam.attribute.SamAttributeValidator;
import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamHeaderBuilder;
/**
 * {@code SamFileWriterBuilder}
 * is a Builder object that will create
 * a {@link SamWriter} implementation
 * to write out either SAM or BAM formatted files
 * and optionally re-sort them.
 * If resorting the {@link SamRecord}s, temp data
 * will be written to a temp directory.
 * By default, the system's temp directory is used but that can be changed
 * by using the {@link #setTempRootDir(File)} method.
 * 
 * @author dkatzel
 *
 */
public final class SamFileWriterBuilder {

	
	private static final int DEFAULT_RECORDS_IN_MEMORY = 2_000_000;
	
	private final File outputFile;
	private final SamHeaderBuilder headerBuilder;
<span class="fc" id="L53">	private SamAttributeValidator attributeValidator = ReservedAttributeValidator.INSTANCE;</span>
	
<span class="fc" id="L55">	private File tmpDirRoot = null; //default to systemp temp</span>
	
<span class="fc" id="L57">	private SortOrder reSortOrder = null;</span>
	
<span class="fc" id="L59">	private int maxRecordsToKeepInMemory = DEFAULT_RECORDS_IN_MEMORY;</span>
	
<span class="fc" id="L61">	private boolean makeBamIndex=false;</span>
	
<span class="fc" id="L63">	private boolean includeIndexMetadata=false;</span>
	
	/**
	 * Get the max number of {@link SamRecord}s
	 * to keep in memory at any one time if
	 * re-sorting on the fly. 
	 * @return an int will always be &gt;=0.
	 */
	public static int getDefaultRecordsToKeepInMemory() {
<span class="nc" id="L72">		return DEFAULT_RECORDS_IN_MEMORY;</span>
	}
	/**
	 * Create a new {@link SamFileWriterBuilder} instance
	 * that will write out {@link SamRecord}s
	 * to the given output file.  The file encoding
	 * to use is determined by the file extension of the output file.
	 * @param outputFile the output file to write to;
	 * can not be null.
	 * the File extension must be either &quot;.sam&quot; or &quot;.bam&quot;.
	 * @param header the {@link SamHeader}; can not be null.
	 * The sort order in the header 
	 * may be overridden by {@link #reSortBy(SortOrder)}
	 * or {@link #reSortBy(SortOrder, int)} or {@link #forceHeaderSortOrder(SortOrder)}.
	 * @throws NullPointerException if either parameter is null.
	 */
<span class="fc" id="L88">	public SamFileWriterBuilder(File outputFile, SamHeader header){</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">		if(outputFile == null){</span>
<span class="nc" id="L90">			throw new NullPointerException(&quot;output file can not be null&quot;);</span>
		}
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">		if(header ==null){</span>
<span class="nc" id="L93">			throw new NullPointerException(&quot;headerBuilder can not be null&quot;);</span>
		}
		
<span class="fc" id="L96">		this.outputFile = outputFile;</span>
<span class="fc" id="L97">		this.headerBuilder = new SamHeaderBuilder(header);</span>
<span class="fc" id="L98">	}</span>
	/**
	 * Change the temp directory to write
	 * re-sorted temp data to when writing out the 
	 * SAM or BAM file.  If this method is not called,
	 * then the default system temp directory is used.
	 * 
	 * @param tmpDir the temp directory to use;
	 * if null, then use the default system temp directory.
	 * If this temp directory does not exist, it will be created
	 * if used.
	 * @return this.
	 */
	public SamFileWriterBuilder setTempRootDir(File tmpDir){
<span class="fc" id="L112">		this.tmpDirRoot = tmpDir;</span>
<span class="fc" id="L113">		return this;</span>
	}
	/**
	 * Set a {@link SamAttributeValidator} to use
	 * to confirm that the {@link SamRecord}s given to the writer
	 * are valid for this {@link SamHeader}.
	 * If not provided, then a default validator
	 * that only knows about ReservedSamAttributeKeys
	 * will be used.
	 * @param validator the validator to use; can not be null.
	 * @return this
	 * @throws NullPointerException if validator is null.
	 */
	public SamFileWriterBuilder setSamAttributeValidator(SamAttributeValidator validator){
<span class="nc bnc" id="L127" title="All 2 branches missed.">		if(validator ==null){</span>
<span class="nc" id="L128">			throw new NullPointerException(&quot;validator can not be null&quot;);</span>
		}
<span class="nc" id="L130">		this.attributeValidator = validator;</span>
<span class="nc" id="L131">		return this;</span>
	}
	/**
	 * Should a corresponding BAM Index file also be created ({@code false} by default). 
	 * Convenience method for {@link #createBamIndex(boolean, boolean) createBamIndex(createBamIndex, false)}.
	 *  &lt;p&gt;
	 * &lt;strong&gt;
	 * If the Bam file should make an index and the {@link SortOrder} is not set to
	 * {@link SortOrder#COORDINATE} by the time {@link #build()} is called,
	 * then {@link #build()} will throw an {@link IllegalStateException}.
	 * &lt;/strong&gt;
	 * The exception throw is delayed until as late as possible so that you can
	 * later call either {@link #reSortBy(SortOrder)} or {@link #forceHeaderSortOrder(SortOrder)}
	 * to specify {@link SortOrder#COORDINATE} sorting after calling this method.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * If {@code createBamIndex} is true,
	 * AND the file to be written is a BAM file AND the sort order is {@link SortOrder#COORDINATE},
	 * then an additional file named &quot;$outputFile#getName.bam.bai&quot; will also be created in the same directory
	 * as the outputFile.
	 * &lt;/p&gt;  
	 * &lt;p&gt;
	 * So for example, if the outputFile was &lt;code&gt;myOutput.bam&lt;/code&gt;
	 * then the index file to be written will be named &lt;code&gt;myOutput.bam.bai&lt;/code&gt;.
	 *  If this method is not called, then by default, the metadata is not included.
	 *&lt;/p&gt;
	 *@param createBamIndex should a BAM index be created? {@code true} if it should; {@code false}
	 *otherwise.
	 * @return this.
	 * 
	 * @see #createBamIndex(boolean, boolean)
	 */
	public SamFileWriterBuilder createBamIndex(boolean createBamIndex){
<span class="nc" id="L165">		return createBamIndex(createBamIndex, false);</span>
	}
	/**
	 * Should a corresponding BAM Index file also be created ({@code false} by default).  If {@code createBamIndex} is true,
	 * AND the file to be written is a BAM file AND the sort order is {@link SortOrder#COORDINATE},
	 * then an additional file named &quot;$outputFile#getName.bam.bai&quot; will also be created in the same directory
	 * as the outputFile.  
	 * 
	 * &lt;p&gt;
	 * &lt;strong&gt;
	 * If the Bam file should make an index and the {@link SortOrder} is not set to
	 * {@link SortOrder#COORDINATE} by the time {@link #build()} is called,
	 * then {@link #build()} will throw an {@link IllegalStateException}.
	 * &lt;/strong&gt;
	 * The exception throw is delayed until as late as possible so that you can
	 * later call either {@link #reSortBy(SortOrder)} or {@link #forceHeaderSortOrder(SortOrder)}
	 * to specify {@link SortOrder#COORDINATE} sorting after calling this method.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * So for example, if the outputFile was &lt;code&gt;myOutput.bam&lt;/code&gt;
	 * then the index file to be written will be named &lt;code&gt;myOutput.bam.bai&lt;/code&gt;.
	 *  If this method is not called, then by default, the metadata is not included.
	 *&lt;/p&gt;
	 *@param createBamIndex should a BAM index be created? {@code true} if it should; {@code false}
	 *otherwise.
	 *
	 *
	 * @param includeMetadata Some BAM indexes created by some other SAM libraries such as samtools and picard
	 * add additional
	 * metadata to the index such as the number of unaligned reads. This metadata
	 * is not specified in the BAM Index specification so some SAM parsers might not be able to correctly
	 * handle them. If this parameter is set to {@code true} if metadata should be included;
	 * {@code false} otherwise (the default).
	 * 
	 * @return this.
	 */
	public SamFileWriterBuilder createBamIndex(boolean createBamIndex, boolean includeMetadata){
<span class="fc" id="L202">		this.makeBamIndex = createBamIndex;</span>
<span class="fc" id="L203">		this.includeIndexMetadata = includeMetadata;</span>
<span class="fc" id="L204">		return this;</span>
	}
	/**
	 * Convenience method to resort 
	 * using the default number of records to get in memory
	 * specified by {@link #getDefaultRecordsToKeepInMemory()}.
	 * Same as {@link #reSortBy(SortOrder, int) reSortBy(sortOrder, getDefaultRecordsToKeepInMemory()}
	 * 
	 * @param sortOrder the {@link SortOrder} to use;
	 * can not be null.
	 * @return this.
	 * @see #reSortBy(SortOrder, int)
	 */
	public SamFileWriterBuilder reSortBy(SortOrder sortOrder){
<span class="fc" id="L218">		return reSortBy(sortOrder, DEFAULT_RECORDS_IN_MEMORY);</span>
	}
	/**
	 * Resort the {@link SamRecord}s written by this
	 * writer on the fly.  This will also modify
	 * the SAM/BAM header written out
	 * to specify the correct sort order.
	 * NOTE: Setting {@link SortOrder#UNKNOWN}
	 * or {@link SortOrder#UNSORTED}
	 * will not cause a re-sort on the fly
	 * but the header written will still be modified.
	 * @param sortOrder the {@link SortOrder} to use;
	 * can not be null.
	 * @param maxRecordsToKeepInMemory the number of SamRecords
	 * to keep in memory; must be &gt;0.
	 * @return this.
	 * @throws NullPointerException if sortOrder is not specified.
	 * @throws IllegalArgumentException if maxRecordsToKeepInMemory &lt; 1.
	 */
	public SamFileWriterBuilder reSortBy(SortOrder sortOrder, int maxRecordsToKeepInMemory){
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">		if(sortOrder ==null){</span>
<span class="nc" id="L239">			throw new NullPointerException(&quot;sort order can not be null&quot;);</span>
		}
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">		if(maxRecordsToKeepInMemory &lt; 1){</span>
<span class="nc" id="L242">			throw new IllegalArgumentException(&quot;max records to keep in memory must be positive&quot;);</span>
		}
		
<span class="fc" id="L245">		forceHeaderSortOrder(sortOrder);</span>
<span class="fc" id="L246">		this.reSortOrder = sortOrder;</span>
<span class="fc" id="L247">		this.maxRecordsToKeepInMemory = maxRecordsToKeepInMemory;</span>
<span class="fc" id="L248">		return this;</span>
	}
	/**
	 * Change the sort order specified in the written
	 * out header but do not actually re-sort the records on the fly.
	 * This method should be used with care and should only be used
	 * if the records are already known to be sorted
	 * but for some reason the provided header has the wrong
	 * sort order.
	 * @param sortOrder the sort order to use; if null,
	 * then the sort order will be set to {@link SortOrder#UNKNOWN}.
	 * @return this.
	 */
	public SamFileWriterBuilder forceHeaderSortOrder(SortOrder sortOrder){
<span class="fc" id="L262">		headerBuilder.setSortOrder(sortOrder);</span>
<span class="fc" id="L263">		return this;</span>
	}
	/**
	 * Create a new {@link SamWriter} instance
	 * using the provided configuration.
	 * @return a new {@link SamWriter} will never be null.
	 * @throws IOException if there is a problem creating
	 * the output directories or temp areas.
	 * 
	 * @throws IllegalStateException if the bam file to be written
	 * should also make an index file, but the sort order
	 * is not {@link SortOrder#COORDINATE} which is required
	 * by index files.
	 */
	public SamWriter build() throws IOException{
<span class="fc" id="L278">		SamHeader header = headerBuilder.build();</span>
<span class="fc" id="L279">		Encoding encoding = Encoding.parseEncoding(FileUtil.getExtension(outputFile));</span>
		BamIndexer indexer;
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">		if(makeBamIndex &amp;&amp; encoding== Encoding.BAM){</span>
			//check sort order in new header
			//which will be the sort order we use
			//regardless if we are re-sorting or not.
			//
			//BAM indexes must be applied to 
			//coordinate sorted bam files
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">			if(header.getSortOrder() != SortOrder.COORDINATE){</span>
<span class="nc" id="L289">				throw new IllegalStateException(&quot;can not make bam index when bam file to be written is not coordinate sorted&quot;);</span>
			}
<span class="fc" id="L291">			indexer = new BamIndexer(header);</span>
		}else{
<span class="fc" id="L293">			indexer =null;</span>
		}
<span class="fc bfc" id="L295" title="All 2 branches covered.">		if(writeUnSortedRecords()){</span>
<span class="fc" id="L296">			return encoding.createPreSortedNoValidationOutputWriter(outputFile, header, indexer,includeIndexMetadata);</span>
		}
<span class="fc" id="L298">		return encoding.createReSortedOutputWriter(outputFile, tmpDirRoot, header, maxRecordsToKeepInMemory, attributeValidator, indexer, includeIndexMetadata);</span>
		
	}

	private boolean writeUnSortedRecords() {
<span class="fc bfc" id="L303" title="All 6 branches covered.">		return reSortOrder ==null || reSortOrder == SortOrder.UNKNOWN || reSortOrder == SortOrder.UNSORTED;</span>
	}

	
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>