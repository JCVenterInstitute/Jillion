<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SortOrder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">SortOrder.java</span></div><h1>SortOrder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamReferenceSequence;

/**
 * Sorting Order of alignments in a SAM/BAM file.
 * @author dkatzel
 *
 */
<span class="pc" id="L40">public enum SortOrder{</span>
	/**
	 * Sort order is unknown.
	 * This is the default if no sort order is specified.
	 */
<span class="fc" id="L45">	UNKNOWN,</span>
<span class="fc" id="L46">	UNSORTED,</span>
	/**
	 * Order by query name (read name).
	 */
<span class="fc" id="L50">	QUERY_NAME{</span>

		@Override
		public Comparator&lt;SamRecord&gt; createComparator(SamHeader header) {
<span class="fc" id="L54">			return QUERY_NAME_COMPARATOR;</span>
		}
		
	},
	/**
	 * The major sort key is the Reference Name,
	 * with the order defined by the order of the
	 * References defined in the sequence dictionary. 
	 * And the minor sort key is the {@link org.jcvi.jillion.sam.SamRecord#getStartPosition()}
	 * field.
	 * Alignments with the same reference and start offset,
	 * the order is arbitrary.
	 * All alignments that do not map to a reference follow
	 * alignments with some other value but otherwise are in arbitrary order.
	 */
<span class="fc" id="L69">	COORDINATE{</span>

		@Override
		public Comparator&lt;SamRecord&gt; createComparator(SamHeader header) {
<span class="fc" id="L73">			return new CoordinateComparator(header);</span>
		}
		
	};
	/**
	 * The Mapping of String names to our
	 * {@link SortOrder} objects used when parsing 
	 * SAM files.  Have to use a map because
	 * Jillion enum names don't match 100% to names used 
	 * in SAM format.
	 */
	private static final Map&lt;String, SortOrder&gt; NAME_MAP;
	
	/**
	 * {@link Comparator} used by {@link SortOrder#QUERY_NAME}.
	 */
<span class="fc" id="L89">	private static final Comparator&lt;SamRecord&gt; QUERY_NAME_COMPARATOR = new Comparator&lt;SamRecord&gt;(){</span>

		@Override
		public int compare(SamRecord o1, SamRecord o2) {
			//nulls always go last
<span class="fc bfc" id="L94" title="All 2 branches covered.">			if (o1 == null) {</span>
<span class="fc" id="L95">                return 1;</span>
            }
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (o2 == null) {</span>
<span class="nc" id="L98">                return -1;</span>
            }
<span class="fc" id="L100">			return o1.getQueryName().compareTo(o2.getQueryName());</span>
		}
		
	};
	
	static{
<span class="fc" id="L106">		NAME_MAP = new HashMap&lt;String, SortOrder&gt;();</span>
		
<span class="fc bfc" id="L108" title="All 2 branches covered.">		for(SortOrder s : values()){</span>
<span class="fc" id="L109">			NAME_MAP.put(s.getEncodedName(), s);</span>
		}
<span class="fc" id="L111">	}</span>
	private final String encodedName;
	
<span class="fc" id="L114">	private SortOrder(){</span>
<span class="fc" id="L115">		encodedName = name().replaceAll(&quot;_&quot;, &quot;&quot;).toLowerCase(Locale.US);</span>
<span class="fc" id="L116">	}</span>
	
	/**
	 * Get the name of this SortOrder
	 * that is encoded in SAM and BAM header text.
	 * @return the name as a String,
	 * and may be different than {@link #name()}.
	 */
	public String getEncodedName() {
<span class="fc" id="L125">		return encodedName;</span>
	}


	/**
	 * Parse the {@link SortOrder} from the given sort order name. current
	 * accepted values are:
	 * &lt;ul&gt;
	 * &lt;li&gt;unknown&lt;/li&gt;
	 * &lt;li&gt;unsorted&lt;/li&gt;
	 * &lt;li&gt;queryname&lt;/li&gt;
	 * &lt;li&gt;coordinate&lt;/li&gt;
	 * &lt;/ul&gt;
	 * All other values will return null.
	 * @param sortOrder the sortOrder name to check.
	 * @return the {@link SortOrder} type if the sortOrder
	 * String EXACTLY matches the value list described above;
	 * otherwise {@code null}.
	 */
	public static SortOrder parseSortOrder(String sortOrder){
<span class="fc" id="L145">		return NAME_MAP.get(sortOrder);</span>
	}
	/**
	 * Get the {@link Comparator} for this {@link SortOrder}
	 * which may be null if SortOrder is {@link SortOrder#UNKNOWN}
	 * or {@link SortOrder#UNSORTED}.
	 * Depending on the type, the returned Comparator may be
	 * a new object or a pointer to a pre-existing object.
	 * @return a {@link Comparator} or {@code null}
	 * if no comparator specified.
	 */
	public Comparator&lt;SamRecord&gt; createComparator(SamHeader header){
		//by default return null
		//let types override to return actual
		//comparator implementation.
<span class="fc" id="L160">		return null;</span>
	}
	/**
	 * {@code CoordinateComparator}
	 * is a class that implements the sort rules
	 * required for {@link SortOrder#COORDINATE}.
	 * &lt;p&gt;
	 * Algorithm: Sort by reference order specified in
	 * {@link SamHeader#getReferenceSequences()}
	 * then by start position.  Unmapped records
	 * sort after mapped records.
	 * 
	 * The SAM file spec says that records that either have the same
	 * reference and start position or records that are unmapped are
	 * in an arbitrary order, but we will try to sort them by 
	 * query name.
	 * &lt;/p&gt;
	 * @author dkatzel
	 *
	 */
	private static final class CoordinateComparator implements Comparator&lt;SamRecord&gt;, Serializable{

		private static final long serialVersionUID = -4315866144598924346L;
		
		private final List&lt;String&gt; referenceNames;
		
<span class="fc" id="L186">		public CoordinateComparator(SamHeader header){</span>
<span class="fc" id="L187">			Collection&lt;SamReferenceSequence&gt; refs = header.getReferenceSequences();</span>
<span class="fc" id="L188">			referenceNames = new ArrayList&lt;String&gt;(refs.size());</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">			for(SamReferenceSequence ref : refs){</span>
<span class="fc" id="L190">				referenceNames.add(ref.getName());</span>
<span class="fc" id="L191">			}</span>
<span class="fc" id="L192">		}</span>
		@Override
		public int compare(SamRecord o1, SamRecord o2) {
			//nulls always go last
<span class="fc bfc" id="L196" title="All 2 branches covered.">			if (o1 == null) {</span>
<span class="fc" id="L197">                return 1;</span>
            }
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            if (o2 == null) {</span>
<span class="nc" id="L200">                return -1;</span>
            }
			//sort by reference then by start position
			//if the read didn't map, then the alignments
			//go last
			//according to the SAM spec and those reads
			//are in &quot;arbitrary order&quot;
			//which means we can do whatever we want
			//therefore will sort by qname
			
<span class="fc bfc" id="L210" title="All 2 branches covered.">			boolean ref1DidNotMap = !o1.mapped();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			boolean ref2DidNotMap = !o2.mapped();</span>
			
<span class="fc bfc" id="L213" title="All 4 branches covered.">			if(ref1DidNotMap &amp;&amp; ref2DidNotMap){</span>
				//according to the SAM spec and those reads
				//that don't map are sorted in
				//&quot;arbitrary order&quot;
				//which means we can do whatever we want
				//therefore will sort by qname
<span class="fc" id="L219">				return o1.getQueryName().compareTo(o2.getQueryName());</span>
			}
			//unmapped reads go last
<span class="fc bfc" id="L222" title="All 2 branches covered.">			if(ref1DidNotMap){</span>
				//read 1 therefore will always be 
				//after read 2
<span class="fc" id="L225">				return 1;</span>
			}
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if(ref2DidNotMap){</span>
				//read 2 therefore will always be 
				//after read 1
<span class="fc" id="L230">				return -1;</span>
			}
			//if we get this far,
			//then both reads mapped somewhere
<span class="fc" id="L234">			String ref1 =o1.getReferenceName();</span>
<span class="fc" id="L235">			String ref2 =o2.getReferenceName();</span>
			
<span class="fc bfc" id="L237" title="All 2 branches covered.">			if(!ref1.equals(ref2)){</span>
<span class="fc" id="L238">				int index1 =referenceNames.indexOf(ref1);</span>
<span class="fc" id="L239">				int index2 =referenceNames.indexOf(ref2);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">				if(index1 &lt; index2){</span>
<span class="fc" id="L241">					return -1;</span>
				}
<span class="fc" id="L243">				return 1;</span>
			}
			//same reference order by start position
<span class="fc" id="L246">			int startComp = compare(o1.getStartPosition(), o2.getStartPosition());</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">			if(startComp != 0){</span>
<span class="fc" id="L248">				return startComp;</span>
			}
			//according to the SAM spec and those reads
			//that don't map are sorted in
			//&quot;arbitrary order&quot;
			//which means we can do whatever we want
			//therefore will sort by qname
<span class="fc" id="L255">			return o1.getQueryName().compareTo(o2.getQueryName());</span>
		}
			
		private static int  compare(int x, int y) {
			//taken from Java 7's compare since
			//it's not in Java 6
<span class="fc bfc" id="L261" title="All 4 branches covered.">			return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>