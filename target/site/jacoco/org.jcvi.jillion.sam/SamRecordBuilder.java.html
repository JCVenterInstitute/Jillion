<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SamRecordBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">SamRecordBuilder.java</span></div><h1>SamRecordBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.sam.attribute.InvalidAttributeException;
import org.jcvi.jillion.sam.attribute.ReservedAttributeValidator;
import org.jcvi.jillion.sam.attribute.ReservedSamAttributeKeys;
import org.jcvi.jillion.sam.attribute.SamAttribute;
import org.jcvi.jillion.sam.attribute.SamAttributeKey;
import org.jcvi.jillion.sam.attribute.SamAttributeValidator;
import org.jcvi.jillion.sam.cigar.Cigar;
import org.jcvi.jillion.sam.cigar.Cigar.ClipType;
import org.jcvi.jillion.sam.header.SamHeader;

/**
 * Builder object to build new instances
 * of {@link SamRecord}s.
 * 
 * @author dkatzel
 *
 */
public class SamRecordBuilder implements SamAttributed{
	
	
	final SamHeader header;
	private final SamAttributeValidator attributeValidator;
	
<span class="fc" id="L52">	final Map&lt;SamAttributeKey, SamAttribute&gt; attributes = new LinkedHashMap&lt;SamAttributeKey, SamAttribute&gt;();</span>
	
<span class="fc" id="L54">	String queryName= SamRecord.UNAVAILABLE;</span>
<span class="fc" id="L55">	String referenceName = null;</span>
<span class="fc" id="L56">	String nextReferenceName = null;</span>
	SamRecordFlags flags;
<span class="fc" id="L58">	int startPosition =0;</span>
<span class="fc" id="L59">	int nextPosition= 0;</span>
<span class="fc" id="L60">	byte mappingQuality= -1;</span>
	Cigar cigar;
	NucleotideSequence sequence;
	QualitySequence qualities;
	
<span class="fc" id="L65">	int observedTemplateLength = 0;</span>
	/**
	 * Create an new Builder object for a SamRecord
	 * that will use the given {@link SamHeader}.
	 * The reference(s) this record maps to as well
	 * as any read groups or custom tags referred to by this record
	 * must be defined by this header.
	 * 
	 * @param header The {@link SamHeader} to use; can not be null.
	 * 
	 * @throws NullPointerException if header is null.
	 */
	public SamRecordBuilder(SamHeader header){
<span class="fc" id="L78">		this(header, ReservedAttributeValidator.INSTANCE);</span>
<span class="fc" id="L79">	}</span>
	/**
	 * Create an new Builder object for a SamRecord
	 * that will use the given {@link SamHeader} and the given
	 * {@link SamAttributeValidator}.
	 * The reference(s) this record maps to as well
	 * as any read groups or custom tags referred to by this record
	 * must be defined by this header.
	 * 
	 * @param header The {@link SamHeader} to use; can not be null.
	 * 
	 * @throws NullPointerException if header is null.
	 */
<span class="fc" id="L92">	public SamRecordBuilder(SamHeader header, SamAttributeValidator attributeValidator){</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">		if(header ==null){</span>
<span class="nc" id="L94">			throw new NullPointerException(&quot;header can not be null&quot;);</span>
		}
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">		if(attributeValidator ==null){</span>
<span class="nc" id="L97">			throw new NullPointerException(&quot;attribute Validator can not be null&quot;);</span>
		}
<span class="fc" id="L99">		this.header = header;</span>
<span class="fc" id="L100">		this.attributeValidator = attributeValidator;</span>
<span class="fc" id="L101">	}</span>
	/**
	 * Add the given attribute to this record.
	 * @param attribute the attribute to add;
	 * can not be null.
	 * @return this
	 * @throws NullPointerException if attribute is null.
	 * @throws InvalidAttributeException if the attribute fails the given {@link SamAttributeValidator}.
	 * @see #removeAttribute(SamAttributeKey)
	 */
	public SamRecordBuilder addAttribute(SamAttribute attribute) throws InvalidAttributeException{
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">		if(attribute ==null){</span>
<span class="nc" id="L113">			throw new NullPointerException(&quot;attribute can not be null&quot;);</span>
		}
<span class="fc" id="L115">		SamAttributeKey key = attribute.getKey();</span>
		/*
		if(attributes.containsKey(key)){
			throw new InvalidAttributeException(&quot;attribute with key already exists &quot; + key);
		}
		*/
<span class="fc" id="L121">		attributeValidator.validate(header, this, attribute);</span>
<span class="fc" id="L122">		attributes.put(key, attribute);</span>
<span class="fc" id="L123">		return this;</span>
	}
	
	
	/**
	 * Remove the attribute with the given
	 * {@link SamAttributeKey}.
	 * If this record does not have
	 * an attribute with the attribute key,
	 * then this method does nothing.
	 * 
	 * @param attributeKey the key to remove;
	 * can not be null.
	 * @return this.
	 * @throws NullPointerException if attributeKey is null.
	 */
	public SamRecordBuilder removeAttribute(SamAttributeKey attributeKey){
<span class="nc bnc" id="L140" title="All 2 branches missed.">		if(attributeKey ==null){</span>
<span class="nc" id="L141">			throw new NullPointerException(&quot;attribute key can not be null&quot;);</span>
		}
<span class="nc" id="L143">		attributes.remove(attributeKey);</span>
<span class="nc" id="L144">		return this;</span>
	}
	/**
	 * Sets the query template name.
	 * Reads/segments having identical query name
	 * are regarded to come from the same template.
	 * If this method is not called,
	 * then the query name will be set to 
	 * {@link SamRecord#UNAVAILABLE}.
	 * 
	 * @param queryName the query name to use;
	 * can not be null.
	 * @return this.
	 * @throws NullPointerException if queryName is null.
	 */
	public SamRecordBuilder setQueryName(String queryName) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">		if(queryName ==null){</span>
<span class="nc" id="L161">			throw new NullPointerException(&quot;query name can not be null&quot;);</span>
		}
<span class="fc" id="L163">		this.queryName = queryName;</span>
<span class="fc" id="L164">		return this;</span>
	}
	/**
	 * Set the reference name that this segment
	 * aligns to.  If this field is not set to
	 * {@link SamRecord#UNAVAILABLE}, then the reference
	 * {@link SamHeader#getReferenceSequence(String)}
	 * must return a non-null value.
	 * 
	 * If this method is not called, then the value will default
	 * to null.
	 * @param referenceName the reference name this segment aligns;
	 * can not be null and must either be {@link SamRecord#UNAVAILABLE}
	 * or a reference sequence name that is in the provided {@link SamHeader}.
	 * @return this.
	 * @throws NullPointerException if referenceName is null.
	 * @throws IllegalArgumentException if referenceName is not 
	 *  {@link SamRecord#UNAVAILABLE}
	 * and is not in the provided {@link SamHeader}.
	 */
	public SamRecordBuilder setReferenceName(String referenceName) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if(referenceName ==null){</span>
<span class="nc" id="L186">			throw new NullPointerException(&quot;reference name can not be null&quot;);</span>
		}
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		if(SamRecord.UNAVAILABLE.equals(referenceName)){</span>
<span class="nc" id="L189">			this.referenceName = null;</span>
		}else{
<span class="fc" id="L191">			assertHeaderKnowsAboutReference(referenceName);</span>
<span class="fc" id="L192">			this.referenceName = referenceName;</span>
		}
		
<span class="fc" id="L195">		return this;</span>
	}
	private void assertHeaderKnowsAboutReference(String referenceName) {
		//RNAME must be present in a SQ-SN tag
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">		if(header.getReferenceSequence(referenceName)==null){</span>
<span class="nc" id="L200">			throw new IllegalArgumentException(&quot;reference name is not in sam header '&quot;+ referenceName+&quot;'&quot;);</span>
		}
<span class="fc" id="L202">	}</span>
	/**
	 * Set the reference sequence name of the primary alignment
	 * of the NEXT read in the template.
	 * If nextReferenceName is not {@link SamRecord#UNAVAILABLE}
	 * or {@link SamRecord#IDENTICAL} then the reference
	 * {@link SamHeader#getReferenceSequence(String)}
	 * must return a non-null value. 
	 * 
	 * If nextReferenceName is not  {@link SamRecord#IDENTICAL}
	 * and the next read in the template {@link SamRecord#isPrimary()}, then this field is
	 * identical to {@link SamRecord#getReferenceName()} of the next read.
	 * @param nextReferenceName the next reference name;
	 * can not be null.
	 * @returns this
	 * @throws NullPointerException if reference name is null.
	 * @throws  IllegalArgumentException if referenceName is not 
	 *  {@link SamRecord#UNAVAILABLE} or {@link SamRecord#IDENTICAL}
	 * and is not in the provided {@link SamHeader}.
	 */
	public SamRecordBuilder setNextReferenceName(String nextReferenceName) {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">		if(nextReferenceName ==null){</span>
<span class="nc" id="L224">			throw new NullPointerException(&quot;next reference name can not be null&quot;);</span>
		}
<span class="fc bfc" id="L226" title="All 2 branches covered.">		if(nextReferenceName.equals(SamRecord.UNAVAILABLE)){</span>
<span class="fc" id="L227">			this.nextReferenceName = null;</span>
		}else{
<span class="pc bpc" id="L229" title="1 of 4 branches missed.">			if(!nextReferenceName.equals(SamRecord.UNAVAILABLE) &amp;&amp; !nextReferenceName.equals(SamRecord.IDENTICAL)){</span>
<span class="fc" id="L230">				assertHeaderKnowsAboutReference(nextReferenceName);</span>
			}
<span class="fc" id="L232">			this.nextReferenceName = nextReferenceName;</span>
		}
<span class="fc" id="L234">		return this;</span>
	}
	/**
         * Set the {@link SamRecordFlags} of this 
         * record This method call is required.  This method call makes a defensive copy
         * of the input Set.
         * @param flags the {@link SamRecordFlags} relevant
         * to this record; can not be null.
         * @return this;
         * @throws NullPointerException if flags is null.
         */
        public SamRecordBuilder setFlags(int flags) {
<span class="fc" id="L246">            this.flags = SamRecordFlags.valueOf(flags);</span>
<span class="fc" id="L247">            return this;</span>
        }
	/**
	 * Set the {@link SamRecordFlags} of this 
	 * record This method call is required.  This method call makes a defensive copy
	 * of the input Set.
	 * @param flags the {@link SamRecordFlags} relevant
	 * to this record; can not be null.
	 * @return this;
	 * @throws NullPointerException if flags is null.
	 */
	public SamRecordBuilder setFlags(Set&lt;SamRecordFlag&gt; flags) {
		//make defensive copy
<span class="fc" id="L260">		this.flags = SamRecordFlags.valueOf(flags);</span>
<span class="fc" id="L261">		return this;</span>
	}
	/**
	 * Set the start position on the reference (1-based) of the first
	 * matching base of this segment.  The first valid start position
	 * is therefore 1, a value of 0 means the segment did not map.
	 * @param startPosition the start position; must be &gt;=0.
	 * If this method is not called, then the default start position
	 * of 0 is used.
	 * @return this
	 * @throws IllegalArgumentException if startPosition is &lt;0.
	 */
	public SamRecordBuilder setStartPosition(int startPosition) {
<span class="fc" id="L274">		assertValidPosition(startPosition);</span>
<span class="fc" id="L275">		this.startPosition = startPosition;</span>
<span class="fc" id="L276">		return this;</span>
	}
	private void assertValidPosition(int startPosition) {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">		if(startPosition &lt;0){</span>
<span class="nc" id="L280">			throw new IllegalArgumentException(&quot;position must be &gt;=0 &quot;);</span>
		}
<span class="fc" id="L282">	}</span>
	/**
	 * Set the start position on the reference (1-based) of the 
	 * matching base of the NEXT
	 * read in the template.
	 * This value should match the {@link SamRecord#getStartPosition()}
	 * of the primary line of the next read.
	 * @param nextPosition the start position; must be &gt;=0.
	 * If this method is not called, then the default nextPosition
	 * of 0 is used.
	 * @return this
	 * @throws IllegalArgumentException if startPosition is &lt;0.
	 */
	public SamRecordBuilder setNextPosition(int nextPosition) {
<span class="fc" id="L296">		assertValidPosition(nextPosition);</span>
<span class="fc" id="L297">		this.nextPosition = nextPosition;</span>
<span class="fc" id="L298">		return this;</span>
	}
	/**
	 * Convenience method to set mapping
	 * quality as an int instead of a byte.
	 * Otherwise same as {@link #setMappingQuality(byte)}.
	 * @throws IllegalArgumentException if mappingQuality is out of 
	 * byte range.
	 */
	public SamRecordBuilder setMappingQuality(int mappingQuality) {
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">		if(mappingQuality&gt;Byte.MAX_VALUE){</span>
<span class="nc" id="L309">			throw new IllegalArgumentException(&quot;invalid mapping quality &quot; + mappingQuality);</span>
		}
<span class="fc" id="L311">		return setMappingQuality((byte)mappingQuality);</span>
		
	}
	/**
	 * The mapping quality.  It equals
	 * -10 log&lt;sub&gt;10&lt;/sub&gt; Prob{mapping position is wrong}
	 * rounded to the nearest integer.  If set to -1, then 
	 * the mapping is unavailable. Valid values are -1.. {@link Byte#MAX_VALUE}.
	 * If this method is not called, then the default value of -1 will be used.
	 * @param mappingQuality the mapping quality to set; must be &gt;= -1.
	 * @throws IllegalArgumentException if mapping quality &lt; -1.
	 * @return this
	 */
	public SamRecordBuilder setMappingQuality(byte mappingQuality) {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">		if(mappingQuality &lt; -1){</span>
<span class="nc" id="L326">			throw new IllegalArgumentException(&quot;invalid mapping quality &quot; + mappingQuality);</span>
		}
<span class="fc" id="L328">		this.mappingQuality = mappingQuality;</span>
<span class="fc" id="L329">		return this;</span>
	}
	/**
	 * Sets the {@link Cigar} value. If the {@link Cigar}
	 * is not available, then this value should be set to null.
	 * @param cigar the {@link Cigar}; or null.
	 * @return this.
	 */
	public SamRecordBuilder setCigar(Cigar cigar) {
<span class="fc" id="L338">		this.cigar = cigar;</span>
<span class="fc" id="L339">		return this;</span>
	}
	/**
	 * The segment {@link NucleotideSequence}.  If the sequence is not stored,
	 * then this value should be null.
	 * If this sequence exists, then the sequence length
	 * must equal the length of the {@link Cigar}.
	 * @param sequence the sequence, may be null.
	 * @return this.
	 */
	public SamRecordBuilder setSequence(NucleotideSequence sequence) {
<span class="fc" id="L350">		this.sequence = sequence;</span>
<span class="fc" id="L351">		return this;</span>
	}
	/**
	 * The {@link QualitySequence} of this segment.
	 * If the qualities are not stored, then this value
	 * should be null.  If not null,
	 * then then this segment's {@link NucleotideSequence}
	 * must also not be null and have an equal length.
	 * @param qualities the {@link QualitySequence} for this record; may be null
	 * if the qualities are not known.
	 * 
	 * @see #setSequence(NucleotideSequence)
	 * @return this.
	 */
	public SamRecordBuilder setQualities(QualitySequence qualities) {
<span class="fc" id="L366">		this.qualities = qualities;</span>
<span class="fc" id="L367">		return this;</span>
	}

	/**
	 * Signed observed template length. If all segments are mapped to the
	 * same reference, the unsigned observed template length equals the
	 * number of bases from the leftmost mapped base to the rightmost mapped
	 * base. The leftmost segment has a plus sign and the rightmost has a
	 * minus sign. The sign of segments in the middle is undefined. It is
	 * set as 0 for single-segment template or when the information is
	 * unavailable. If this method is not called, then the default value is
	 * 0.
	 * 
	 * @param observedTemplateLength the observed template length.
	 * @return this.
	 */
	public SamRecordBuilder setObservedTemplateLength(int observedTemplateLength) {
<span class="fc" id="L384">		this.observedTemplateLength = observedTemplateLength;</span>
<span class="fc" id="L385">		return this;</span>
	}
	
	
	public SamRecord build(){
<span class="fc" id="L390">		assertSequenceLengthsCorrect();</span>
		//flags must be set
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">		if(flags ==null){</span>
<span class="nc" id="L393">			throw new IllegalStateException(&quot;flags must be set&quot;);</span>
		}
<span class="fc bfc" id="L395" title="All 2 branches covered.">		if(SamRecord.IDENTICAL.equals(nextReferenceName)){</span>
<span class="fc" id="L396">			nextReferenceName = referenceName;</span>
		}
		//TODO force unmapped read to have mapping quality of 0?
		
<span class="fc" id="L400">		return new SamRecordImpl(this);</span>
	}
	private void assertSequenceLengthsCorrect() {
<span class="fc bfc" id="L403" title="All 2 branches covered.">		if(qualities !=null){</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">			if(sequence ==null){</span>
<span class="nc" id="L405">				throw new IllegalStateException(&quot;sequence must be set if qualities are set&quot;);</span>
			}
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">			if(sequence.getLength() !=qualities.getLength()){</span>
<span class="nc" id="L408">				throw new IllegalStateException(&quot;sequence and qualities must have same length&quot;);</span>
			}
		}
<span class="fc bfc" id="L411" title="All 4 branches covered.">		if(sequence !=null &amp;&amp; cigar !=null</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">			&amp;&amp; sequence.getUngappedLength() != cigar.getUnpaddedReadLength(ClipType.HARD_CLIPPED)){</span>
			
<span class="nc" id="L414">			throw new IllegalStateException(&quot;sequence and cigar must have same unpadded/ ungapped read length&quot;);</span>
			
		}
		
<span class="fc" id="L418">	}</span>
	@Override
	public boolean hasAttribute(SamAttributeKey key){
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">		if(key==null){</span>
<span class="nc" id="L422">			throw new NullPointerException(&quot;key can not be null&quot;);</span>
		}
<span class="fc" id="L424">		return attributes.containsKey(key);</span>
	}
	
	@Override
	public SamAttribute getAttribute(SamAttributeKey key){
<span class="nc" id="L429">		return attributes.get(key);</span>
	}
	
	@Override
	public boolean hasAttribute(ReservedSamAttributeKeys key){
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if(key==null){</span>
<span class="nc" id="L435">			throw new NullPointerException(&quot;key can not be null&quot;);</span>
		}
<span class="nc" id="L437">		return hasAttribute(key.getKey());</span>
	}
	
	@Override
	public SamAttribute getAttribute(ReservedSamAttributeKeys key){
<span class="nc bnc" id="L442" title="All 2 branches missed.">		if(key==null){</span>
<span class="nc" id="L443">			return null;</span>
		}
<span class="nc" id="L445">		return getAttribute(key.getKey());</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>