<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BgzfInputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam</a> &gt; <span class="el_source">BgzfInputStream.java</span></div><h1>BgzfInputStream.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam;


import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.nio.ByteOrder;
import java.util.zip.CRC32;
import java.util.zip.CheckedInputStream;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipException;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;

/**
 * {@code BgzfInputStream} is an {@link InputStream} implementation
 * for parsing BAM &quot;BGZF&quot; encoded files which are specially formated
 * concatenated GZIP blocks with extra fields.
 * &lt;br&gt;
 * Can't use {@link java.util.zip.GZIPInputStream} for 2 reasons:
 * &lt;ul&gt;
 * &lt;li&gt;GZIPInputStream had a bug in it for reading concatenated blocks
 * that wasn't fixed until Java 7 came out.  Since Jillion still supports
 * Java 6, moving to Java 7 wasn't an option.&lt;/li&gt;
 * &lt;li&gt;To support BAM indexes, we have to know internal details about
 * how many compressed and uncompressed bytes have been parsed so far
 * at any given moment as well as some values set by the 
 * BGZF extra fields.  This information could not be obtained
 * from (a fixed) GZIPInputStream even via subclassing. Reflection might
 * have worked but would be brittle.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * Therefore, it was decided to write a new implementation
 * to work around those problems.
 * 
 * @author		dkatzel
 *
 */
class BgzfInputStream extends InflaterInputStream {
	
	 private static final int BGZF_XLEN_LENGTH = 6;

	/**
     * GZIP header magic number.
     */
    private static final int GZIP_MAGIC_NUMBER = 0x8b1f;

    /*
     * GZIP block header flag 
     * names taken from constants
     * from RFC 1952
     */
    private static final int FHCRC      = 2; //bit 1
    private static final int FEXTRA     = 4; //bit 2
    private static final int FNAME      = 8; //bit 3
    private static final int FCOMMENT   = 16; //bit 4

    /**
     * This is the magic number in the extra fields
     * of a GZIP block that denote BGZF files.
     */
	private static final int BGZF_MAGIC_NUMBER = 0x4243;
	
    private static final int BGZF_EXTRA_FIELDS_LENGTH = 8;
    /**
     * The max buffer a compressed block can be.
     * We also use this as the GZIP buffer size
     * so it's easier to compute where we are in a block.
     */
    private static final int BUFFER_SIZE = 0xFFFF;

	/**
     * CRC-32 for uncompressed data.
     */
<span class="fc" id="L102">    protected CRC32 crc = new CRC32();</span>

    /**
     * Indicates end of file
     * has been reached.
     * Note : This is different than
     * closed..
     */
    protected boolean eof;
    /**
     * Indicates that the user
     * has called the {@link #close()} method
     * before we reached the end of file.
     */
<span class="fc" id="L116">    private volatile boolean closed = false;</span>
    /**
     * Number of compressed bytes
     * the full blocks we have read take up.
     * This is used to compute BAM
     * VirtualFileOffsets for BAM indexing. 
     */
<span class="fc" id="L123">    private long compressedBlockBytesReadSoFar=0;</span>

    
    private int currentBlockSize;

    /**
     * Creates a new BgzfInputStream with a default buffer size.
     * 
     * @param bamFile The bam file to parse.
     *
     * @throws ZipException if a GZIP format error has occurred or the
     *                         compression method used is unsupported
     * @throws IOException if an I/O error has occurred
     * 
     * @since 5.0
     */
    public static BgzfInputStream create(File bamFile) throws IOException{
<span class="nc" id="L140">    	return new BgzfInputStream(bamFile);</span>
    }
    /**
     * Creates a new {@link BgzfInputStream} starting
     * from the given {@link VirtualFileOffset}.
     * 
     * @param bamFile The bam file to parse.
     * @param vfs the {@link VirtualFileOffset} to use to seek to before reading
     *any bytes from the stream; can not be null.
     *
     * @throws ZipException if a GZIP format error has occurred or the
     *                         compression method used is unsupported
     *@throw IOException if an I/O error has occurred.
     * 
     * @throws NullPointerException if either parameter is null.
     * 
     * @since 5.0
     */
    static BgzfInputStream create(File bamFile, VirtualFileOffset vfs) throws IOException{
<span class="nc" id="L159">    	long compressedBamBlockOffset = vfs.getCompressedBamBlockOffset();</span>
    	InputStream in;
<span class="nc bnc" id="L161" title="All 2 branches missed.">    	if(compressedBamBlockOffset&gt;0){</span>
<span class="nc" id="L162">    		in = new RandomAccessFileInputStream(bamFile, compressedBamBlockOffset);</span>
    	}else{
<span class="nc" id="L164">    		in = new BufferedInputStream(new FileInputStream(bamFile));</span>
    	}
		
<span class="nc" id="L167">    	BgzfInputStream bgzfStream = new BgzfInputStream(in);</span>
    	
<span class="nc" id="L169">    	IOUtil.blockingSkip(bgzfStream, vfs.getUncompressedOffset());</span>
    	
<span class="nc" id="L171">    	return bgzfStream;</span>
    	
    }
    
    /**
     * Creates a new input stream with the specified buffer size.
     * @param in the input stream
     * @param size the input buffer size
     *
     * @throws ZipException if a GZIP format error has occurred or the
     *                         compression method used is unsupported
     * @throws IOException if an I/O error has occurred
     * @throws IllegalArgumentException if size is &lt;= 0
     */
    private BgzfInputStream(InputStream in, int size) throws IOException {
<span class="fc" id="L186">        super(in, new Inflater(true), size);</span>
<span class="fc" id="L187">        parseBlockHeader(in);</span>
<span class="fc" id="L188">    }</span>

    /**
     * Creates a new input stream with a default buffer size.
     * 
     * @param bam The bam file to parse.
     *
     * @throws ZipException if a GZIP format error has occurred or the
     *                         compression method used is unsupported
     * @throws IOException if an I/O error has occurred
     */
    public BgzfInputStream(File bam) throws IOException {
<span class="fc" id="L200">        this(new BufferedInputStream(new FileInputStream(bam),BUFFER_SIZE));</span>
<span class="fc" id="L201">    }</span>
    
    
    /**
     * Creates a new input stream with a default buffer size.
     * @param in the input stream
     *
     * @throws ZipException if a GZIP format error has occurred or the
     *                         compression method used is unsupported
     * @throws IOException if an I/O error has occurred
     */
    private BgzfInputStream(InputStream in) throws IOException {
<span class="fc" id="L213">        this(in, BUFFER_SIZE);</span>
<span class="fc" id="L214">    }</span>

    /**
     * Reads uncompressed data into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not
     * zero, the method will block until some input can be decompressed; otherwise,
     * no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.
     * @param buf the buffer into which the data is read
     * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;
     * @param len the maximum number of bytes read
     * @return  the actual number of bytes read, or -1 if the end of the
     *          compressed input stream is reached
     *
     * @throws  NullPointerException If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
     * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
     * &lt;code&gt;buf.length - off&lt;/code&gt;
     * @throws ZipException if the compressed input data is corrupt.
     * @throws IOException if an I/O error has occurred.
     *
     */
    public int read(byte[] buf, int off, int len) throws IOException {
<span class="fc" id="L235">        assertNotClosed();</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (!hasMoreData()) {</span>
<span class="nc" id="L237">            return -1;</span>
        }
        //don't read anything
        //unless we have to
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if(len ==0){</span>
<span class="nc" id="L242">        	return 0;</span>
        }
        //Most of the try block below
        //was taken from InflaterInputStream
        //so we don't have to call super.read()
        //and since super.read() will return -1
        //and set eof flags which we don't want.
        //If we are at the end of the block
        //we can simplify our code by 
        //checking if we have more blocks immediately
        //instead of checking for -1 and 
        //resetting flags.
        try {
            int bytesRead;
<span class="fc bfc" id="L256" title="All 2 branches covered.">            while ((bytesRead = inf.inflate(buf, off, len)) == 0) {</span>
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">                if (inf.finished() || inf.needsDictionary()) {</span>
                	//if we get here we've reached the end of the block
<span class="fc" id="L259">                	compressedBlockBytesReadSoFar +=currentBlockSize;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">                    if (hasMoreBlocks()){</span>
<span class="fc" id="L261">                    	return this.read(buf, off, len);</span>
                    }
                    //if we get here
                    //then we are done parsing the BAM file
<span class="fc" id="L265">                    eof = true;</span>
<span class="fc" id="L266">                    return -1;</span>
                }
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">                if (inf.needsInput()) {</span>
<span class="fc" id="L269">                    fill();</span>
                }
            }  	
<span class="fc" id="L272">            crc.update(buf, off, bytesRead);</span>
            
<span class="fc" id="L274">            return bytesRead;</span>
<span class="nc" id="L275">        } catch (DataFormatException e) {</span>
<span class="nc" id="L276">            String s = e.getMessage();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            throw new IOException(s == null ? &quot;Invalid ZLIB data format&quot; : s, e);</span>
        }
        
    }

  
    
    private void assertNotClosed() throws IOException {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (closed) {</span>
<span class="nc" id="L286">            throw new IOException(&quot;BAM file is closed&quot;);</span>
        }
<span class="fc" id="L288">    }</span>
    
    public boolean hasMoreData() {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">		return !eof;</span>
	}

    /**
     * Get the {@link VirtualFileOffset}
     * which represents where we are currently
     * in the {@link BgzfInputStream}.
     * Any read calls will change the value
     * returned by this method.
     * @return a new {@link VirtualFileOffset};
     * will never be null.  Calling
     * the method multiple times between reads
     * will return equal file offsets (but
     * may not be the same instance).
     */
    VirtualFileOffset getCurrentVirutalFileOffset(){    	
<span class="fc" id="L307">    	int uncompressedBytesReadInCurrentBlock = (int)this.inf.getBytesWritten();</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">    	if(uncompressedBytesReadInCurrentBlock &gt; BUFFER_SIZE){</span>
    		//this will cause an overflow in the encoded virtual file offset
    		//we should be able to just return the beginning of the next block...
<span class="fc" id="L311">    		return VirtualFileOffset.create(compressedBlockBytesReadSoFar + currentBlockSize, 0);</span>
        	
    	}
<span class="fc" id="L314">    	return VirtualFileOffset.create(compressedBlockBytesReadSoFar, uncompressedBytesReadInCurrentBlock);</span>
    	
    }
	

	/**
     * Closes this input stream and releases any system resources associated
     * with the stream.
     * @exception IOException if an I/O error has occurred
     */
    public void close() throws IOException {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (!closed) {</span>
<span class="fc" id="L326">            super.close();</span>
<span class="fc" id="L327">            eof = true;</span>
<span class="fc" id="L328">            closed = true;</span>
            //since we don't have access to the 
            //InflaterInputStream's useDefaultInflater field
            //we have to do the cleanup ourselves
<span class="fc" id="L332">            this.inf.end();</span>
        }
<span class="fc" id="L334">    }</span>

   
	
	
    /**
     * Reads GZIP Blcok header and returns the total byte number
     * of this member header.
     */
    private int parseBlockHeader(InputStream currentStream) throws IOException {
<span class="fc" id="L344">        CheckedInputStream in = new CheckedInputStream(currentStream, crc);</span>
<span class="fc" id="L345">        crc.reset();</span>
        // Check header magic
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (IOUtil.readUnsignedShort(in, ByteOrder.LITTLE_ENDIAN) != GZIP_MAGIC_NUMBER) {</span>
<span class="nc" id="L348">            throw new ZipException(&quot;Not in GZIP format&quot;);</span>
        }
        // Check compression method
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (IOUtil.readUnsignedByte(in) != 8) {</span>
<span class="nc" id="L352">            throw new ZipException(&quot;Unsupported compression method&quot;);</span>
        }
        // Read flags
<span class="fc" id="L355">        int flg = IOUtil.readUnsignedByte(in);</span>
        // Skip MTIME, XFL, and OS fields
<span class="fc" id="L357">        IOUtil.blockingSkip(in, BGZF_XLEN_LENGTH);</span>
        
<span class="fc" id="L359">        int headerLength = 10;</span>
<span class="fc" id="L360">        currentBlockSize = parseCurrentBgzfBlockSize(in, flg);</span>

<span class="fc" id="L362">        headerLength += BGZF_EXTRA_FIELDS_LENGTH;</span>
        // Skip optional file name if present
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if ((flg &amp; FNAME) == FNAME) {</span>
            do {
<span class="nc" id="L366">                headerLength++;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            } while (IOUtil.readUnsignedByte(in) != 0);</span>
        }
        // Skip optional file comment if present
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if ((flg &amp; FCOMMENT) == FCOMMENT) {</span>
            do {
<span class="nc" id="L372">                headerLength++;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            } while (IOUtil.readUnsignedByte(in) != 0);</span>
        }
        // Check optional header CRC
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if ((flg &amp; FHCRC) == FHCRC) {</span>
<span class="nc" id="L377">            int v = (int)crc.getValue() &amp; 0xffff;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (IOUtil.readUnsignedShort(in, ByteOrder.LITTLE_ENDIAN) != v) {</span>
<span class="nc" id="L379">                throw new ZipException(&quot;Corrupt GZIP header&quot;);</span>
            }
<span class="nc" id="L381">            headerLength += 2;</span>
        }
<span class="fc" id="L383">        crc.reset();</span>
<span class="fc" id="L384">        return headerLength;</span>
    }

	private int parseCurrentBgzfBlockSize(CheckedInputStream in, int flg)
			throws IOException {
        //BGZF files must have the F.EXTRA
        //flag set and have a payload of 6 bytes
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if ((flg &amp; FEXTRA) == FEXTRA) {</span>
<span class="fc" id="L392">            int extraLength = IOUtil.readUnsignedShort(in, ByteOrder.LITTLE_ENDIAN);</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">            if(extraLength !=6){</span>
<span class="nc" id="L394">            	throw new IOException(&quot;invalid BGZF file, F.EXTRA not correct length&quot;);</span>
            }
<span class="fc" id="L396">            int magic = IOUtil.readUnsignedShort(in);</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if(magic != BGZF_MAGIC_NUMBER){</span>
<span class="nc" id="L398">            	throw new IOException(&quot;invalid BGZF file, F.EXTRA Subfield IDs are wrong &quot; + Integer.toHexString(magic));                </span>
            }
            
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if(IOUtil.readUnsignedShort(in, ByteOrder.LITTLE_ENDIAN) != 2){</span>
<span class="nc" id="L402">            	throw new IOException(&quot;invalid BGZF file, F.EXTRA payload length not 2&quot;);                </span>
            }
<span class="fc" id="L404">           return IOUtil.readUnsignedShort(in, ByteOrder.LITTLE_ENDIAN) +1;</span>
            
        }else{
        	//not a BGZF file
<span class="nc" id="L408">        	throw new IOException(&quot;invalid BGZF file, F.EXTRA not set&quot;);</span>
        }

	}

    /**
     * Checks to see if there are more
     * concatenated blocks in this 
     * GZIP inputStream. 
     * BGZF files have multiple
     * GZIP blocks.
     * If there are more blocks, then the 
     * wrapped InputSream is advanced to the correct position
     * to begin reading that next block seamlessly.
     * @return {@code true} if there are more blocks
     * {@code false} if there aren't.
     * @throws IOException
     */
    private boolean hasMoreBlocks() throws IOException {
        //GZIPBUG FIX
        //This next code block supports handling
        //concatenated blocks which the BGZF uses
        //Which broke Java pre Java 6u23 (or there-abouts)
    	
    	//code mostly taken from various bug reports
    	//that included work around code
    	
<span class="fc" id="L435">        InputStream in = this.in;</span>
<span class="fc" id="L436">        int remaining = inf.getRemaining();</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        if (remaining &gt; 0) {</span>
<span class="fc" id="L438">            in = new SequenceInputStream(</span>
                        new ByteArrayInputStream(buf, len - remaining, remaining), in);
        }
<span class="fc" id="L441">        long actualCrc = crc.getValue();</span>
<span class="fc" id="L442">        long expectedCrc = IOUtil.readUnsignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
        
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if(expectedCrc != actualCrc){</span>
<span class="nc" id="L445">        	throw new ZipException(&quot;invalid CRC: expected &quot; + expectedCrc + &quot; actual &quot; + actualCrc);</span>
        }
        // rfc1952; ISIZE is the input size % 2^32
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if(IOUtil.readUnsignedInt(in, ByteOrder.LITTLE_ENDIAN) != (inf.getBytesWritten() &amp; 0xffffffffL) ){</span>
<span class="nc" id="L449">        	throw new ZipException(&quot;invalid ISIZE&quot;);</span>
        }
      
        
        // If there are more bytes available in &quot;in&quot; or
        // the leftover in the &quot;inf&quot; is &gt; 26 bytes:
        // 8 bytes per footer and at least 10 bytes in the next header block
        //means we should have at least 10+ 2*8 bytes if we have another
        //block (because we still have our current footer + the next block's header and footer)

<span class="fc bfc" id="L459" title="All 4 branches covered.">        if (this.in.available() &gt; 0 || remaining &gt; 26) {</span>
<span class="fc" id="L460">            int m = 8;                  // this.footer</span>
            try {
<span class="fc" id="L462">                m += parseBlockHeader(in);    // next.header</span>
<span class="nc" id="L463">            } catch (IOException ze) {</span>
<span class="nc" id="L464">                return false;  // ignore any malformed, do nothing</span>
<span class="fc" id="L465">            }</span>
<span class="fc" id="L466">            inf.reset();</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            if (remaining &gt; m){</span>
<span class="fc" id="L468">                inf.setInput(buf, len - remaining + m, remaining - m);</span>
            }
<span class="fc" id="L470">            return true;</span>
        }
<span class="fc" id="L472">        return false;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>