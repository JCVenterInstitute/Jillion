<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TraceArchiveWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.experimental.trace.archive2</a> &gt; <span class="el_source">TraceArchiveWriter.java</span></div><h1>TraceArchiveWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.experimental.trace.archive2;

import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.util.DateUtil;
import org.jcvi.jillion.fasta.nt.NucleotideFastaWriter;
import org.jcvi.jillion.fasta.nt.NucleotideFastaWriterBuilder;
import org.jcvi.jillion.fasta.pos.PositionFastaWriter;
import org.jcvi.jillion.fasta.pos.PositionFastaWriterBuilder;
import org.jcvi.jillion.fasta.qual.QualityFastaWriter;
import org.jcvi.jillion.fasta.qual.QualityFastaWriterBuilder;
import org.jcvi.jillion.trace.chromat.Chromatogram;
import org.jcvi.jillion.trace.chromat.ChromatogramFactory;

/**
 * {@code TraceArchiveWriter} is a class
 * that can write out a complete Trace Archive folder structure which contains the 
 * following files:
 * &lt;ul&gt;
 * &lt;li&gt;TRACEINFO.XML&lt;/li&gt;
 * &lt;li&gt;README&lt;/li&gt;
 * &lt;li&gt;fasta folder: contains 1 fasta file per record&lt;/li&gt;
 * &lt;li&gt;pos folder: contains 1 position fasta file per record&lt;/li&gt;
 * &lt;li&gt;qual folder: contains 1 quality fasta file per record&lt;/li&gt;
 * &lt;li&gt;traces folder: contains 1 binary trace per record&lt;/li&gt;
 * &lt;/ul&gt;
 * @author dkatzel
 *
 */
public final class TraceArchiveWriter implements Closeable{

	private static final String README_TEXT = 
			&quot;JCVI Trace Volume Generated: %s%n&quot;
			+ &quot;In instances where two basecallers are reported both callers were used in%n&quot;
			+ &quot;conjuction to create the basecall and/or assign quality values.%n%n&quot;

			+ &quot;This volume contains:%n&quot;
			+ &quot;. MD5            MD5 file signatures%n&quot;
			+ &quot;. README         This file%n&quot;
			+ &quot;. TRACEINFO.XML  Auxiliary information in XML format%n&quot;
			+ &quot;. fasta          directory containing basecalls%n&quot;
			+ &quot;. peak           directory containing peak index values%n&quot;
			+ &quot;. qual           directory containing quality scores%n&quot;
			+ &quot;. traces         directory containing %d trace file(s)%n&quot;;
	
<span class="fc" id="L86">	private static final DateFormat DATE_TIME_FORMATTER = new SimpleDateFormat(&quot;yyyy-MM-dd-HH:mm:ss&quot;, Locale.US);</span>
    
	private final File rootDir;
	private final TraceArchiveRecordCallback recordCallback;
	
	private final DefaultTraceArchiveInfo.Builder traceInfoBuilder;
<span class="fc" id="L92">	private final Set&lt;String&gt; traceNamesSeen= new HashSet&lt;String&gt;();</span>
	
	private final String volumeName, volumeVersion;
	private final Date volumeDate;
	/**
	 * Create a new TraceArchiveWriter without any common fields.
	 */
	public TraceArchiveWriter(File rootDir,TraceArchiveRecordCallback recordFactory,
			String volumeName, Date volumeDate, String volumeVersion) throws IOException {
<span class="fc" id="L101">		this(rootDir, Collections.&lt;TraceInfoField, String&gt;emptyMap(), recordFactory,</span>
				volumeName, volumeDate, volumeVersion);
<span class="fc" id="L103">	}</span>
	/**
	 * Create a new TraceArchiveWriter.
	 * @param rootDir the root directory of where to write out the trace archive;
	 * if this parameter is null, then the current directory is used 
	 * (not recommended).  If the given directory does not
	 * exist, then it will be created.
	 * @param commonFields {@link Map} of common fields
	 * that should be included in all trace archive records;
	 * if no common fields should be used, then include
	 * and empty collection, can not be null.
	 * @param recordCallback an instance of {@link TraceArchiveRecordCallback}
	 * can not be null.
	 * @throws IOException if the root directory given does not
	 * exist, and an error occurs trying to create it.
	 * @throws NullPointerException if recordCallback, commonFields is null
	 * or if any key or value in commonFields is null.
	 */
	public TraceArchiveWriter(File rootDir,Map&lt;TraceInfoField, String&gt; commonFields, TraceArchiveRecordCallback recordCallback,
<span class="fc" id="L122">			String volumeName, Date volumeDate, String volumeVersion) throws IOException {</span>
		//delete pre-existing files if any
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">		if(rootDir !=null){</span>
<span class="fc" id="L125">			IOUtil.recursiveDelete(rootDir);</span>
		}
<span class="fc" id="L127">		IOUtil.mkdirs(rootDir);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if(recordCallback ==null){</span>
<span class="nc" id="L129">			throw new NullPointerException(&quot;TraceArchiveRecordFactory instance can not be null&quot;);</span>
		}
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if(commonFields ==null){</span>
<span class="nc" id="L132">			throw new NullPointerException(&quot;common fields Map can not be null&quot;);</span>
		}
		
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">		this.volumeDate = volumeDate == null? null : new Date(volumeDate.getTime());</span>
<span class="fc" id="L136">		this.volumeName = volumeName;</span>
<span class="fc" id="L137">		this.volumeVersion = volumeVersion;</span>
		
<span class="fc" id="L139">		this.rootDir = rootDir;</span>
<span class="fc" id="L140">		this.recordCallback = recordCallback;</span>
<span class="fc" id="L141">		traceInfoBuilder = new DefaultTraceArchiveInfo.Builder();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">		for(Entry&lt;TraceInfoField, String&gt; entry: commonFields.entrySet()){</span>
<span class="nc" id="L143">			traceInfoBuilder.addCommonField(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L144">		}</span>
<span class="fc" id="L145">		IOUtil.mkdirs(new File(rootDir,&quot;fasta&quot;));</span>
<span class="fc" id="L146">		IOUtil.mkdirs(new File(rootDir,&quot;peak&quot;));</span>
<span class="fc" id="L147">		IOUtil.mkdirs(new File(rootDir,&quot;qual&quot;));</span>
<span class="fc" id="L148">		IOUtil.mkdirs(new File(rootDir,&quot;traces&quot;));</span>
<span class="fc" id="L149">	}</span>
	/**
	 * 
	 * @param traceName the name of the trace (read id)
	 * @param traceFile the File containing the actual trace data.
	 * 
	 * @throws IOException if there is an exception parsing the given
	 * traceFile.
	 * @throws NullPointerException if traceName or traceFile are null.
	 * 
	 * @throws IllegalArgumentException if a trace with the given traceName
	 * has already been added.
	 */
	public void addTrace(String traceName,File traceFile) throws IOException, TraceArchiveRecordDataException{
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">		if(traceName ==null){</span>
<span class="nc" id="L164">			throw new NullPointerException(&quot;traceName can not be null&quot;);</span>
		}
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		if(traceFile ==null){</span>
<span class="nc" id="L167">			throw new NullPointerException(&quot;traceFile can not be null&quot;);</span>
		}
<span class="fc" id="L169">		TraceArchiveRecordBuilder recordBuilder = new DefaultTraceArchiveRecord.Builder();</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">		if(traceNamesSeen.contains(traceName)){</span>
<span class="nc" id="L171">			throw new IllegalArgumentException(&quot;already added a trace with the trace name &quot;+ traceName);</span>
		}
<span class="fc" id="L173">		traceNamesSeen.add(traceName);</span>
<span class="fc" id="L174">		recordBuilder.put(TraceInfoField.TRACE_NAME,traceName);</span>
<span class="fc" id="L175">		Chromatogram chromo = parseChromatogram(traceName, traceFile);</span>
<span class="fc" id="L176">		handleSeqFasta(recordBuilder, traceName, chromo);</span>
<span class="fc" id="L177">		handleQualFasta(recordBuilder, traceName, chromo);		</span>
<span class="fc" id="L178">		handlePeakFasta(recordBuilder, traceName, chromo);</span>
		
<span class="fc" id="L180">		copyTraceFile(recordBuilder, traceName, traceFile);</span>
<span class="fc" id="L181">		recordCallback.addMetaData(traceName, traceFile,recordBuilder);</span>
		
<span class="fc" id="L183">		traceInfoBuilder.addRecord(recordBuilder.build());</span>
<span class="fc" id="L184">	}</span>
	private void copyTraceFile(TraceArchiveRecordBuilder recordBuilder, String traceName,
			File traceFile)
			throws FileNotFoundException, IOException {
<span class="fc" id="L188">		String pathToTraceFile = String.format(&quot;./traces/%s.ztr&quot;, traceName);</span>
<span class="fc" id="L189">		recordBuilder.put(TraceInfoField.TRACE_FILE, pathToTraceFile);</span>

<span class="pc" id="L191">		try(InputStream in = new FileInputStream(traceFile);</span>
<span class="fc" id="L192">                    OutputStream out = new FileOutputStream(new File(rootDir, pathToTraceFile))){</span>
		    
<span class="fc" id="L194">			IOUtil.copy(in, out);</span>
<span class="pc bpc" id="L195" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L196">	}</span>
	
	private String createMd5For(File f) throws IOException{
		MessageDigest md5;
		try {
<span class="fc" id="L201">			md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="nc" id="L202">		} catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L203">			throw new IOException(&quot;could not compute MD5&quot;,e);</span>
<span class="fc" id="L204">		}</span>
		
<span class="pc" id="L206">		try(InputStream in = new FileInputStream(f)){</span>
<span class="fc" id="L207">			byte[] bytes =IOUtil.toByteArray(in);</span>
<span class="fc" id="L208">			return toPaddedHexString(md5.digest(bytes));</span>
<span class="pc bpc" id="L209" title="6 of 8 branches missed.">		}</span>
	}
	private String toPaddedHexString(byte[] digest){
<span class="fc" id="L212">		StringBuilder builder = new StringBuilder(digest.length*2);</span>
		//Integer.toHexString will only print out 
		//a single character if the value is &lt;16
		// ex: &quot;a&quot; instead of &quot;0a&quot; so we
		//need to add padding if that happens.
<span class="fc bfc" id="L217" title="All 2 branches covered.">		for(int i=0; i&lt;digest.length; i++){</span>
<span class="fc" id="L218">			String hex = Integer.toHexString(0xFF &amp; digest[i]);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">			if(hex.length() ==1){</span>
				//padd
<span class="fc" id="L221">				builder.append('0');</span>
			}
<span class="fc" id="L223">			builder.append(hex);</span>
		}
<span class="fc" id="L225">		return builder.toString();</span>
	}
	
	public int getNumberOfTracesWritten(){
<span class="fc" id="L229">		return this.traceNamesSeen.size();</span>
	}
	
	@Override
	public void close() throws IOException {
<span class="fc" id="L234">		TraceArchiveInfo info =traceInfoBuilder.build();</span>
<span class="fc" id="L235">		File xmlFile = createTraceInfoFile(info);		</span>
<span class="fc" id="L236">		File readMeFile = createReadmeFile();		</span>
<span class="fc" id="L237">		createMd5File(xmlFile, readMeFile);</span>
		
<span class="fc" id="L239">	}</span>
	private File createTraceInfoFile(TraceArchiveInfo info)
			throws IOException {
<span class="fc" id="L242">		File xmlFile = new File(rootDir, &quot;TRACEINFO.XML&quot;);</span>
		
<span class="pc" id="L244">		try(OutputStream out = new FileOutputStream(xmlFile)){</span>
<span class="fc" id="L245">			TraceInfoWriterUtil.writeTraceInfoXML(out, info, volumeName, volumeDate, volumeVersion);</span>
<span class="pc bpc" id="L246" title="6 of 8 branches missed.">		}</span>
<span class="fc" id="L247">		return xmlFile;</span>
	}
	private File createReadmeFile() throws IOException {
<span class="fc" id="L250">		File readMeFile = new File(rootDir, &quot;README&quot;);</span>
<span class="fc" id="L251">		writeReadmeText(readMeFile);</span>
<span class="fc" id="L252">		return readMeFile;</span>
	}
	private void createMd5File(File xmlFile, File readMeFile)
			throws FileNotFoundException, IOException {
<span class="pc" id="L256">		try(PrintWriter md5Writer = new PrintWriter(new File(rootDir, &quot;MD5&quot;), IOUtil.UTF_8_NAME)){</span>

<span class="fc" id="L258">        		md5Writer.println(createMd5For(xmlFile) +&quot;\tTRACEINFO.XML&quot;);</span>
<span class="fc" id="L259">        		md5Writer.println(createMd5For(readMeFile) +&quot;\tREADME&quot;);</span>
<span class="pc bpc" id="L260" title="6 of 8 branches missed.">		}</span>
<span class="fc" id="L261">	}</span>
	private void writeReadmeText(File readMeFile) throws IOException {
		
<span class="pc" id="L264">		try(PrintWriter writer = new PrintWriter(readMeFile, IOUtil.UTF_8_NAME)){</span>
			//must synchronize data formatter since 
			//it is badly designed and not multithreaded.
<span class="fc" id="L267">			synchronized(DATE_TIME_FORMATTER){</span>
<span class="fc" id="L268">				writer.printf(README_TEXT, </span>
<span class="fc" id="L269">						DATE_TIME_FORMATTER.format(DateUtil.getCurrentDate()),</span>
<span class="fc" id="L270">						traceNamesSeen.size());</span>
<span class="pc" id="L271">			}</span>
<span class="pc bpc" id="L272" title="6 of 8 branches missed.">		}</span>
		
		
<span class="fc" id="L275">	}</span>
	private void handleSeqFasta(TraceArchiveRecordBuilder recordBuilder, String traceName, Chromatogram chromo)
			throws FileNotFoundException, IOException {
<span class="fc" id="L278">		String fastaFilePath = String.format(&quot;./fasta/%s.fasta&quot;, traceName);</span>
<span class="pc" id="L279">		try(NucleotideFastaWriter writer = new NucleotideFastaWriterBuilder(new File(rootDir, fastaFilePath))</span>
<span class="fc" id="L280">														.build()){</span>
<span class="fc" id="L281">		writer.write(traceName, chromo.getNucleotideSequence());</span>
<span class="fc" id="L282">		recordBuilder.put(TraceInfoField.BASE_FILE, fastaFilePath);</span>
<span class="pc bpc" id="L283" title="6 of 8 branches missed.">		}</span>
		
		
<span class="fc" id="L286">	}</span>
	
	private void handleQualFasta(TraceArchiveRecordBuilder recordBuilder, String traceName, Chromatogram chromo)
			throws FileNotFoundException, IOException {
<span class="fc" id="L290">		String qualFastaFilePath = String.format(&quot;./qual/%s.qual&quot;, traceName);</span>
<span class="pc" id="L291">		try(QualityFastaWriter writer = new QualityFastaWriterBuilder(new File(rootDir, qualFastaFilePath))</span>
<span class="fc" id="L292">														.build()){</span>
		
<span class="fc" id="L294">		    writer.write(traceName, chromo.getQualitySequence());</span>
<span class="fc" id="L295">		    recordBuilder.put(TraceInfoField.QUAL_FILE, qualFastaFilePath);</span>
<span class="pc bpc" id="L296" title="6 of 8 branches missed.">		}</span>
<span class="fc" id="L297">	}</span>
	
	private void handlePeakFasta(TraceArchiveRecordBuilder recordBuilder, String traceName, Chromatogram chromo)
			throws FileNotFoundException, IOException {
<span class="fc" id="L301">		String peakFastaFilePath = String.format(&quot;./peak/%s.peak&quot;, traceName);</span>
<span class="pc" id="L302">		try(PositionFastaWriter writer = new PositionFastaWriterBuilder(new File(rootDir, peakFastaFilePath))</span>
<span class="fc" id="L303">														.build()){</span>
<span class="fc" id="L304">		writer.write(traceName, chromo.getPeakSequence());</span>
		
		
<span class="fc" id="L307">		recordBuilder.put(TraceInfoField.PEAK_FILE, peakFastaFilePath);</span>
<span class="pc bpc" id="L308" title="6 of 8 branches missed.">		}</span>
<span class="fc" id="L309">	}</span>
	
	private Chromatogram parseChromatogram(String traceName, File traceFile) throws IOException {
<span class="fc" id="L312">		return ChromatogramFactory.create(traceName,traceFile);</span>
	}
	/**
	 * {@code TraceArchiveRecordCallback} is a way to add
	 * additional metadata to specific {@link TraceArchiveRecord}s
	 * before they are built.  The {@link TraceArchiveWriter} will
	 * create an instance of {@link TraceArchiveRecordBuilder}
	 * for each record but only partially populate them.
	 * It is up to implementations of {@link TraceArchiveRecordCallback}
	 * to complete building each record by setting attribute
	 * key value pairs that a generic TraceArchiveWriter won't know how to set.
	 * For example, each trace often requires primer information
	 * to be set in a trace archive.  Implementations of {@link TraceArchiveRecordCallback}
	 * would know how to look up such information from the clients LIMS system.
	 *  
	 * @author dkatzel
	 *
	 */
	public interface TraceArchiveRecordCallback{
		/**
		 * Add any additional metadata to the given {@link TraceArchiveRecordBuilder}
		 * for the given traceName with the accompanying traceFile.
		 * The given builder already has several attributes already 
		 * including:
		 * &lt;ul&gt;
		 * &lt;li&gt; {@link TraceInfoField#TRACE_NAME} = traceName&lt;/li&gt;
		 * &lt;li&gt; {@link TraceInfoField#TRACE_FILE} = path to a copy of traceFile&lt;/li&gt;
		 * &lt;li&gt; {@link TraceInfoField#BASE_FILE} = path to nucleotide sequence fasta&lt;/li&gt;
		 * &lt;li&gt; {@link TraceInfoField#PEAK_FILE} = path to peak positions sequence fasta&lt;/li&gt;
		 * &lt;li&gt; {@link TraceInfoField#QUAL_FILE} = path to quality  sequence fasta&lt;/li&gt;
		 * &lt;/ul&gt;
		 * Additional metadata that is recommended to be added are attributes such
		 * as direction, primer and vector info etc.
		 * @param traceName the name that is used to set
		 * the {@link TraceInfoField#TRACE_NAME}.
		 * @param traceFile the actual trace file of this record.  A copy of this file
		 * is included in the archive and pointed to by {@link TraceInfoField#TRACE_FILE}.
		 * @param builder the builder to add extra metadata to such as direction, primer and vector info etc.
		 */
		void addMetaData(final String traceName,final File traceFile, final TraceArchiveRecordBuilder builder) throws TraceArchiveRecordDataException;
	}
	/**
	 * {@code TraceArchiveRecordDataException} is a checked
	 * {@link Exception} that is to be thrown
	 * when an error occurs while creating metadata for
	 * a {@link TraceArchiveRecord}.
	 * @author dkatzel
	 *
	 */
	public static class TraceArchiveRecordDataException extends Exception{

		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		public TraceArchiveRecordDataException(String message, Throwable cause) {
<span class="nc" id="L369">			super(message, cause);</span>
<span class="nc" id="L370">		}</span>

		public TraceArchiveRecordDataException(String message) {
<span class="nc" id="L373">			super(message);</span>
<span class="nc" id="L374">		}</span>
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>