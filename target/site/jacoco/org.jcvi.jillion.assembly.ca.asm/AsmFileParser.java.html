<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AsmFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.ca.asm</a> &gt; <span class="el_source">AsmFileParser.java</span></div><h1>AsmFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.ca.asm;

import java.io.BufferedInputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.assembly.ca.asm.AsmContigVisitor.VariantRecord;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.AsmVisitorCallback;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.AsmVisitorCallback.AsmVisitorMemento;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.LinkOrientation;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.MatePairEvidence;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.MateStatus;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.OverlapStatus;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.OverlapType;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.UnitigLayoutType;
import org.jcvi.jillion.assembly.ca.asm.AsmVisitor.UnitigStatus;
import org.jcvi.jillion.core.DirectedRange;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
import org.jcvi.jillion.internal.core.io.TextLineParser;
import org.jcvi.jillion.internal.core.util.JillionUtil;

/**
 * {@code AsmFileParser} is a class
 * that can parse Celera Assembler files.
 * 
 * @author dkatzel
 *
 *
 */
public abstract class AsmFileParser implements AsmParser{
	
	
	private static final String SRC = &quot;src&quot;;

	/**
	 * Refactored out split Pattern since String.split() 
	 * causes a new Pattern to be created and compiled
	 * for each call.  This is a minor cpu optimization.
	 */
<span class="fc" id="L81">	private static final Pattern SPLIT_ON_SLASH = Pattern.compile(&quot;/&quot;);</span>
	
	 private static final String END_MESSAGE = &quot;}&quot;;
	 
<span class="fc" id="L85">	 private static final Pattern LENGTH_PATTERN = Pattern.compile(&quot;len:(\\d+)&quot;);</span>
<span class="fc" id="L86">	 private  static final Pattern NUM_READS_PATTERN = Pattern.compile(&quot;n\\S\\S:(\\d+)&quot;);</span>
     
	 
<span class="fc" id="L89">	private AsmFileParser(){</span>
		//can not instantiate outside this file.
<span class="fc" id="L91">	}</span>
	
	public static AsmParser create(File asmFile){
<span class="fc" id="L94">		return new FileBasedAsmFileParser(asmFile);</span>
	}
	
	
	
    protected void  parseAsm(ParserState parserState, AsmVisitor visitor) throws IOException{       
<span class="fc" id="L100">        AsmMessageHandler.parse(parserState, visitor);</span>
<span class="fc" id="L101">    }</span>
    
    protected abstract class ParserState implements Closeable{
        private final TextLineParser parser;
        protected long markedOffset;
<span class="fc" id="L106">        protected final AtomicBoolean keepParsing = new AtomicBoolean(true);</span>
        
<span class="fc" id="L108">        ParserState(InputStream inputStream, long initialOffset) throws IOException{</span>
<span class="fc" id="L109">            this.parser = new TextLineParser(inputStream,initialOffset);</span>
<span class="fc" id="L110">            markedOffset= initialOffset;</span>
<span class="fc" id="L111">        }</span>
        
        boolean hasNextLine(){
<span class="fc" id="L114">            return parser.hasNextLine();</span>
        }
        
        String getNextLine() throws IOException{
<span class="fc" id="L118">            return parser.nextLine(); </span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public void close() throws IOException {
<span class="nc" id="L125">            parser.close();            </span>
<span class="nc" id="L126">        }</span>
        public abstract CallBack createCallback();

		public void markCurrentOffset() {
<span class="fc" id="L130">			markedOffset =parser.getPosition();</span>
			
<span class="fc" id="L132">		}</span>

		public boolean keepParsing() {
<span class="fc" id="L135">			return keepParsing.get();</span>
		}

        
    }
    
<span class="pc" id="L141">    enum AsmMessageHandler{</span>
        /**
         * Describes a group of mate pairs that belong to the same library.
         */
<span class="fc" id="L145">        MODIFIED_DISTANCE_MESSAGE(&quot;MDI&quot;) {</span>
<span class="fc" id="L146">            private final Pattern refIdPattern = Pattern.compile(&quot;ref:\\((\\S+),(\\d+)\\)&quot;);</span>
            /**
             * min can be set to a negative value
             */
<span class="fc" id="L150">            private final Pattern minPattern = Pattern.compile(&quot;min:(-?\\d+)&quot;);</span>
<span class="fc" id="L151">            private final Pattern maxPattern = Pattern.compile(&quot;max:(\\d+)&quot;);</span>
<span class="fc" id="L152">            private final Pattern histogramBucketPattern = Pattern.compile(&quot;buc:(\\d+)&quot;);</span>
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor) throws IOException {
<span class="fc" id="L155">                IdTuple idTuple = parseIds(parserState, visitor, refIdPattern);</span>
<span class="fc" id="L156">                float mean = parseMean(parserState, visitor);                </span>
<span class="fc" id="L157">                float stdDev = parseStdDev(parserState, visitor);                </span>
<span class="fc" id="L158">                long min=parseMin(parserState, visitor);</span>
<span class="fc" id="L159">                long max=parseMax(parserState, visitor);</span>
                
<span class="fc" id="L161">                List&lt;Long&gt; histogram=parseHistogram(parserState,visitor);</span>
<span class="fc" id="L162">                parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="fc" id="L163">                visitor.visitLibraryStatistics(idTuple.externalId, idTuple.internalId, </span>
                        mean, stdDev, min, max, histogram);
<span class="fc" id="L165">            }</span>
           
            private float parseStdDev(ParserState parserState, AsmVisitor visitor) throws IOException {
<span class="fc" id="L168">                String stdDevLine = parserState.getNextLine();</span>
<span class="fc" id="L169">                Matcher stdDevMatcher = STD_DEV_PATTERN.matcher(stdDevLine);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">                if(!stdDevMatcher.find()){</span>
<span class="nc" id="L171">                    throw new IOException(&quot;invalid asm file: could not parse MDI std dev of distances: &quot;+stdDevLine);</span>
                }
<span class="fc" id="L173">                return  Float.parseFloat(stdDevMatcher.group(1));</span>
            }
            private float parseMean(ParserState parserState, AsmVisitor visitor) throws IOException {
<span class="fc" id="L176">                String meanLine = parserState.getNextLine();</span>
<span class="fc" id="L177">                Matcher meanMatcher = MEAN_PATTERN.matcher(meanLine);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                if(!meanMatcher.find()){</span>
<span class="nc" id="L179">                    throw new IOException(&quot;invalid asm file: could not parse MDI mean distance: &quot;+meanLine);</span>
                }
<span class="fc" id="L181">                return Float.parseFloat(meanMatcher.group(1));</span>
            }
            
            private long parseMin(ParserState parserState, AsmVisitor visitor) throws IOException {
<span class="fc" id="L185">                String minLine = parserState.getNextLine();</span>
<span class="fc" id="L186">                Matcher meanMatcher = minPattern.matcher(minLine);</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                if(!meanMatcher.find()){</span>
<span class="nc" id="L188">                    throw new IOException(&quot;invalid asm file: could not parse MDI min distance: &quot;+minLine);</span>
                }
<span class="fc" id="L190">                return Long.parseLong(meanMatcher.group(1));</span>
            }
            private long parseMax(ParserState parserState, AsmVisitor visitor) throws IOException {
<span class="fc" id="L193">                String maxLine = parserState.getNextLine();</span>
<span class="fc" id="L194">                Matcher meanMatcher = maxPattern.matcher(maxLine);</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">                if(!meanMatcher.find()){</span>
<span class="nc" id="L196">                    throw new IOException(&quot;invalid asm file: could not parse MDI max distance: &quot;+maxLine);</span>
                }
<span class="fc" id="L198">                return Long.parseLong(meanMatcher.group(1));</span>
            }
            
            private List&lt;Long&gt; parseHistogram(ParserState parserState, AsmVisitor visitor) throws IOException {
<span class="fc" id="L202">                String histLine =parserState.getNextLine();</span>
<span class="fc" id="L203">                Matcher bucketMatcher = histogramBucketPattern.matcher(histLine);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                if(!bucketMatcher.find()){</span>
<span class="nc" id="L205">                    throw new IOException(&quot;invalid asm file: could not parse MDI number of histogram buckets: &quot;+histLine);</span>
                }
                //even though the ASM spec says
                //unsigned Int32, there shouldn't
                //ever be more then Integer.MAX_VALUE buckets!
                //Even if an ASM file had  a larger number of buckets
                //we woudn't be able to create the histogram
                //because List and arrays have a max value of 
                //Integer.MAX_VALUE.
                //Integer.parseInt javadoc says it will throw
                //NumberFormatException if value is too big
                //so we are covered.
<span class="fc" id="L217">                int numBuckets = Integer.parseInt(bucketMatcher.group(1));</span>
<span class="fc" id="L218">                String histogramStart =parserState.getNextLine();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                if(!histogramStart.startsWith(&quot;his:&quot;)){</span>
<span class="nc" id="L220">                    throw new IOException(&quot;invalid asm file: could not parse MDI start of histogram values: &quot;+histogramStart);</span>
                 }
<span class="fc" id="L222">                List&lt;Long&gt; histogram = new ArrayList&lt;Long&gt;(numBuckets);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                for(int i=0; i&lt; numBuckets; i++){</span>
<span class="nc" id="L224">                    String line = parserState.getNextLine();</span>
<span class="nc" id="L225">                    histogram.add(Long.parseLong(line.trim()));</span>
                }
<span class="fc" id="L227">                return histogram;</span>
            }
            
            
        },
<span class="fc" id="L232">        FRAGMENT(&quot;AFG&quot;){</span>
             
<span class="fc" id="L234">            private final Pattern isSingletonPattern = Pattern.compile(&quot;cha:(\\d+)&quot;);</span>
<span class="fc" id="L235">            private final Pattern clearRangePattern = Pattern.compile(&quot;clr:(\\d+,\\d+)&quot;);</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor)
                    throws IOException {
<span class="fc" id="L240">                IdTuple idTuple =parseIds(parserState, visitor, ACCESSION_PATTERN);</span>
                //old asm files used to have a scn block 
                //which should be ignored
<span class="fc" id="L243">                String scnLine = parserState.getNextLine();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">                if(scnLine.startsWith(&quot;scn&quot;)){</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    while(!scnLine.startsWith(&quot;.&quot;)){</span>
<span class="nc" id="L246">                        scnLine = parserState.getNextLine();</span>
                    }
                    //get next line which should be status
<span class="nc" id="L249">                    scnLine = parserState.getNextLine();</span>
                }
<span class="fc" id="L251">                MateStatus mateStatus = parseMateStatus(scnLine);</span>
                //is chimeric line is now ignored
                //but we need to visit the line anyway
                //to correctly update offset counts
<span class="fc" id="L255">                parserState.getNextLine();                </span>
<span class="fc" id="L256">                boolean isSingleton = parseIsSingleton(parserState, visitor);</span>
<span class="fc" id="L257">                Range clearRange = parseClearRange(parserState, visitor);</span>
<span class="fc" id="L258">                parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="fc" id="L259">                visitor.visitRead(idTuple.externalId, idTuple.internalId,</span>
                        mateStatus, isSingleton, clearRange);
<span class="fc" id="L261">            }</span>

            private Range parseClearRange(ParserState parserState,
                    AsmVisitor visitor) throws IOException {
<span class="fc" id="L265">                String line = parserState.getNextLine();</span>
<span class="fc" id="L266">                Matcher matcher = clearRangePattern.matcher(line);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L268">                    throw new IOException(&quot;invalid asm file: could not parse AFG clear range: &quot;+line);</span>
                }
<span class="fc" id="L270">                return Range.parseRange(matcher.group(1),CoordinateSystem.SPACE_BASED);</span>
            }

            
            /**
             * Is singleton if chaff value is set to 1; 0 otherwise.
             */
            private boolean parseIsSingleton(ParserState parserState,
                    AsmVisitor visitor) throws IOException {
<span class="fc" id="L279">                String line = parserState.getNextLine();</span>
<span class="fc" id="L280">                Matcher matcher = isSingletonPattern.matcher(line);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L282">                    throw new IOException(&quot;invalid asm file: could not parse AFG singlton status: &quot;+line);</span>
                }
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                return Integer.parseInt(matcher.group(1).trim())==1;</span>
            }
            
        },
<span class="fc" id="L288">        MATE_PAIR(&quot;AMP&quot;){</span>
<span class="fc" id="L289">            private final Pattern frgIdPattern = Pattern.compile(&quot;frg:(\\S+)&quot;);</span>
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor)
                    throws IOException {
<span class="nc" id="L293">                String id1 = parseReadId(parserState);</span>
<span class="nc" id="L294">                String id2 = parseReadId(parserState);</span>
<span class="nc" id="L295">                MateStatus mateStatus = parseMateStatus(parserState);</span>
<span class="nc" id="L296">                parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="nc" id="L297">                visitor.visitMatePair(id1, id2, mateStatus);</span>
                
<span class="nc" id="L299">            }</span>
            private String parseReadId(ParserState parserState) throws IOException {
<span class="nc" id="L301">                String line = parserState.getNextLine();</span>
<span class="nc" id="L302">                Matcher matcher = frgIdPattern.matcher(line);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L304">                    throw new IOException(&quot;error reading frg id :&quot;+ line);</span>
                }
<span class="nc" id="L306">                return matcher.group(1);</span>
            }
            
        },
<span class="fc" id="L310">        UNITIG(&quot;UTG&quot;){</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor)
                    throws IOException {
<span class="fc" id="L315">                IdTuple idTuple =parseIds(parserState, visitor, ACCESSION_PATTERN);</span>
<span class="fc" id="L316">                String nextLine = parserState.getNextLine();</span>
<span class="fc" id="L317">                nextLine = skipSrcBlock(parserState, nextLine);</span>
<span class="fc" id="L318">                float aStat = parseAStat(nextLine);</span>
<span class="fc" id="L319">                nextLine = parserState.getNextLine();</span>
                //measure of polymorphism
                //was introduced in CA 6
                //looks like older versions
                //had this value inside the src field
                final float polymorphism;
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                if(nextLine.startsWith(&quot;mhp&quot;)){</span>
<span class="fc" id="L326">                    polymorphism = parsePolymorphismMeasure(nextLine);</span>
<span class="fc" id="L327">                    nextLine = parserState.getNextLine();</span>
                }else{
<span class="nc" id="L329">                    polymorphism = Float.NaN;</span>
                }
<span class="fc" id="L331">                UnitigStatus status = parseUnitigStatus(nextLine);</span>
<span class="fc" id="L332">                nextLine = parserState.getNextLine();</span>
                //skip legacy branch point lines
                //which don't exist in newer versions of CA
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                if(nextLine.startsWith(&quot;abp&quot;)){</span>
                    //skip bbp as well
<span class="nc" id="L337">                   parserState.getNextLine();</span>
<span class="nc" id="L338">                   parserState.getNextLine();</span>
                }
               
<span class="fc" id="L341">                int length = parseLength(nextLine);</span>
<span class="fc" id="L342">                NucleotideSequence consensus = parseConsensus(parserState, length);</span>
<span class="fc" id="L343">                QualitySequence consensusQualities = parseConsensusQualities(parserState,length);</span>
                //skip forced line
<span class="fc" id="L345">                parserState.getNextLine();</span>
<span class="fc" id="L346">                long numberOfReads = parseNumberOfReads(parserState);</span>
<span class="fc" id="L347">                CallBack callback = parserState.createCallback();</span>
<span class="fc" id="L348">                AsmUnitigVisitor asmUnitigVisitor =visitor.visitUnitig(callback, idTuple.externalId, idTuple.internalId, aStat,</span>
                        polymorphism, status, consensus, consensusQualities, numberOfReads);
                //read info is nested in each unitig
<span class="fc bfc" id="L351" title="All 4 branches covered.">                for(int i=0; parserState.keepParsing() &amp;&amp; i&lt;numberOfReads; i++){</span>
<span class="fc" id="L352">                    String readHeader = parserState.getNextLine();</span>
<span class="fc" id="L353">                    Matcher matcher = MESSAGE_HEADER_PATTERN.matcher(readHeader);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                    if(!matcher.find()){</span>
<span class="nc" id="L355">                        throw new IOException(</span>
<span class="nc" id="L356">                                String.format(&quot;error reading read # %d for unitig %s; invalid header :%s&quot;,</span>
<span class="nc" id="L357">                                        i,idTuple.externalId,readHeader));</span>
                    }
<span class="fc" id="L359">                    String code = matcher.group(1);</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                    if(!ReadMapping.INSTANCE.canHandle(code)){</span>
<span class="nc" id="L361">                        throw new IOException(</span>
<span class="nc" id="L362">                                String.format(&quot;error reading read # %d for unitig %s; invalid header code :%s&quot;,</span>
<span class="nc" id="L363">                                        i,idTuple.externalId,code));</span>
                    
                    }
<span class="fc" id="L366">                    ReadMapping.INSTANCE.handleReadLayout(parserState, asmUnitigVisitor);</span>
                }
<span class="fc bfc" id="L368" title="All 2 branches covered.">                if(asmUnitigVisitor !=null){</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">                	if(parserState.keepParsing()){</span>
<span class="fc" id="L370">		                parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="fc" id="L371">		                asmUnitigVisitor.visitEnd();</span>
	                }else{
<span class="nc" id="L373">	                	asmUnitigVisitor.halted();</span>
	                }
                }
<span class="fc" id="L376">            }</span>
           
           

            private UnitigStatus parseUnitigStatus(String line) throws IOException {
<span class="fc" id="L381">                Matcher matcher = STATUS_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L383">                    throw new IOException(&quot;error parsing unitig status : &quot;+ line);</span>
                }
<span class="fc" id="L385">                return UnitigStatus.parseUnitigStatus(matcher.group(1));</span>
            }

            private float parseAStat(String line) throws IOException {
<span class="fc" id="L389">                Matcher matcher = A_STAT_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L391">                    throw new IOException(&quot;error reading unitig coverage a stat:&quot;+ line);</span>
                }
<span class="fc" id="L393">                return Float.parseFloat(matcher.group(1));</span>
            }
            
            private float parsePolymorphismMeasure(String line) throws IOException {
<span class="fc" id="L397">                Matcher matcher = POLYMORPHISM_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L399">                    throw new IOException(&quot;error reading unitig polymorphism measure:&quot;+ line);</span>
                }
<span class="fc" id="L401">                return Float.parseFloat(matcher.group(1));</span>
            }
            
            

            
            
        },
        
<span class="fc" id="L410">        UNITIG_LINK(&quot;ULK&quot;){</span>
<span class="fc" id="L411">            private final Pattern unitigIdPattern = Pattern.compile(&quot;ut\\d:(\\S+)&quot;);</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor) throws IOException{
<span class="nc" id="L415">                handle(parserState, visitor,true);</span>
<span class="nc" id="L416">            }</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor, boolean shouldParse)
                    throws IOException {
<span class="nc" id="L421">                parseLinkMessage(parserState, visitor, shouldParse, unitigIdPattern);</span>
<span class="nc" id="L422">            }</span>
            @Override
            protected void visitLink(AsmVisitor visitor, String unitig1,
                    String unitig2, LinkOrientation orientation,
                    OverlapType overlapType, boolean isPossibleChimera,
                    float mean, float stdDev, int numberOfContributingEdges,
                    OverlapStatus status, Set&lt;MatePairEvidence&gt; evidenceList) {
<span class="nc" id="L429">                visitor.visitUnitigLink(unitig1, unitig2, orientation, overlapType, status, </span>
                        isPossibleChimera, numberOfContributingEdges, mean, stdDev, evidenceList);
<span class="nc" id="L431">            }</span>
            
            
            
        },
<span class="fc" id="L436">        CONTIG(&quot;CCO&quot;){</span>
<span class="fc" id="L437">            private final Pattern degeneratePattern = Pattern.compile(&quot;pla:(\\S)&quot;);</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor)
                    throws IOException {
<span class="fc" id="L442">                IdTuple idTuple =parseIds(parserState, visitor, ACCESSION_PATTERN);</span>
<span class="fc" id="L443">                boolean isDegenerate = parseIsDegenerateFlag(parserState, visitor);</span>
<span class="fc" id="L444">                String lengthLine = parserState.getNextLine();</span>
<span class="fc" id="L445">                int length = parseLength(lengthLine);</span>
<span class="fc" id="L446">                NucleotideSequence consensus = parseConsensus(parserState, length);</span>
<span class="fc" id="L447">                QualitySequence consensusQualities = parseConsensusQualities(parserState,length);</span>
                //skip forced line
<span class="fc" id="L449">                parserState.getNextLine();</span>
<span class="fc" id="L450">                long numberOfReads = parseNumberOfReads(parserState);</span>
<span class="fc" id="L451">                long numberOfUnitigs = parseNumberOfReads(parserState);</span>
<span class="fc" id="L452">                long numberOfVariants = parseNumberOfReads(parserState);</span>
<span class="fc" id="L453">                CallBack callback = parserState.createCallback();</span>
<span class="fc" id="L454">                AsmContigVisitor contigVisitor =visitor.visitContig(callback, idTuple.externalId, idTuple.internalId, isDegenerate, </span>
									                        consensus, consensusQualities, 
									                        numberOfReads, numberOfUnitigs, numberOfVariants);
<span class="fc bfc" id="L457" title="All 2 branches covered.">                if(!parserState.keepParsing()){</span>
<span class="fc" id="L458">                	return;</span>
                }
<span class="fc bfc" id="L460" title="All 2 branches covered.">                if(contigVisitor ==null){</span>
                	//skip everything
<span class="fc" id="L462">                	long allSubBlocks = numberOfVariants + numberOfReads + numberOfUnitigs;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">                	for(long i=0; i&lt;allSubBlocks; i++){</span>
<span class="fc" id="L464">                        skipCurrentBlock(parserState);</span>
                    }                	
<span class="fc" id="L466">                }else{</span>
<span class="pc bpc" id="L467" title="2 of 4 branches missed.">                	for(long i=0; parserState.keepParsing() &amp;&amp; i&lt;numberOfVariants; i++){</span>
<span class="nc" id="L468">                        String variantHeader = parserState.getNextLine();</span>
<span class="nc" id="L469">                        String messageCode = parseMessageCode(variantHeader);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                        if(!ContigVariant.INSTANCE.canHandle(messageCode)){</span>
<span class="nc" id="L471">                            throw new IOException(&quot;invalid variant block start : &quot;+ variantHeader);</span>
                        }
<span class="nc" id="L473">                        ContigVariant.INSTANCE.handle(parserState, contigVisitor);</span>
                    }
                	
<span class="pc bpc" id="L476" title="1 of 4 branches missed.">                	for(long i=0; parserState.keepParsing() &amp;&amp; i&lt;numberOfReads; i++){</span>
<span class="fc" id="L477">                        String readHeader = parserState.getNextLine();</span>
<span class="fc" id="L478">                        String messageCode = parseMessageCode(readHeader);</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">                        if(!ReadMapping.INSTANCE.canHandle(messageCode)){</span>
<span class="nc" id="L480">                            throw new IOException(&quot;invalid read mapping block start : &quot;+ readHeader);</span>
                        }
<span class="fc" id="L482">                        ReadMapping.INSTANCE.handleReadLayout(parserState, contigVisitor);</span>
                    }
                	
<span class="pc bpc" id="L485" title="1 of 4 branches missed.">                	for(long i=0; parserState.keepParsing() &amp;&amp; i&lt;numberOfUnitigs; i++){</span>
<span class="fc" id="L486">                        String unitigHeader = parserState.getNextLine();</span>
<span class="fc" id="L487">                        String messageCode = parseMessageCode(unitigHeader);</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                        if(!ContigUnitigMapping.INSTANCE.canHandle(messageCode)){</span>
<span class="nc" id="L489">                            throw new IOException(&quot;invalid unitig mapping block start : &quot;+ unitigHeader);</span>
                        }
<span class="fc" id="L491">                        ContigUnitigMapping.INSTANCE.handle(parserState, contigVisitor);</span>
                    }
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">                	if(parserState.keepParsing()){</span>
<span class="fc" id="L494">	                	 parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="fc" id="L495">	                	 contigVisitor.visitEnd();</span>
                	}else{
<span class="nc" id="L497">                		contigVisitor.halted();</span>
                	}
                }
                
                
               
                
<span class="fc" id="L504">            }</span>

            private boolean parseIsDegenerateFlag(ParserState parserState,
                    AsmVisitor visitor) throws IOException {
<span class="fc" id="L508">                String line = parserState.getNextLine();</span>
<span class="fc" id="L509">                Matcher matcher = degeneratePattern.matcher(line);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L511">                    throw new IOException(&quot;error reading contig placement status (degenerate flag):&quot;+ line);</span>
                }
                //P is placed in a scaffold (maybe even a scaffold of just this contig
                //U is unplaced i.e. degenerate
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">                return matcher.group(1).charAt(0)=='U';</span>
            }
            
        },
        
        
<span class="fc" id="L521">        CONTIG_LINK(&quot;CLK&quot;){</span>
<span class="fc" id="L522">            private final Pattern contigIdPattern = Pattern.compile(&quot;co\\d:(\\S+)&quot;);</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor) throws IOException{
<span class="nc" id="L526">                handle(parserState, visitor,true);</span>
<span class="nc" id="L527">            }</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor, boolean shouldParse)
                    throws IOException {
<span class="nc" id="L532">                parseLinkMessage(parserState, visitor, shouldParse, contigIdPattern);</span>
<span class="nc" id="L533">            }</span>
            @Override
            protected void visitLink(AsmVisitor visitor, String id1,
                    String id2, LinkOrientation orientation,
                    OverlapType overlapType, boolean isPossibleChimera,
                    float mean, float stdDev, int numberOfContributingEdges,
                    OverlapStatus status, Set&lt;MatePairEvidence&gt; evidenceList) {
<span class="nc" id="L540">                visitor.visitContigLink(id1, id2, orientation, overlapType, status, </span>
                        numberOfContributingEdges, mean, stdDev, evidenceList);
<span class="nc" id="L542">            }</span>
            
        },
<span class="fc" id="L545">        SCAFFOLD_LINK(&quot;SLK&quot;){</span>
<span class="fc" id="L546">            private final Pattern scaffoldIdPattern = Pattern.compile(&quot;sc\\d:(\\S+)&quot;);</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor) throws IOException{
<span class="nc" id="L550">                handle(parserState, visitor,true);</span>
<span class="nc" id="L551">            }</span>
            
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor, boolean shouldParse)
                    throws IOException {
<span class="nc" id="L556">                parseLinkMessage(parserState, visitor, shouldParse, scaffoldIdPattern);</span>
<span class="nc" id="L557">            }</span>
            @Override
            protected void visitLink(AsmVisitor visitor, String id1,
                    String id2, LinkOrientation orientation,
                    OverlapType overlapType, boolean isPossibleChimera,
                    float mean, float stdDev, int numberOfContributingEdges,
                    OverlapStatus status, Set&lt;MatePairEvidence&gt; evidenceList) {
<span class="nc" id="L564">                visitor.visitScaffoldLink(id1, id2, orientation, overlapType, status, </span>
                        numberOfContributingEdges, mean, stdDev, evidenceList);
<span class="nc" id="L566">            }</span>
            
        },
        /**
         * Handles scaffold messages &lt;strong&gt;and&lt;/strong&gt;
         * nested contig link messages since
         * there are different kinds of links depending 
         * on the number of contigs in the scaffold.
         */
<span class="fc" id="L575">        SCAFFOLD(&quot;SCF&quot;){</span>
<span class="fc" id="L576">            final Pattern numPairsPattern = Pattern.compile(&quot;noc:(\\d+)&quot;);</span>
<span class="fc" id="L577">            final Pattern contigIdPattern = Pattern.compile(&quot;ct\\d:(\\S+)&quot;);</span>
            @Override
            protected void handle(ParserState parserState, AsmVisitor visitor)
                    throws IOException {
<span class="fc" id="L581">            	CallBack callback = parserState.createCallback();</span>
<span class="fc" id="L582">                IdTuple idTuple = parseIds(parserState, visitor, ACCESSION_PATTERN);</span>
<span class="fc" id="L583">                int numberOfContigPairs = parseNumberOfContigPairs(parserState);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if(numberOfContigPairs==0){</span>
                    //only 1 contig
<span class="fc" id="L586">                    handleSingleContig(callback, parserState, idTuple,visitor);</span>
                }else{
                	
<span class="nc" id="L589">                	AsmScaffoldVisitor scaffoldVisitor = visitor.visitScaffold(callback, idTuple.externalId, idTuple.internalId, numberOfContigPairs);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                    if(scaffoldVisitor !=null){</span>
<span class="nc bnc" id="L591" title="All 4 branches missed.">	                    for(int i=0; parserState.keepParsing() &amp;&amp; i&lt; numberOfContigPairs; i++){</span>
<span class="nc" id="L592">	                        handleContigPairs(parserState, scaffoldVisitor);</span>
	                    }
<span class="nc bnc" id="L594" title="All 2 branches missed.">	                    if(parserState.keepParsing()){</span>
<span class="nc" id="L595">	                    	parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="nc" id="L596">	                    	scaffoldVisitor.visitEnd();</span>
	                    }else{
<span class="nc" id="L598">	                    	scaffoldVisitor.halted();</span>
	                    }
                    }
                }
<span class="fc" id="L602">            }</span>
            
            private void handleSingleContig(CallBack callback, ParserState parserState,IdTuple idTuple,
            		AsmVisitor visitor) throws IOException {
<span class="fc" id="L606">                parsePairStart(parserState);</span>
<span class="fc" id="L607">                String contigId = parseContigId(parserState);</span>
                //ids should be the same
<span class="fc" id="L609">                String duplicateId = parseContigId(parserState);</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                if(!contigId.equals(duplicateId)){</span>
<span class="nc" id="L611">                    throw new IOException(</span>
<span class="nc" id="L612">                            String.format(</span>
                        		&quot;invalid single contig scaffold, contig ids ct1 and ct2 should be identical %s vs %s&quot;,
                            		contigId, duplicateId));
                }
                //only 1 contig mean, stddev and ori should be ignored
<span class="fc" id="L617">                parserState.getNextLine();</span>
<span class="fc" id="L618">                parserState.getNextLine();</span>
<span class="fc" id="L619">                parserState.getNextLine();</span>
<span class="fc" id="L620">                parseEndOfMessage(parserState, this.getMessageCode());</span>
<span class="fc" id="L621">                visitor.visitScaffold(callback, idTuple.externalId,idTuple.internalId,contigId);</span>
                
<span class="fc" id="L623">            }</span>

            private void handleContigPairs(ParserState parserState,
            		AsmScaffoldVisitor scaffoldVisitor) throws IOException {
<span class="nc" id="L627">                parsePairStart(parserState);</span>
<span class="nc" id="L628">                String contigId1 = parseContigId(parserState); </span>
<span class="nc" id="L629">                String contigId2 = parseContigId(parserState);                </span>
<span class="nc" id="L630">                float mean = parseMeanEdgeDistance(parserState);</span>
<span class="nc" id="L631">                float stdDev = parseStdDevDistance(parserState);</span>
<span class="nc" id="L632">                LinkOrientation orientation = getLinkOrientation(parserState);</span>
                
<span class="nc" id="L634">                parseEndOfMessage(parserState, this.getMessageCode());                </span>
<span class="nc" id="L635">                scaffoldVisitor.visitContigPair(contigId1, contigId2, mean, stdDev, orientation);</span>
                
<span class="nc" id="L637">            }</span>
            private int parseNumberOfContigPairs(ParserState parserState) throws IOException {
<span class="fc" id="L639">                String line = parserState.getNextLine();</span>
<span class="fc" id="L640">                Matcher matcher = numPairsPattern.matcher(line);</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L642">                    throw new IOException(&quot;error parsing number of contig pairs : &quot;+ line);</span>
                }
<span class="fc" id="L644">                return Integer.parseInt(matcher.group(1));</span>
            }
            
            private String parseContigId(ParserState parserState) throws IOException{
<span class="fc" id="L648">                String line = parserState.getNextLine();</span>
<span class="fc" id="L649">                Matcher matcher = contigIdPattern.matcher(line);</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L651">                    throw new IOException(&quot;error contig id :&quot;+ line);</span>
                }
<span class="fc" id="L653">                return matcher.group(1);</span>
            }
            
            private void parsePairStart(ParserState parserState) throws IOException {
<span class="fc" id="L657">                String line = parserState.getNextLine();</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">                if(!line.startsWith(&quot;{CTP&quot;)){</span>
<span class="nc" id="L659">                    throw new IOException(&quot;error parsing contig pair header : &quot;+ line);</span>
                }
<span class="fc" id="L661">            }</span>
            
        },
        
        ;
        
        
        private final String messageCode;
<span class="fc" id="L669">        static Pattern MESSAGE_HEADER_PATTERN = Pattern.compile(&quot;\\{(\\S+)&quot;);</span>
<span class="fc" id="L670">        static final Pattern MATE_STATUS_PATTERN = Pattern.compile(&quot;mst:(\\S)&quot;);</span>
<span class="fc" id="L671">        static final Pattern ACCESSION_PATTERN = Pattern.compile(&quot;acc:\\((\\S+),(\\d+)\\)&quot;);</span>
<span class="fc" id="L672">        static final Pattern MEAN_PATTERN = Pattern.compile(&quot;mea:(\\S+)&quot;);</span>
<span class="fc" id="L673">        static final Pattern STD_DEV_PATTERN = Pattern.compile(&quot;std:(\\S+)&quot;);</span>
        
<span class="fc" id="L675">        static final Pattern A_STAT_PATTERN = Pattern.compile(&quot;cov:(\\S+)&quot;);</span>
<span class="fc" id="L676">        static final Pattern POLYMORPHISM_PATTERN = Pattern.compile(&quot;mhp:(\\S+)&quot;);</span>
<span class="fc" id="L677">        static final Pattern STATUS_PATTERN = Pattern.compile(&quot;sta:(\\S)&quot;);</span>
        
        
<span class="fc" id="L680">        final Pattern linkOrientationPattern = Pattern.compile(&quot;ori:(\\S)&quot;);</span>
<span class="fc" id="L681">        final Pattern overlapTypePattern = Pattern.compile(&quot;ovt:(\\S)&quot;);</span>
        
<span class="fc" id="L683">        final Pattern chimeraFlagPattern = Pattern.compile(&quot;ipc:(\\d)&quot;);</span>
<span class="fc" id="L684">        final Pattern numEdgesPattern = Pattern.compile(&quot;num:(\\d+)&quot;);</span>
        
<span class="fc" id="L686">        final Pattern linkStatusPattern = Pattern.compile(&quot;sta:(\\S)&quot;);</span>
<span class="fc" id="L687">        final Pattern jumpListPattern = Pattern.compile(&quot;(\\S+),(\\S+),(\\S)&quot;);</span>
        
        
       
<span class="fc" id="L691">        private AsmMessageHandler(String messageCode){</span>
<span class="fc" id="L692">            this.messageCode = messageCode;</span>
<span class="fc" id="L693">        }</span>
        
        final boolean canHandle(String messageCode){
<span class="fc" id="L696">            return this.messageCode.equals(messageCode);</span>
        }
        
        /**
         * @return the messageCode
         */
        public String getMessageCode() {
<span class="fc" id="L703">            return messageCode;</span>
        }

        public String parseMessageCode(String line){
<span class="fc" id="L707">            Matcher matcher = MESSAGE_HEADER_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">            if(matcher.find()){</span>
<span class="fc" id="L709">                return matcher.group(1);</span>
            }
<span class="nc" id="L711">            return null;</span>
        }
        protected abstract void handle(ParserState parserState, AsmVisitor visitor) throws IOException;
        
        protected void handle(ParserState parserState, AsmVisitor visitor, boolean shouldVisitRecord) throws IOException{
<span class="nc" id="L716">            handle(parserState, visitor);</span>
<span class="nc" id="L717">        }</span>
        public static void parse(ParserState parserState, AsmVisitor visitor) throws IOException{
<span class="fc bfc" id="L719" title="All 2 branches covered.">            while(parserState.hasNextLine()){</span>
<span class="fc" id="L720">            	parserState.markCurrentOffset();</span>
<span class="fc" id="L721">                String line =parserState.getNextLine();</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                if(line !=null){                    </span>
<span class="fc" id="L723">                    Matcher matcher = MESSAGE_HEADER_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">                    if(matcher.find()){</span>
<span class="fc" id="L725">                        String header = matcher.group(1);</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                        for(AsmMessageHandler handler : values()){</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                            if(handler.canHandle(header)){</span>
<span class="fc" id="L728">                                handler.handle(parserState, visitor);</span>
<span class="fc" id="L729">                                break;</span>
                            }
                        }
                    }
                }
<span class="fc" id="L734">            }</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if(parserState.keepParsing()){</span>
<span class="fc" id="L736">            	visitor.visitEnd();</span>
            }else{
<span class="fc" id="L738">            	visitor.halted();</span>
            }
<span class="fc" id="L740">        }</span>
        
        
        
        IdTuple parseIds(ParserState parserState, AsmVisitor visitor, Pattern pattern) throws IOException {
<span class="fc" id="L745">            String idLine =parserState.getNextLine();</span>
<span class="fc" id="L746">            Matcher idMatcher = pattern.matcher(idLine);</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">            if(!idMatcher.find()){</span>
<span class="nc" id="L748">                throw new IOException(&quot;invalid asm file: could not parse IDs: &quot;+idLine);</span>
            }
<span class="fc" id="L750">            return new IdTuple(idMatcher.group(1), Long.parseLong(idMatcher.group(2)));</span>
        }
       
        
        MateStatus parseMateStatus(ParserState parserState) throws IOException {
<span class="nc" id="L755">            String line = parserState.getNextLine();</span>
<span class="nc" id="L756">            Matcher matcher = MATE_STATUS_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L758">                throw new IOException(&quot;invalid asm file: could not parse &quot;+messageCode+&quot; mate status: &quot;+line);</span>
            }
<span class="nc" id="L760">            return MateStatus.parseMateStatus(matcher.group(1));</span>
        }
        
        MateStatus parseMateStatus(String line) throws IOException {
<span class="fc" id="L764">            Matcher matcher = MATE_STATUS_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L766">                throw new IOException(&quot;invalid asm file: could not parse &quot;+messageCode+&quot; mate status: &quot;+line);</span>
            }
<span class="fc" id="L768">            return MateStatus.parseMateStatus(matcher.group(1));</span>
        }
        
        
        
       
        QualitySequence parseConsensusQualities(
                ParserState parserState, int length) throws IOException {
<span class="fc" id="L776">            byte[] qualities = new byte[length];</span>
            //first line should be qlt
<span class="fc" id="L778">            String line = parserState.getNextLine();</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">            if(!line.startsWith(&quot;qlt:&quot;)){</span>
<span class="nc" id="L780">               throw new IOException(&quot;expected start quality consensus block :&quot;+line); </span>
            }
<span class="fc" id="L782">            line = parserState.getNextLine();</span>
<span class="fc" id="L783">            int offset=0;</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">            while(!line.startsWith(&quot;.&quot;)){</span>
<span class="fc" id="L785">                String trimmedLine = line.trim();</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">                for(int i=0; i&lt;trimmedLine.length(); i++){</span>
                    //qualities are encoded as value + ascii zero
<span class="fc" id="L788">                    qualities[offset+i]=(byte)(trimmedLine.charAt(i)- '0');</span>
                }
<span class="fc" id="L790">                offset +=trimmedLine.length();</span>
<span class="fc" id="L791">                line = parserState.getNextLine();</span>
<span class="fc" id="L792">            }</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">            if(offset !=length){</span>
<span class="nc" id="L794">                throw new IOException( String.format(&quot;incorrect consensus quality length for %s: expected %d but was %d&quot;,</span>
<span class="nc" id="L795">                        getMessageCode(),</span>
<span class="nc" id="L796">                        length,offset));</span>
            }
<span class="fc" id="L798">            return new QualitySequenceBuilder(qualities).build();</span>
        }
        NucleotideSequence parseConsensus(ParserState parserState,
                int expectedLength) throws IOException {
<span class="fc" id="L802">            NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder(expectedLength);</span>
<span class="fc" id="L803">            String line = parserState.getNextLine();</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">            if(!line.startsWith(&quot;cns:&quot;)){</span>
<span class="nc" id="L805">                throw new IOException(&quot;expected begin cns field but was &quot;+line );</span>
            }
<span class="fc" id="L807">            line = parserState.getNextLine();</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">            while(!line.startsWith(&quot;.&quot;)){</span>
<span class="fc" id="L809">                builder.append(line.trim());</span>
<span class="fc" id="L810">                line = parserState.getNextLine();</span>
            }
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            if(builder.getLength()!=expectedLength){</span>
<span class="nc" id="L813">                throw new IOException(</span>
<span class="nc" id="L814">                        String.format(&quot;incorrect consensus length for %s: expected %d but was %d&quot;,</span>
<span class="nc" id="L815">                                getMessageCode(),</span>
<span class="nc" id="L816">                                expectedLength,builder.getLength()));</span>
            }
<span class="fc" id="L818">            return builder.build();</span>
        }
        

        Set&lt;MatePairEvidence&gt; parseMatePairEvidence(
                int expectedNumberOfMatePairEvidenceRecords,
                ParserState parserState) throws IOException {
<span class="nc" id="L825">            Set&lt;MatePairEvidence&gt; set = new LinkedHashSet&lt;MatePairEvidence&gt;();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            for(int i=0; i&lt;expectedNumberOfMatePairEvidenceRecords; i++){</span>
<span class="nc" id="L827">                String line = parserState.getNextLine();</span>
<span class="nc" id="L828">                Matcher matcher = jumpListPattern.matcher(line);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L830">                    throw new IOException(&quot;invalid jump list record: &quot;+ line);</span>
                }
<span class="nc" id="L832">                set.add(new MatePairEvidenceImpl(matcher.group(1), matcher.group(2)));</span>
            }
<span class="nc" id="L834">            return set;</span>
        }

        OverlapStatus parseOverlapStatus(ParserState parserState) throws IOException {
<span class="nc" id="L838">            String line = parserState.getNextLine();</span>
<span class="nc" id="L839">            Matcher matcher = linkStatusPattern.matcher(line);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L841">                throw new IOException(&quot;error overlap status&quot;+ line);</span>
            }
<span class="nc" id="L843">            return OverlapStatus.parseOverlapStatus(matcher.group(1));</span>
        }

        int parseNumberOfEdges(ParserState parserState) throws IOException {
<span class="nc" id="L847">            String line = parserState.getNextLine();</span>
<span class="nc" id="L848">            Matcher matcher = numEdgesPattern.matcher(line);</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L850">                throw new IOException(&quot;error reading # of edges&quot;+ line);</span>
            }
<span class="nc" id="L852">            return Integer.parseInt(matcher.group(1));</span>
        }

        float parseMeanEdgeDistance(String nextLine) throws IOException {
<span class="nc" id="L856">            Matcher matcher = MEAN_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L858">                throw new IOException(&quot;error reading is mean edge distance message&quot;+ nextLine);</span>
            }
<span class="nc" id="L860">            return Float.parseFloat(matcher.group(1));</span>
        }
        float parseMeanEdgeDistance(ParserState parserState) throws IOException {
<span class="nc" id="L863">            String nextLine = parserState.getNextLine();</span>
<span class="nc" id="L864">            Matcher matcher = MEAN_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L866">                throw new IOException(&quot;error reading is mean edge distance message&quot;+ nextLine);</span>
            }
<span class="nc" id="L868">            return Float.parseFloat(matcher.group(1));</span>
        }
        
        float parseStdDevDistance(ParserState parserState) throws IOException {
<span class="nc" id="L872">            String line = parserState.getNextLine();</span>
<span class="nc" id="L873">            Matcher matcher = STD_DEV_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L875">                throw new IOException(&quot;error reading is std dev edge distance message&quot;+ line);</span>
            }
<span class="nc" id="L877">            return Float.parseFloat(matcher.group(1));</span>
        }

        boolean getChimeraFlag(ParserState parserState) throws IOException {
<span class="nc" id="L881">            String line = parserState.getNextLine();</span>
<span class="nc" id="L882">            Matcher matcher = chimeraFlagPattern.matcher(line);</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L884">                throw new IOException(&quot;error reading is possible chimera message&quot;+ line);</span>
            }
<span class="nc" id="L886">            int value = Integer.parseInt(matcher.group(1));</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">            return value ==1;</span>
        }

        LinkOrientation getLinkOrientation(ParserState parserState) throws IOException {
<span class="nc" id="L891">            String line = parserState.getNextLine();</span>
<span class="nc" id="L892">            Matcher matcher = linkOrientationPattern.matcher(line);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L894">                throw new IOException(&quot;error reading link orientation message&quot;+ line);</span>
            }
<span class="nc" id="L896">            return LinkOrientation.parseLinkOrientation(matcher.group(1));</span>
        }
        
        OverlapType getOverlapType(ParserState parserState) throws IOException {
<span class="nc" id="L900">            String line = parserState.getNextLine();</span>
<span class="nc" id="L901">            Matcher matcher = overlapTypePattern.matcher(line);</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L903">                throw new IOException(&quot;error reading overlap type message&quot;+ line);</span>
            }
<span class="nc" id="L905">            return OverlapType.parseOverlapType(matcher.group(1));</span>
        }
        
        String getUnitigId(Pattern idPattern, ParserState parserState) throws IOException{
<span class="nc" id="L909">            String line = parserState.getNextLine();</span>
<span class="nc" id="L910">            Matcher matcher = idPattern.matcher(line);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L912">                throw new IOException(&quot;error reading unitig link message unitig id:&quot;+ line);</span>
            }
<span class="nc" id="L914">            return matcher.group(1);</span>
        }

        void parseLinkMessage(ParserState parserState, AsmVisitor visitor,
                boolean shouldParse, Pattern idPattern) throws IOException {
<span class="nc" id="L919">            String unitig1 = getUnitigId(idPattern, parserState);</span>
<span class="nc" id="L920">            String unitig2 = getUnitigId(idPattern, parserState);</span>
<span class="nc" id="L921">            LinkOrientation orientation = getLinkOrientation(parserState);</span>
<span class="nc" id="L922">            OverlapType overlapType = getOverlapType(parserState);</span>
<span class="nc" id="L923">            boolean isPossibleChimera = getChimeraFlag(parserState);</span>
            //includes guide was removed in CA 6
<span class="nc" id="L925">            String nextLine = parserState.getNextLine();</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">            if(nextLine.startsWith(&quot;gui:&quot;)){</span>
<span class="nc" id="L927">                nextLine = parserState.getNextLine();</span>
            }
<span class="nc" id="L929">            float mean = parseMeanEdgeDistance(nextLine);</span>
<span class="nc" id="L930">            float stdDev = parseStdDevDistance(parserState);</span>
<span class="nc" id="L931">            int numberOfContributingEdges = parseNumberOfEdges(parserState);</span>
<span class="nc" id="L932">            OverlapStatus status = parseOverlapStatus(parserState);</span>
<span class="nc" id="L933">            String jumpList = parserState.getNextLine();</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">            if(!jumpList.startsWith(&quot;jls:&quot;)){</span>
<span class="nc" id="L935">                throw new IOException(&quot;invalid jump list block : &quot;+ jumpList);</span>
            }
<span class="nc" id="L937">            Set&lt;MatePairEvidence&gt; evidenceList = parseMatePairEvidence(overlapType.getExpectedNumberOfMatePairEvidenceRecords(numberOfContributingEdges), parserState);</span>
<span class="nc" id="L938">            parseEndOfMessage(parserState, messageCode);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if(shouldParse){</span>
<span class="nc" id="L940">                visitLink(visitor, unitig1, unitig2, orientation,</span>
                        overlapType, isPossibleChimera, mean, stdDev,
                        numberOfContributingEdges, status, evidenceList);
            }
<span class="nc" id="L944">        }</span>
        
        protected void visitLink(AsmVisitor visitor, String unitig1,
                String unitig2, LinkOrientation orientation,
                OverlapType overlapType, boolean isPossibleChimera,
                float mean, float stdDev, int numberOfContributingEdges,
                OverlapStatus status, Set&lt;MatePairEvidence&gt; evidenceList){
<span class="nc" id="L951">            throw new IllegalStateException(&quot;invalid state should not contain any links&quot;);</span>
        }

    }
    
<span class="pc" id="L956">    private enum ContigUnitigMapping{</span>
<span class="fc" id="L957">    	INSTANCE(&quot;UPS&quot;)</span>
    	;
    	private final String messageCode;
    	
<span class="fc" id="L961">        private final Pattern typePattern = Pattern.compile(&quot;typ:(\\S)&quot;);</span>
<span class="fc" id="L962">        private final Pattern idPattern = Pattern.compile(&quot;lid:(\\S+)&quot;);</span>
<span class="fc" id="L963">        private final Pattern rangePattern = Pattern.compile(&quot;pos:(\\d+,\\d+)&quot;);</span>
<span class="fc" id="L964">        private final Pattern numOffsetsPattern = Pattern.compile(&quot;dln:(\\d+)&quot;);</span>
        
<span class="fc" id="L966">        ContigUnitigMapping(String code){</span>
<span class="fc" id="L967">        	this.messageCode = code;</span>
<span class="fc" id="L968">        }</span>
        final boolean canHandle(String messageCode){
<span class="fc" id="L970">            return this.messageCode.equals(messageCode);</span>
        }

        protected void handle(ParserState parserState, AsmContigVisitor visitor) throws IOException {
<span class="fc" id="L974">                UnitigLayoutType type = parseUnitigLayoutType(parserState);</span>
<span class="fc" id="L975">                String readId = parseReadId(parserState);</span>
<span class="fc" id="L976">                String nextLine = parserState.getNextLine();</span>
                //CA &lt;= 5 had a src block which should be ignored
                //CA 6+ doesn't have it anymore so need to handle
                //both cases.
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">                if(nextLine.startsWith(SRC)){</span>
<span class="nc" id="L981">                    skipReservedSource(parserState);</span>
<span class="nc" id="L982">                    nextLine = parserState.getNextLine();</span>
                }
                
<span class="fc" id="L985">                DirectedRange directedRange = parseDirectedRange(nextLine);</span>
<span class="fc" id="L986">                List&lt;Long&gt; gapOffsets = parseGapOffsets(parserState);</span>
<span class="fc" id="L987">                parseEndOfMessage(parserState, messageCode);</span>
           
<span class="fc" id="L989">                visitor.visitUnitigLayout(type, readId, directedRange, gapOffsets);</span>
            
<span class="fc" id="L991">        }</span>
        private DirectedRange parseDirectedRange(String line) throws IOException {
<span class="fc" id="L993">            Matcher matcher = rangePattern.matcher(line);</span>
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L995">                throw new IOException(&quot;error reading read-to-unitig placed range:&quot;+ line);</span>
            }
<span class="fc" id="L997">            return DirectedRange.parse(matcher.group(1));</span>
        }
        private List&lt;Long&gt; parseGapOffsets(ParserState parserState) throws IOException {
<span class="fc" id="L1000">            String lengthLine = parserState.getNextLine();</span>
<span class="fc" id="L1001">            Matcher matcher = numOffsetsPattern.matcher(lengthLine);</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1003">                throw new IOException(&quot;error reading read-to-unitig delta encoding length:&quot;+ lengthLine);</span>
            }
<span class="fc" id="L1005">            int expectedNumberOfOffsets = Integer.parseInt(matcher.group(1));</span>
<span class="fc" id="L1006">            String beginDeltaEncodingLine = parserState.getNextLine();</span>
<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">            if(!beginDeltaEncodingLine.startsWith(&quot;del:&quot;)){</span>
<span class="nc" id="L1008">                throw new IOException(&quot;error reading read-to-unitig delta encoding:&quot;+ beginDeltaEncodingLine);</span>
            }
<span class="fc" id="L1010">            List&lt;Long&gt; offsets = new ArrayList&lt;Long&gt;(expectedNumberOfOffsets);</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">            while(offsets.size()&lt;expectedNumberOfOffsets){</span>
<span class="fc" id="L1012">                String offsetLine = parserState.getNextLine();</span>
                //TODO Scanner is so slow use different implementation?
<span class="fc" id="L1014">                Scanner scanner = new Scanner(offsetLine);</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">                if(!scanner.hasNextLong()){</span>
<span class="nc" id="L1016">                    throw new IOException(&quot;error reading read-to-unitig delta encoding not enough values :&quot;+ offsetLine);</span>
                    
                }
<span class="fc bfc" id="L1019" title="All 2 branches covered.">                while(scanner.hasNextLong()){</span>
<span class="fc" id="L1020">                    offsets.add(scanner.nextLong());</span>
                }
<span class="fc" id="L1022">            }</span>
<span class="fc" id="L1023">            return offsets;</span>
        }
        private String parseReadId(ParserState parserState) throws IOException {
<span class="fc" id="L1026">            String line = parserState.getNextLine();</span>
<span class="fc" id="L1027">            Matcher matcher = idPattern.matcher(line);</span>
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1029">                throw new IOException(&quot;error reading read-to-unitig read id:&quot;+ line);</span>
            }
<span class="fc" id="L1031">            return matcher.group(1);</span>
        }
        private UnitigLayoutType parseUnitigLayoutType(ParserState parserState) throws IOException {
<span class="fc" id="L1034">            String line = parserState.getNextLine();</span>
<span class="fc" id="L1035">            Matcher matcher = typePattern.matcher(line);</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1037">                throw new IOException(&quot;error reading unitig-to-contig mapping type:&quot;+ line);</span>
            }
<span class="fc" id="L1039">            return UnitigLayoutType.parseUnitigLayoutType(matcher.group(1));</span>
        }
    }
    
    
<span class="nc" id="L1044">    private enum ContigVariant{</span>
<span class="nc" id="L1045">    	INSTANCE(&quot;VAR&quot;);</span>
    	
    	private final String messageCode;
<span class="nc" id="L1048">    	 final Pattern positionPattern = Pattern.compile(&quot;pos:(\\d+,\\d+)&quot;);</span>
<span class="nc" id="L1049">         final Pattern anchorPattern = Pattern.compile(&quot;anc:(\\d+)&quot;);</span>
<span class="nc" id="L1050">         final Pattern variantIdPattern = Pattern.compile(&quot;vid:(\\d+)&quot;);</span>
<span class="nc" id="L1051">         final Pattern phasePattern = Pattern.compile(&quot;pid:(\\S+)&quot;);</span>
         
<span class="nc" id="L1053">    	ContigVariant(String code){</span>
<span class="nc" id="L1054">    		this.messageCode = code;</span>
<span class="nc" id="L1055">    	}</span>
           
    	 final boolean canHandle(String messageCode){
<span class="nc" id="L1058">             return this.messageCode.equals(messageCode);</span>
         }
             protected void handle(ParserState parserState, AsmContigVisitor contigVisitor) throws IOException {
<span class="nc" id="L1061">                Range position = parseVariantPosition(parserState);</span>
<span class="nc" id="L1062">                long numberOfReads = parseNumberOfReads(parserState);</span>
                //Java is limited to signed int
                //throw exception in unlikely even that we have 2^15 coverage.                
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                if(numberOfReads &gt; Integer.MAX_VALUE){</span>
<span class="nc" id="L1066">                	throw new NumberFormatException(&quot;too many reads in variant must be &lt; Integer.MAX_VALUE&quot;);</span>
                }
<span class="nc" id="L1068">                long numberOfVariants = parseNumberOfVariants(parserState);</span>
                //Java is limited to signed int
                //throw exception in unlikely even that we have 2^15 different variants.                
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                if(numberOfVariants &gt; Integer.MAX_VALUE){</span>
<span class="nc" id="L1072">                	throw new NumberFormatException(&quot;too many variants must be &lt; Integer.MAX_VALUE&quot;);</span>
                }
<span class="nc" id="L1074">                long anchorSize = parseAnchorSize(parserState);</span>
                //skip length?
<span class="nc" id="L1076">                parseLength(parserState);</span>
<span class="nc" id="L1077">                long variantId = parseVariantId(parserState);</span>
<span class="nc" id="L1078">                long phasedVariantId = parsePhasedVariantId(parserState);</span>
<span class="nc" id="L1079">                String[] contributingReadCountString = SPLIT_ON_SLASH.split(parseContributingReadcountString(parserState));</span>
<span class="nc" id="L1080">                String[] weightString = SPLIT_ON_SLASH.split(parseWeightString(parserState));</span>
<span class="nc" id="L1081">                String[] sequencesString = SPLIT_ON_SLASH.split(parseSequencesString(parserState));</span>
<span class="nc" id="L1082">                String supportingReadIds = parseSupportingReadsString(parserState);</span>
<span class="nc" id="L1083">                List&lt;Long&gt; readIds = new ArrayList&lt;Long&gt;((int)numberOfReads);                </span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                for(String id : SPLIT_ON_SLASH.split(supportingReadIds)){</span>
<span class="nc" id="L1085">                    readIds.add(Long.parseLong(id.trim()));</span>
                }
                
<span class="nc" id="L1088">                parseEndOfMessage(parserState, messageCode);</span>
                
<span class="nc" id="L1090">                SortedSet&lt;VariantRecord&gt; variantRecords = new TreeSet&lt;VariantRecord&gt;();</span>
<span class="nc" id="L1091">                int readCounter=0;</span>
<span class="nc" id="L1092">                int numberOfVariantsAsInt = (int)numberOfVariants;</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">                for(int i=0; i &lt; numberOfVariantsAsInt; i++){</span>
<span class="nc" id="L1094">                    int numContributingReads = Integer.parseInt(contributingReadCountString[i].trim());</span>
<span class="nc" id="L1095">                    int weight = Integer.parseInt(weightString[i].trim());</span>
<span class="nc" id="L1096">                    NucleotideSequence seq = new NucleotideSequenceBuilder(sequencesString[i]).build();</span>
<span class="nc" id="L1097">                    List&lt;Long&gt; reads = readIds.subList(readCounter, readCounter+numContributingReads);</span>
<span class="nc" id="L1098">                    variantRecords.add(new VariantRecordImpl(reads, seq, weight));</span>
<span class="nc" id="L1099">                    readCounter+=numContributingReads;</span>
                }
<span class="nc" id="L1101">                contigVisitor.visitVariance(position, numberOfReads, anchorSize, </span>
                        variantId, phasedVariantId, 
                        variantRecords);
                
<span class="nc" id="L1105">             }</span>
            
            private String parseContributingReadcountString(
                    ParserState parserState) throws IOException {
<span class="nc" id="L1109">                return parseVariantBlock(parserState, &quot;nra:&quot;);</span>
            }
            private String parseWeightString(ParserState parserState) throws IOException {
<span class="nc" id="L1112">                return parseVariantBlock(parserState, &quot;wgt:&quot;);</span>
            }
            private String parseSequencesString(ParserState parserState) throws IOException {
<span class="nc" id="L1115">                return parseVariantBlock(parserState, &quot;seq:&quot;);</span>
            }
            private String parseSupportingReadsString(ParserState parserState) throws IOException {
<span class="nc" id="L1118">                return parseVariantBlock(parserState, &quot;rid:&quot;);</span>
            }
            private String parseVariantBlock(ParserState parserState, String expectedBlockStart) throws IOException{
<span class="nc" id="L1121">                String line = parserState.getNextLine();</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                if(!line.startsWith(expectedBlockStart)){</span>
<span class="nc" id="L1123">                    throw new IOException(&quot;invalid start of variants block section : &quot;+ line);</span>
                }
<span class="nc" id="L1125">                String value = parserState.getNextLine();</span>
<span class="nc" id="L1126">                String endBlock = parserState.getNextLine();</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                if(!endBlock.startsWith(&quot;.&quot;)){</span>
<span class="nc" id="L1128">                    throw new IOException(&quot;invalid end of variant block section : &quot;+ endBlock);</span>
                }
<span class="nc" id="L1130">                return value;</span>
            }
            private long parseNumberOfVariants(ParserState parserState) throws IOException {
                // delegate to parse number of reads since the pattern
                //is close enough, this method name is just
                //to avoid confusion/ make it intent revealing
<span class="nc" id="L1136">                return parseNumberOfReads(parserState);</span>
            }
            private Range parseVariantPosition(ParserState parserState) throws IOException {
<span class="nc" id="L1139">                String line = parserState.getNextLine();</span>
<span class="nc" id="L1140">                Matcher matcher = positionPattern.matcher(line);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L1142">                    throw new IOException(&quot;error reading variant record position:&quot;+ line);</span>
                }
<span class="nc" id="L1144">                return Range.parseRange(matcher.group(1), CoordinateSystem.SPACE_BASED);</span>
            }
            private long parseAnchorSize(ParserState parserState) throws IOException {
<span class="nc" id="L1147">                String line = parserState.getNextLine();</span>
<span class="nc" id="L1148">                Matcher matcher = anchorPattern.matcher(line);</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L1150">                    throw new IOException(&quot;error reading variant anchor size:&quot;+ line);</span>
                }
<span class="nc" id="L1152">                return Long.parseLong(matcher.group(1));</span>
            }
            private long parseVariantId(ParserState parserState) throws IOException {
<span class="nc" id="L1155">                String line = parserState.getNextLine();</span>
<span class="nc" id="L1156">                Matcher matcher = variantIdPattern.matcher(line);</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L1158">                    throw new IOException(&quot;error reading variant id&quot;+ line);</span>
                }
<span class="nc" id="L1160">                return Long.parseLong(matcher.group(1));</span>
            }
            private long parsePhasedVariantId(ParserState parserState) throws IOException {
<span class="nc" id="L1163">                String line = parserState.getNextLine();</span>
<span class="nc" id="L1164">                Matcher matcher = phasePattern.matcher(line);</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                if(!matcher.find()){</span>
<span class="nc" id="L1166">                    throw new IOException(&quot;error reading variant id&quot;+ line);</span>
                }
<span class="nc" id="L1168">                return Long.parseLong(matcher.group(1));</span>
            }
        }
    
    
<span class="pc" id="L1173">    private enum ReadMapping{</span>
<span class="fc" id="L1174">    	INSTANCE(&quot;MPS&quot;);</span>
    	
    	private final String messageCode;
<span class="fc" id="L1177">    	ReadMapping(String code){</span>
<span class="fc" id="L1178">    		this.messageCode = code;</span>
<span class="fc" id="L1179">    	}</span>
    
<span class="fc" id="L1181">        private final Pattern typePattern = Pattern.compile(&quot;typ:(\\S)&quot;);</span>
<span class="fc" id="L1182">        private final Pattern readIdPattern = Pattern.compile(&quot;mid:(\\S+)&quot;);</span>
<span class="fc" id="L1183">        private final Pattern rangePattern = Pattern.compile(&quot;pos:(\\d+,\\d+)&quot;);</span>
<span class="fc" id="L1184">        private final Pattern numOffsetsPattern = Pattern.compile(&quot;dln:(\\d+)&quot;);</span>
        
        final boolean canHandle(String messageCode){
<span class="fc" id="L1187">            return this.messageCode.equals(messageCode);</span>
        }
   
        public void handleReadLayout(ParserState parserState, AsmUnitigVisitor visitor) throws IOException {
<span class="fc bfc" id="L1191" title="All 2 branches covered.">            if(visitor ==null){</span>
<span class="fc" id="L1192">            	skipCurrentBlock(parserState);</span>
            }else{                
<span class="fc" id="L1194">                char type = parseReadType(parserState);</span>
<span class="fc" id="L1195">                String readId = parseReadId(parserState);</span>
<span class="fc" id="L1196">                String nextLine = parserState.getNextLine();</span>
                //CA &lt;= 5 had a src block which should be ignored
                //CA 6+ doesn't have it anymore so need to handle
                //both cases.
<span class="pc bpc" id="L1200" title="1 of 2 branches missed.">                if(nextLine.startsWith(SRC)){</span>
<span class="nc" id="L1201">                    skipReservedSource(parserState);</span>
<span class="nc" id="L1202">                    nextLine = parserState.getNextLine();</span>
                }
                
<span class="fc" id="L1205">                DirectedRange directedRange = parseDirectedRange(nextLine);</span>
<span class="fc" id="L1206">                List&lt;Integer&gt; gapOffsets = parseGapOffsets(parserState);</span>
<span class="fc" id="L1207">                parseEndOfMessage(parserState, messageCode);                   </span>
<span class="fc" id="L1208">                visitor.visitReadLayout(type, readId, directedRange, gapOffsets);</span>
            }
<span class="fc" id="L1210">        }</span>
        
        public void handleReadLayout(ParserState parserState, AsmContigVisitor visitor) throws IOException {
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">            if(visitor ==null){</span>
<span class="nc" id="L1214">            	 skipCurrentBlock(parserState);</span>
            }else{
<span class="fc" id="L1216">            	 char type = parseReadType(parserState);</span>
<span class="fc" id="L1217">                 String readId = parseReadId(parserState);</span>
<span class="fc" id="L1218">                 String nextLine = parserState.getNextLine();</span>
                 //CA &lt;= 5 had a src block which should be ignored
                 //CA 6+ doesn't have it anymore so need to handle
                 //both cases.
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">                 if(nextLine.startsWith(SRC)){</span>
<span class="nc" id="L1223">                     skipReservedSource(parserState);</span>
<span class="nc" id="L1224">                     nextLine = parserState.getNextLine();</span>
                 }
                 
<span class="fc" id="L1227">                 DirectedRange directedRange = parseDirectedRange(nextLine);</span>
<span class="fc" id="L1228">                 List&lt;Integer&gt; gapOffsets = parseGapOffsets(parserState);</span>
<span class="fc" id="L1229">                 parseEndOfMessage(parserState, messageCode);                   </span>
<span class="fc" id="L1230">                 visitor.visitReadLayout(type, readId, directedRange, gapOffsets);               </span>
            }
<span class="fc" id="L1232">        }</span>
        private DirectedRange parseDirectedRange(String line) throws IOException {
<span class="fc" id="L1234">            Matcher matcher = rangePattern.matcher(line);</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1236">                throw new IOException(&quot;error reading read-to-unitig placed range:&quot;+ line);</span>
            }
<span class="fc" id="L1238">            return DirectedRange.parse(matcher.group(1));</span>
        }
        private List&lt;Integer&gt; parseGapOffsets(ParserState parserState) throws IOException {
<span class="fc" id="L1241">            String lengthLine = parserState.getNextLine();</span>
<span class="fc" id="L1242">            Matcher matcher = numOffsetsPattern.matcher(lengthLine);</span>
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1244">                throw new IOException(&quot;error reading read-to-unitig delta encoding length:&quot;+ lengthLine);</span>
            }
<span class="fc" id="L1246">            int expectedNumberOfOffsets = Integer.parseInt(matcher.group(1));</span>
<span class="fc" id="L1247">            String beginDeltaEncodingLine = parserState.getNextLine();</span>
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">            if(!beginDeltaEncodingLine.startsWith(&quot;del:&quot;)){</span>
<span class="nc" id="L1249">                throw new IOException(&quot;error reading read-to-unitig delta encoding:&quot;+ beginDeltaEncodingLine);</span>
            }
<span class="fc" id="L1251">            List&lt;Integer&gt; offsets = new ArrayList&lt;Integer&gt;(expectedNumberOfOffsets);</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">            while(offsets.size()&lt;expectedNumberOfOffsets){</span>
<span class="fc" id="L1253">                String offsetLine = parserState.getNextLine();</span>
<span class="fc" id="L1254">                Scanner scanner = new Scanner(offsetLine);</span>
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">                if(!scanner.hasNextInt()){</span>
<span class="nc" id="L1256">                    throw new IOException(&quot;error reading read-to-unitig delta encoding not enough values :&quot;+ offsetLine);</span>
                    
                }
<span class="fc bfc" id="L1259" title="All 2 branches covered.">                while(scanner.hasNextInt()){</span>
<span class="fc" id="L1260">                    offsets.add(scanner.nextInt());</span>
                }
<span class="fc" id="L1262">            }</span>
<span class="fc" id="L1263">            return offsets;</span>
        }
        private String parseReadId(ParserState parserState) throws IOException {
<span class="fc" id="L1266">            String line = parserState.getNextLine();</span>
<span class="fc" id="L1267">            Matcher matcher = readIdPattern.matcher(line);</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1269">                throw new IOException(&quot;error reading read-to-unitig read id:&quot;+ line);</span>
            }
<span class="fc" id="L1271">            return matcher.group(1);</span>
        }
        private char parseReadType(ParserState parserState) throws IOException {
<span class="fc" id="L1274">            String line = parserState.getNextLine();</span>
<span class="fc" id="L1275">            Matcher matcher = typePattern.matcher(line);</span>
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">            if(!matcher.find()){</span>
<span class="nc" id="L1277">                throw new IOException(&quot;error reading read-to-unitig mapping type:&quot;+ line);</span>
            }
<span class="fc" id="L1279">            return matcher.group(1).charAt(0);</span>
        }
        
    }
    static int parseLength(ParserState parserState) throws IOException {
<span class="nc" id="L1284">        String line = parserState.getNextLine();</span>
<span class="nc" id="L1285">        return parseLength(line);</span>
    }
    private static int parseLength(String line) throws IOException {               
<span class="fc" id="L1288">        Matcher matcher = LENGTH_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">        if(!matcher.find()){</span>
<span class="nc" id="L1290">            throw new IOException(&quot;error reading length:&quot;+ line);</span>
        }
<span class="fc" id="L1292">        return Integer.parseInt(matcher.group(1));</span>
    }
    private static long parseNumberOfReads(ParserState parserState) throws IOException {
<span class="fc" id="L1295">        String line = parserState.getNextLine();</span>
<span class="fc" id="L1296">        Matcher matcher = NUM_READS_PATTERN.matcher(line);</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if(!matcher.find()){</span>
<span class="nc" id="L1298">            throw new IOException(&quot;error parsing unitig number of reads : &quot;+ line);</span>
        }
<span class="fc" id="L1300">        return Long.parseLong(matcher.group(1));</span>
    }
    private static final class IdTuple{
        private final String externalId;
        private final long internalId;
<span class="fc" id="L1305">        private IdTuple(String externalId, long internalId) {</span>
<span class="fc" id="L1306">            this.externalId = externalId;</span>
<span class="fc" id="L1307">            this.internalId = internalId;</span>
<span class="fc" id="L1308">        }</span>
        
    }
    
    private static final class MatePairEvidenceImpl implements MatePairEvidence{
        private final String read1,read2;
        
<span class="nc" id="L1315">        private MatePairEvidenceImpl(String read1, String read2) {</span>
<span class="nc" id="L1316">            this.read1 = read1;</span>
<span class="nc" id="L1317">            this.read2 = read2;</span>
<span class="nc" id="L1318">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        public String getRead1() {
<span class="nc" id="L1325">            return read1;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public String getRead2() {
<span class="nc" id="L1333">            return read2;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public int hashCode() {
<span class="nc" id="L1341">            final int prime = 31;</span>
<span class="nc" id="L1342">            int result = 1;</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">            result = prime * result + ((read1 == null) ? 0 : read1.hashCode());</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">            result = prime * result + ((read2 == null) ? 0 : read2.hashCode());</span>
<span class="nc" id="L1345">            return result;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L1353" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1354">                return true;</span>
            }
<span class="nc bnc" id="L1356" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L1357">                return false;</span>
            }
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            if (!(obj instanceof MatePairEvidenceImpl)) {</span>
<span class="nc" id="L1360">                return false;</span>
            }
<span class="nc" id="L1362">            MatePairEvidenceImpl other = (MatePairEvidenceImpl) obj;</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">            if (read1 == null) {</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                if (other.read1 != null) {</span>
<span class="nc" id="L1365">                    return false;</span>
                }
<span class="nc bnc" id="L1367" title="All 2 branches missed.">            } else if (!read1.equals(other.read1)) {</span>
<span class="nc" id="L1368">                return false;</span>
            }
<span class="nc bnc" id="L1370" title="All 2 branches missed.">            if (read2 == null) {</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">                if (other.read2 != null) {</span>
<span class="nc" id="L1372">                    return false;</span>
                }
<span class="nc bnc" id="L1374" title="All 2 branches missed.">            } else if (!read2.equals(other.read2)) {</span>
<span class="nc" id="L1375">                return false;</span>
            }
<span class="nc" id="L1377">            return true;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public String toString() {
<span class="nc" id="L1385">            return &quot;MatePairEvidenceImpl [read1=&quot; + read1 + &quot;, read2=&quot; + read2</span>
                    + &quot;]&quot;;
        }
        
        
    }
    
    private static class VariantRecordImpl implements VariantRecord{

        private final List&lt;Long&gt; readIds;
        private final NucleotideSequence sequence;
        private final int weight;
        
        
        public VariantRecordImpl(List&lt;Long&gt; readIds,
<span class="nc" id="L1400">                NucleotideSequence sequence, int weight) {</span>
<span class="nc" id="L1401">            this.readIds = Collections.unmodifiableList(readIds);</span>
<span class="nc" id="L1402">            this.sequence = sequence;</span>
<span class="nc" id="L1403">            this.weight = weight;</span>
<span class="nc" id="L1404">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        public List&lt;Long&gt; getContributingReadIIDs() {
<span class="nc" id="L1411">            return readIds;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public int getWeight() {
<span class="nc" id="L1419">            return weight;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public NucleotideSequence getVariantSequence() {
<span class="nc" id="L1427">            return sequence;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public int compareTo(VariantRecord o) {
<span class="nc" id="L1435">        	return JillionUtil.compare(weight, o.getWeight());			</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public int hashCode() {
<span class="nc" id="L1443">            final int prime = 31;</span>
<span class="nc" id="L1444">            int result = 1;</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">            result = prime * result</span>
<span class="nc" id="L1446">                    + ((readIds == null) ? 0 : readIds.hashCode());</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">            result = prime * result</span>
<span class="nc" id="L1448">                    + ((sequence == null) ? 0 : sequence.hashCode());</span>
<span class="nc" id="L1449">            result = prime * result + weight;</span>
<span class="nc" id="L1450">            return result;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L1458" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1459">                return true;</span>
            }
<span class="nc bnc" id="L1461" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L1462">                return false;</span>
            }
<span class="nc bnc" id="L1464" title="All 2 branches missed.">            if (!(obj instanceof VariantRecordImpl)) {</span>
<span class="nc" id="L1465">                return false;</span>
            }
<span class="nc" id="L1467">            VariantRecordImpl other = (VariantRecordImpl) obj;</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">            if (readIds == null) {</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">                if (other.readIds != null) {</span>
<span class="nc" id="L1470">                    return false;</span>
                }
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            } else if (!readIds.equals(other.readIds)) {</span>
<span class="nc" id="L1473">                return false;</span>
            }
<span class="nc bnc" id="L1475" title="All 2 branches missed.">            if (sequence == null) {</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">                if (other.sequence != null) {</span>
<span class="nc" id="L1477">                    return false;</span>
                }
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            } else if (!sequence.equals(other.sequence)) {</span>
<span class="nc" id="L1480">                return false;</span>
            }
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (weight != other.weight) {</span>
<span class="nc" id="L1483">                return false;</span>
            }
<span class="nc" id="L1485">            return true;</span>
        }

        /**
        * {@inheritDoc}
        */
        @Override
        public String toString() {
<span class="nc" id="L1493">            return &quot;VariantRecordImpl [readIds=&quot; + readIds + &quot;, sequence=&quot;</span>
                    + sequence + &quot;, weight=&quot; + weight + &quot;]&quot;;
        }
        
    }
    
    private static void skipReservedSource(ParserState parserState) throws IOException {
        
<span class="nc" id="L1501">        String line = &quot;&quot;;</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">        while(!&quot;.\n&quot;.equals(line)){</span>
<span class="nc" id="L1503">            line = parserState.getNextLine();</span>
        }
        
<span class="nc" id="L1506">    }</span>
    private  static void parseEndOfMessage(ParserState parserState, String messageCode) throws IOException {
<span class="fc" id="L1508">        String endLine = parserState.getNextLine();</span>
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">        if(!endLine.startsWith(END_MESSAGE)){</span>
<span class="nc" id="L1510">            throw new IOException(&quot;invalid asm file: invalid &quot;+ messageCode +&quot; end tag : &quot; + endLine);</span>
        }
<span class="fc" id="L1512">    }</span>
    
    private static void skipCurrentBlock(ParserState parserState) throws IOException {
<span class="fc" id="L1515">        String line=null;</span>
        do{
<span class="fc" id="L1517">            line = parserState.getNextLine();</span>
<span class="pc bpc" id="L1518" title="1 of 4 branches missed.">        }while(line !=null &amp;&amp; !line.startsWith(&quot;}&quot;));</span>
        
<span class="fc" id="L1520">    }</span>
    /**
     * CA &lt;= 5 had a src block which should be ignored
     * CA 6+ doesn't have it anymore so need to handle
     * both cases.
     * @param parserState
     * @param line the current line to check which might
     * be the beginning of a deprecated 'src' block.
     * @return the first line AFTER the 'src' block
     * or the same reference to {@code line}
     * if the current line isn't a 'src' block.
     * @throws IOException if there is a problem parsing
     * the asm file.
     */
    private static String skipSrcBlock(ParserState parserState, String line)
			throws IOException {
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">		if(line.startsWith(SRC)){</span>
<span class="nc" id="L1537">		    skipReservedSource(parserState);</span>
<span class="nc" id="L1538">		    return parserState.getNextLine();</span>
		}
<span class="fc" id="L1540">		return line;</span>
	}

	private abstract static class CallBack implements AsmVisitorCallback{
    	private final AtomicBoolean keepParsing;

<span class="fc" id="L1546">		public CallBack(AtomicBoolean keepParsing) {</span>
<span class="fc" id="L1547">			this.keepParsing = keepParsing;</span>
<span class="fc" id="L1548">		}</span>

		@Override
		public void haltParsing() {
<span class="fc" id="L1552">			keepParsing.set(false);			</span>
<span class="fc" id="L1553">		}</span>
    	
    }
    
    
    private static class MementoedCallback extends CallBack{

    	private final long offset;
    	public MementoedCallback(AtomicBoolean keepParsing, long offset){
<span class="fc" id="L1562">    		super(keepParsing);</span>
<span class="fc" id="L1563">    		this.offset = offset;</span>
<span class="fc" id="L1564">    	}</span>
		@Override
		public boolean canCreateMemento() {
<span class="fc" id="L1567">			return true;</span>
		}

		@Override
		public AsmVisitorMemento createMemento() {
<span class="fc" id="L1572">			return new OffsetMemento(offset);</span>
		}
    	
    }
    
    
    private static class OffsetMemento implements AsmVisitorMemento{
    	private final long offset;

<span class="fc" id="L1581">		public OffsetMemento(long offset) {</span>
<span class="fc" id="L1582">			this.offset = offset;</span>
<span class="fc" id="L1583">		}</span>

		protected final long getOffset() {
<span class="fc" id="L1586">			return offset;</span>
		}
    	
    }
    private static class FileBasedAsmFileParser extends AsmFileParser{
    	private final File asmFile;

<span class="fc" id="L1593">		public FileBasedAsmFileParser(File asmFile) {</span>
<span class="fc" id="L1594">			this.asmFile = asmFile;</span>
<span class="fc" id="L1595">		}</span>

		@Override
		public void parse(AsmVisitor visitor) throws IOException {
<span class="fc" id="L1599">			InputStream in =null;</span>
	        try{
<span class="fc" id="L1601">	            in= new BufferedInputStream(new FileInputStream(asmFile));</span>
<span class="fc" id="L1602">	            ParserState parserState = new ParserState(in, 0){</span>

					@Override
					public CallBack createCallback() {
<span class="fc" id="L1606">						return new MementoedCallback(keepParsing, markedOffset);</span>
					}
	            	
	            };
<span class="fc" id="L1610">	            parseAsm(parserState,visitor);</span>
	        }finally{
<span class="pc" id="L1612">	            IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L1613">	        }</span>
			
<span class="fc" id="L1615">		}</span>

		@Override
		public void parse(AsmVisitor visitor, AsmVisitorMemento memento)
				throws IOException {
<span class="pc bpc" id="L1620" title="1 of 2 branches missed.">			if( !(memento instanceof OffsetMemento)){</span>
<span class="nc" id="L1621">				throw new IllegalArgumentException(&quot;unknown memento type &quot;+ memento + &quot; must use instance created by this parser&quot;);</span>
			}
			
<span class="fc" id="L1624">			long offset = ((OffsetMemento)memento).getOffset();			</span>
<span class="fc" id="L1625">			InputStream in =null;</span>
			try{
<span class="fc" id="L1627">				in = new BufferedInputStream(new RandomAccessFileInputStream(asmFile, offset));</span>
<span class="fc" id="L1628">				ParserState parserState = new ParserState(in, offset){</span>

					@Override
					public CallBack createCallback() {
<span class="fc" id="L1632">						return new MementoedCallback(keepParsing, markedOffset);</span>
					}
	            	
	            };
<span class="fc" id="L1636">	            parseAsm(parserState,visitor);</span>
			}finally{
<span class="pc" id="L1638">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L1639">			}</span>
<span class="fc" id="L1640">		}</span>

		@Override
		public boolean canParse() {
<span class="nc" id="L1644">			return true;</span>
		}
    	
    }
   
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>