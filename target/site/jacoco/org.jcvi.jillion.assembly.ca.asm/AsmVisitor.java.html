<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AsmVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.ca.asm</a> &gt; <span class="el_source">AsmVisitor.java</span></div><h1>AsmVisitor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.ca.asm;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;

/**
 * {@code AsmVisitor} is a visitor implementation
 * to traverse a Celera Assembler .ASM file.
 * &lt;p&gt;
 * The ASM file is the output of the 
 * Celera Assembler pipeline.  It provides a precise description
 * of the assembly as a hierarchical data structure.  The messages
 * are visited in a &quot;definition before reference&quot; order.  Every
 * identifier is defined in a visit message before it is referenced.
 * For example, both reads will be visited before the visit
 * method that defines these reads as a mate pair.
 * 
 * @author dkatzel
 *
 *
 */
public interface AsmVisitor{
	
	
	/*
	 * ASM message order:
	 * MDI + (library)
	 * AFG + (read)
	 * AMP + (mate pair info)
	 * UTG +
	 * ----MPS (unitig read placement)
	 * ULK + (unitig links?)
	 * CCO +
	 * ----VAR + (variant record)
	 * ----MPS + (contig read placement)
	 * ----UPS + (unitig mapping to cotig)
	 * CLK + (contig links)
	 * SCF + (scaffold)
	 * ----CTP + (contig pair
	 * SLK + (scaffold links)
	 */
	/**
	 * {@code AsmVisitorCallback}
	 * is a callback mechanism to allow the
	 * {@link AsmVisitor} instances
	 * to communicate with the parser
	 * that is parsing the ASM file.
	 * @author dkatzel
	 *
	 */
	interface AsmVisitorCallback{
		/**
		 * {@code AsmVisitorMemento} is a marker
		 * interface that {@link AsmFileParser}
		 * instances can use to &quot;rewind&quot; back
		 * to the position in its ASM file
		 * in order to revisit portions of the ASM file. 
		 * {@link AsmVisitorMemento} should only be used
		 * by the {@link AsmFileParser} instance that
		 * generated it.
		 * @author dkatzel
		 *
		 */
		interface AsmVisitorMemento{
			
		}
		/**
		 * Is this callback capable of
		 * creating {@link AsmVisitorMemento}s
		 * via {@link #createMemento()}.
		 * @return {@code true} if this callback
		 * can create mementos; {@code false} otherwise.
		 */
		boolean canCreateMemento();
		/**
		 * Create a {@link AsmVisitorMemento}
		 * 
		 * @return a {@link AsmVisitorMemento}; never null.
		 * @see #canCreateMemento()
		 * @throws UnsupportedOperationException if {@link #canCreateMemento()}
		 * returns {@code false}.
		 */
		AsmVisitorMemento createMemento();
		/**
		 * Tell the {@link AsmFileParser} to halt parsing
		 * the ASM file. If the ASM file is not completely
		 * parsed, then any visitors still being visited
		 * will have their halted() methods
		 * called instead of their visitEnd() methods. 
		 */
		void haltParsing();
	}
	
    /**
     * {@code MateStatus} indicates the
     * relative positioning of the mate
     * of this read in the assembly.
     * @author dkatzel
     *
     *
     */
<span class="pc" id="L128">    public enum MateStatus{</span>
        /**
         * Mate pair was unprocessed by 
         * CA pipeline; should never appear.
         */
<span class="fc" id="L133">        UNASSIGNED('Z'),</span>
        /**
         * The pair assembled into one
         * scaffold with the proper orientation
         * and within the acceptable distance.
         */
<span class="fc" id="L139">        GOOD('G'),</span>
        /**
         * The pair assembled into one
         * scaffold with the proper orientation
         * but were placed too close
         * together.
         */
<span class="fc" id="L146">        BAD_SHORT('C'),</span>
        /**
         * The pair assembled into one
         * scaffold with the proper orientation
         * but were placed too far apart.
         */
<span class="fc" id="L152">        BAD_LONG('L'),</span>
        /**
         * The pair assembled into one
         * scaffold but in the same
         * orientation.
         */
<span class="fc" id="L158">        SAME_ORIENTATION('S'),</span>
        /**
         * The pair assembled into one
         * scaffold but in the oriented
         * away from each other.
         */
<span class="fc" id="L164">        OUTTIE_ORIENTATION('O'),</span>
        /**
         * This read has no mate.
         */
<span class="fc" id="L168">        NO_MATE('N'),</span>
        /**
         * Neither read in the mate
         * pair were assembled
         */
<span class="fc" id="L173">        BOTH_SINGLETON('H'),</span>
        /**
         * This read's mate was placed
         * in a singleton unitig.
         */
<span class="fc" id="L178">        SINGLETON_MATE('A'),</span>
        /**
         * Both reads in the pair
         * were assembled into degenerate
         * unitig.
         */
<span class="fc" id="L184">        BOTH_DEGENERATE('D'),</span>
        /**
         * This read's mate was
         * assembled into a degenerate unitig.
         */
<span class="fc" id="L189">        DEGENERATE('E'),</span>
        /**
         * Both reads were placed in surrogate
         * unitigs.
         */
<span class="fc" id="L194">        BOTH_SURROGATE('U'),</span>
<span class="fc" id="L195">        SURROGATE('R'),</span>
        /**
         * Each mate was placed in different
         * scaffolds.
         */
<span class="fc" id="L200">        DIFFERENT_SCAFFOLD('F'),</span>
        /**
         * &lt;strong&gt;DO NOT USE&lt;/strong&gt;.
         * Old deprecated bad mate status
         * included here only to support 
         * old asm files.
         */
<span class="fc" id="L207">        @Deprecated</span>
        DEPRECATED_BAD('B')
        ;
        private final char code;
        
        private static final Map&lt;Character,MateStatus&gt; MAP;
        static{
<span class="fc" id="L214">            MAP = new HashMap&lt;Character,MateStatus&gt;();</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">            for(MateStatus status : values()){</span>
<span class="fc" id="L216">                MAP.put(status.code, status);</span>
            }
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">        private MateStatus(char code) {</span>
<span class="fc" id="L220">            this.code = code;</span>
<span class="fc" id="L221">        }</span>
        
        public static MateStatus parseMateStatus(String statusCode){
<span class="fc" id="L224">            return parseMateStatus(statusCode.charAt(0));</span>
        }
        public static MateStatus parseMateStatus(char statusCode){
<span class="fc" id="L227">            Character valueOf = Character.valueOf(statusCode);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">            if(!MAP.containsKey(valueOf)) {</span>
<span class="nc" id="L229">               throw new IllegalArgumentException(&quot;invalid mate status code :&quot;+ statusCode);</span>
            }
<span class="fc" id="L231">            return MAP.get(valueOf);</span>
            
        }

		public char getCode() {
<span class="nc" id="L236">			return code;</span>
		}
        
        
    }
    /**
     * {@code UnitigStatus} represents the unitig's
     * disposition after scaffold construction.
     * @author dkatzel
     *
     */
<span class="pc" id="L247">    public enum UnitigStatus{</span>
        /**
         * Placed in scaffold or promoted
         * to its own scaffold.
         */
<span class="fc" id="L252">        UNIQUE('U'),</span>
        /**
         * Added cautiously at one or more
         * scaffold locations.
         */
<span class="fc" id="L257">        REPEAT_SURROGATE('S'),</span>
        /**
         * Left out of the assembly 
         * as a degenerate.
         */
<span class="fc" id="L262">        REPEAT_DEGENERATE('N'),</span>
        /**
         * No longer used.
         */
<span class="fc" id="L266">        CHIMER('C'),</span>
        /**
         * Always changed to {@link #REPEAT_SURROGATE}
         * or {@link #REPEAT_DEGENERATE} during scaffolding.
         */
<span class="fc" id="L271">        UNRESOVLED('X')</span>
        ;
        private final char code;
        
        private static final Map&lt;Character,UnitigStatus&gt; MAP;
        static{
<span class="fc" id="L277">            MAP = new HashMap&lt;Character,UnitigStatus&gt;();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">            for(UnitigStatus status : values()){</span>
<span class="fc" id="L279">                MAP.put(status.code, status);</span>
            }
<span class="fc" id="L281">        }</span>
<span class="fc" id="L282">        private UnitigStatus(char code) {</span>
<span class="fc" id="L283">            this.code = code;</span>
<span class="fc" id="L284">        }</span>
        
        public static UnitigStatus parseUnitigStatus(String statusCode){
<span class="fc" id="L287">            return parseUnitigStatus(statusCode.charAt(0));</span>
        }
        public static UnitigStatus parseUnitigStatus(char statusCode){
<span class="fc" id="L290">            Character valueOf = Character.valueOf(statusCode);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if(!MAP.containsKey(valueOf)) {</span>
<span class="nc" id="L292">                throw new IllegalArgumentException(&quot;invalid unitig status code :&quot;+ statusCode);</span>
             }
<span class="fc" id="L294">            return MAP.get(valueOf);</span>
        }

		public char getCode() {
<span class="nc" id="L298">			return code;</span>
		}
        
        
    }
    
    /**
     * {@code LinkOrientation} represents the
     * the relative orientation of the two
     * unitigs or the two contigs being linked.
     * @author dkatzel
     *
     */
<span class="nc" id="L311">    public enum LinkOrientation{</span>
        /**
         * Indicates forward-forward.
         */
<span class="nc" id="L315">         NORMAL('N'),</span>
         /**
          * Indicates reverse - reverse.
          */
<span class="nc" id="L319">         ANTI_NORMAL('A'),</span>
         /**
          * Indicates reverse-forward.
          */        
<span class="nc" id="L323">         OUTIE('O'),</span>
         /**
          * Indicates foward-reverse.
          */
<span class="nc" id="L327">         INNIE('I')</span>
        ;
        private final char code;
        
        private static final Map&lt;Character,LinkOrientation&gt; MAP;
        static{
<span class="nc" id="L333">            MAP = new HashMap&lt;Character,LinkOrientation&gt;();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            for(LinkOrientation status : values()){</span>
<span class="nc" id="L335">                MAP.put(status.code, status);</span>
            }
<span class="nc" id="L337">        }</span>
<span class="nc" id="L338">        private LinkOrientation(char code) {</span>
<span class="nc" id="L339">            this.code = code;</span>
<span class="nc" id="L340">        }</span>
        
        public static LinkOrientation parseLinkOrientation(String statusCode){
<span class="nc" id="L343">            return parseLinkOrientation(statusCode.charAt(0));</span>
        }
        public static LinkOrientation parseLinkOrientation(char statusCode){
<span class="nc" id="L346">            Character valueOf = Character.valueOf(statusCode);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if(!MAP.containsKey(valueOf)) {</span>
<span class="nc" id="L348">               throw new IllegalArgumentException(&quot;invalid link orientation code :&quot;+ statusCode);</span>
            }
<span class="nc" id="L350">            return MAP.get(Character.valueOf(statusCode));</span>
        }

		public char getCode() {
<span class="nc" id="L354">			return code;</span>
		}
        
        
    }
    
    /**
     * {@code OverlapType} describes the pair-wise
     * alignment of contigs/unitigs induced by the mate pairs
     * in this link.
     * @author dkatzel
     *
     */
<span class="nc" id="L367">    public enum OverlapType{</span>
        /**
         * These two unitigs/contigs have no overlap
         * and the link is determined
         * only by mate pairs.
         */
<span class="nc" id="L373">         NO_OVERLAP('N'){</span>
             int getExpectedNumberOfMatePairEvidenceRecords(int numberOfContributingEdges){
<span class="nc" id="L375">                 return numberOfContributingEdges;</span>
             }
         },
         /**
          * Regular overlap.
          */
<span class="nc" id="L381">         REGULAR('O'),</span>
         /**
          * TODO: what does this mean?
          */        
<span class="nc" id="L385">         TANDEM('T'),</span>
         /**
          * TODO: what does this mean?
          */ 
<span class="nc" id="L389">         CONTAINMENT_1_BY_2('C'),</span>
         /**
          * TODO: what does this mean?
          */ 
<span class="nc" id="L393">         CONTAINMENT_2_BY_1('I'),</span>
        ;
        private final char code;
        
        private static final Map&lt;Character,OverlapType&gt; MAP;
        static{
<span class="nc" id="L399">            MAP = new HashMap&lt;Character,OverlapType&gt;();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            for(OverlapType status : values()){</span>
<span class="nc" id="L401">                MAP.put(status.code, status);</span>
            }
<span class="nc" id="L403">        }</span>
<span class="nc" id="L404">        private OverlapType(char code) {</span>
<span class="nc" id="L405">            this.code = code;</span>
<span class="nc" id="L406">        }</span>
        
        public static OverlapType parseOverlapType(String statusCode){
<span class="nc" id="L409">            return parseOverlapType(statusCode.charAt(0));</span>
        }
        public static OverlapType parseOverlapType(char statusCode){
<span class="nc" id="L412">            Character valueOf = Character.valueOf(statusCode);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if(!MAP.containsKey(valueOf)){</span>
<span class="nc" id="L414">                throw new IllegalArgumentException(&quot;invalid overlap code :&quot;+ statusCode);                </span>
            }
<span class="nc" id="L416">            return MAP.get(valueOf);</span>
        }
        /**
         * This is the expected number of mate pair
         * evidence records in the &quot;jumplist&quot; of a link
         * message.  The expected number varies based on
         * which overlap type this unitig/contig is.
         * @param numberOfContributingEdges the number of edges
         * specified in the message.
         * @return the expected number of mate pairs to prove
         * evidence of this link.
         */
        int getExpectedNumberOfMatePairEvidenceRecords(int numberOfContributingEdges){
<span class="nc" id="L429">            return numberOfContributingEdges-1;</span>
        }

		public char getCode() {
<span class="nc" id="L433">			return code;</span>
		}
        
        
    }
    
    /**
     * {@code OverlapStatus} describes the pair-wise
     * alignment of contigs/unitigs induced by the mate pairs
     * in this link.
     * @author dkatzel
     *
     */
<span class="nc" id="L446">    public enum OverlapStatus{</span>
        /**
         * TODO: what does this mean?
         */
<span class="nc" id="L450">         IN_ASSEMBLY('A'),</span>
         /**
          * TODO: what does this mean?
          */
<span class="nc" id="L454">         POLYMORPHISM('P'),</span>
         /**
          * TODO: what does this mean?
          */        
<span class="nc" id="L458">         BAD('B'),</span>
         /**
          * TODO: what does this mean?
          */ 
<span class="nc" id="L462">         CHIMERA('C'),</span>
         /**
          * TODO: what does this mean?
          */ 
<span class="nc" id="L466">         UNKNOWN('U'),</span>
        ;
        private final char code;
        
        private static final Map&lt;Character,OverlapStatus&gt; MAP;
        static{
<span class="nc" id="L472">            MAP = new HashMap&lt;Character,OverlapStatus&gt;();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            for(OverlapStatus status : values()){</span>
<span class="nc" id="L474">                MAP.put(status.code, status);</span>
            }
<span class="nc" id="L476">        }</span>
<span class="nc" id="L477">        private OverlapStatus(char code) {</span>
<span class="nc" id="L478">            this.code = code;</span>
<span class="nc" id="L479">        }</span>
        
        public static OverlapStatus parseOverlapStatus(String statusCode){
<span class="nc" id="L482">            return parseOverlapStatus(statusCode.charAt(0));</span>
        }
        public static OverlapStatus parseOverlapStatus(char statusCode){            
<span class="nc" id="L485">            Character valueOf = Character.valueOf(statusCode);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if(!MAP.containsKey(valueOf)){</span>
<span class="nc" id="L487">                throw new IllegalArgumentException(&quot;invalid overlap status code :&quot;+ statusCode);</span>
            }
<span class="nc" id="L489">            return MAP.get(valueOf);</span>
        }

		public char getCode() {
<span class="nc" id="L493">			return code;</span>
		}
        
        
    }
    
    
    
    interface MatePairEvidence{
        String getRead1();
        String getRead2();
    }
    
    
    /**
     * {@code UnitigLayoutType} describes how 
     * the assembler decided to place this unitig
     * in the scaffold.  If the unitig represents
     * a repeat, then the type explains the which
     * repeat resolution level was used.
     * @author dkatzel
     *
     */
<span class="pc" id="L516">    public enum UnitigLayoutType{</span>
        /**
         * This unitig was unique
         */
<span class="fc" id="L520">        UNIQUE('U'),</span>
        /**
         * Least aggressive level of repeat resolution.
         * A Rock is a placed unitig that was consistently
         * positioned by at least two mate pairs.
         */
<span class="fc" id="L526">        REPEAT_ROCK('R'),</span>
        /**
         * Middle aggressive level of repeat resolution.
         * A Stone is a placed unitig that was 
         * positioned by one mate pair and confirmed by an overlap
         * tiling across the gap containing it.
         */
<span class="fc" id="L533">        REPEAT_STONE('S'),</span>
        /**
         * Most aggressive level of repeat resolution.
         * A pebble is a placed unitig that was placed
         * only using overlap tiling.  This level of repeat
         * resolution hasn't been used in Celera Assembler
         * since the 2000 assembly of Drosophila melanogaster.
         */
<span class="fc" id="L541">        REPEAT_PEBBLE('P'),</span>
        /**
         * This unitig represents a single read?
         */
<span class="fc" id="L545">        SINGLE_READ('s')</span>
        ;
        private final char code;
        
        private static final Map&lt;Character,UnitigLayoutType&gt; MAP;
        
        static{
<span class="fc" id="L552">            MAP = new HashMap&lt;Character,UnitigLayoutType&gt;();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">            for(UnitigLayoutType status : values()){</span>
<span class="fc" id="L554">                MAP.put(status.code, status);</span>
            }
<span class="fc" id="L556">        }</span>
<span class="fc" id="L557">        private UnitigLayoutType(char code) {</span>
<span class="fc" id="L558">            this.code = code;</span>
<span class="fc" id="L559">        }</span>
        
        public static UnitigLayoutType parseUnitigLayoutType(String typeCode){
<span class="fc" id="L562">            return parseUnitigLayoutType(typeCode.charAt(0));</span>
        }
        public static UnitigLayoutType parseUnitigLayoutType(char typeCode){
<span class="fc" id="L565">            Character valueOf = Character.valueOf(typeCode);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">            if(!MAP.containsKey(valueOf)){</span>
<span class="nc" id="L567">                throw new IllegalArgumentException(&quot;invalid unitg layout type : &quot;+ typeCode);</span>
            }
<span class="fc" id="L569">            return MAP.get(valueOf);</span>
        }

		public char getCode() {
<span class="nc" id="L573">			return code;</span>
		}
        
        
    }
    /**
     * Describes statistics about one library as observed 
     * after partial assembly.
     * @param externalId the externally unique UID; the value is the same as the 
     * string as the DST accession field in the input frg file.
     * @param internalId an internal integer value that associates this message with
     * future messages visited further on in the assembly pipeline.
     * @param meanOfDistances the mean of the distances between mates in this library.
     * 
     * @param stdDev the standard deviation for the mean distance of mate pairs in this library.
     * 
     * @param min the minimum distance between mate pairs in this library.
     * 
     * @param max the maximum distance between mate pairs in this library.
     * 
     * @param histogram a histogram of the distances observed in one library.
     * A normal distribution indicates a well-constructed library; other distributions
     * can indicate library problems.
     * 
     */
    void visitLibraryStatistics(String externalId, long internalId,
            float meanOfDistances, float stdDev,
            long min, long max, List&lt;Long&gt; histogram);
    
    /**
     * Visit one read and get its status in the assembly.
     * @param externalId the unique external id of this read from the frg file.
     * @param internalId an internal integer value that associates this read with
     * future messages visited further on in the assembly pipeline. 
     * @param mateStatus the {@link MateStatus} of this read's mate.
     * @param isSingleton is this read a singleton.  If {@code true}
     * then this read could not be assembled; {@code false} otherwise.
     * @param clearRange the final clear range of this read determined
     * by the Celera Assembler trimming modules (ex: Overlap Based Trimming).
     */
    void visitRead(String externalId, long internalId, MateStatus mateStatus,
            boolean isSingleton, Range clearRange);
    /**
     * This is duplicated information provided for convenience.
     * @param externalIdOfRead1 the unique id for one read.
     * @param externalIdOfRead2 the unique id for the other read.
     * @param mateStatus the combined status of the individual reads.
     */
    void visitMatePair(String externalIdOfRead1,String externalIdOfRead2, MateStatus mateStatus);
    
    /**
     * Visit a Unitig generated by the unitigger module.  Most unitigs are components of a contigs; some
     * unitigs are themselves a contig.  Some unitigs will be generated by splitting in the scaffold module;
     * those unitigs will appear in a later message
     * generated by the scaffold.
     * @param callback the {@link AsmVisitorCallback} instance
     * which can be used to callback to the parser.
     * @param externalId the unique external id of this unitig.
     * @param internalId an internal integer value that associates this unitig with
     * future messages visited further on in the assembly pipeline. 
     * @param aStat gives the likelihood this unitig derives
     * from a unique locus of the genome, as opposed to being a collapse 
     * of reads from two copies of a genomic repeat. An aStat of 0
     * indicates no preference.  Too-short unitigs have their A-stat set to zero. 
     * Negative values indicate repetitiveness. Positive values indicate uniqueness. 
     * @param measureOfPolymorphism experimental measure of polymorphism
     * observed between reads in the unitig.  Introduced in CA version 6,
     * not yet used by assembler.
     * @param status the unitig status.
     * @param consensusSequence the consensus of this unitig.
     * @param consensusQualities the consensus qualities of this unitig.
     * @param numberOfReads number of reads in the unitig, should always
     * be &amp;ge; 1.
     * @return an instance of {@link AsmUnitigVisitor} to be used
     * to visit this unitig; if a {@code null} value
     * is returned, then this unitig is skipped by the parser.
     */
    AsmUnitigVisitor visitUnitig(AsmVisitorCallback callback, String externalId, long internalId, float aStat, float measureOfPolymorphism,
            UnitigStatus status, NucleotideSequence consensusSequence, QualitySequence consensusQualities,
            long numberOfReads);
    /**
     * Indicates connections between unitigs.  They summarize the edges in the unitig graph whose nodes
     * are unitigs.  The graph's edges are induced by mate pairs that have one read
     * in each unitig.
     * @param externalUnitigId1 the external id of one of the unitigs.
     * @param externalUnitigId2 the external id of one the other unitig.
     * @param orientation The {@link LinkOrientation} of these two unitigs relative
     * to each other.
     * @param overlapType the {@link OverlapType}.
     * @param status the {@link OverlapStatus}.
     * @param isPossibleChimera {@code true} if this unitg link a possible chimera;
     * {@code false} otherwise.
     * @param numberOfEdges the number of contributing edges.
     * @param meanDistance the mean edge distance, may be negative.
     * @param stddev the standard deviation of edge distances.
     * @param matePairEvidence a set of {@link MatePairEvidence}s
     * that show the mate pairs that were used to determine
     * that these two unitigs are linked.
     */
    void visitUnitigLink(String externalUnitigId1,String externalUnitigId2, LinkOrientation orientation,
            OverlapType overlapType, OverlapStatus status, boolean isPossibleChimera,
            int numberOfEdges, float meanDistance, float stddev, Set&lt;MatePairEvidence&gt; matePairEvidence);
    
    /**
     * Indicates connections between contigs.  They summarize the edges in a graph whose nodes
     * are contigs.  The graph's edges are induced by mate pairs that have one read
     * in each contig.
     * @param externalContigId1 the external id of one of the contigs.
     * @param externalContigId2 the external id of one the other contig.
     * @param orientation The {@link LinkOrientation} of these two contigs relative
     * to each other.
     * @param overlapType the {@link OverlapType}.
     * @param status the {@link OverlapStatus}.
     * @param numberOfEdges the number of contributing edges.
     * @param meanDistance the mean edge distance, may be negative.
     * @param stddev the standard deviation of edge distances.
     * @param matePairEvidence a set of {@link MatePairEvidence}s
     * that show the mate pairs that were used to determine
     * that these two contigs are linked.
     */
    void visitContigLink(String externalContigId1,String externalContigId2, LinkOrientation orientation,
            OverlapType overlapType, OverlapStatus status, int numberOfEdges,
            float meanDistance, float stddev, Set&lt;MatePairEvidence&gt; matePairEvidence);
    /**
     * Describes one contig.  A contig represents a contiguous span
     * of the target genome.  The contig contains a layout of reads, a layout of unitigs
     * and any variants found in the underlying reads.
     * @param callback the {@link AsmVisitorCallback} instance
     * which can be used to callback to the parser.
     * @param externalId the unique external id of this contig.
     * @param internalId an internal integer value that associates this contig with
     * future messages visited further on in the assembly pipeline. 
     * @param isDegenerate is this contig a degenerate contig (not placed in a scaffold).
     * @param consensusSequence the gapped consensus sequences of this contig.
     * @param consensusQualities the consensus qualities of this contig.
     * @param numberOfReads the number of reads in this contig.
     * @param numberOfUnitigs the number of unitigs that have been 
     * laid out in this contig.
     * @param numberOfVariants the number of variant (alternate allele)
     * consensus regions.
     * @return an instance of {@link AsmContigVisitor} to be used
     * to visit this contig; if a {@code null} value
     * is returned, then this contig is skipped by the parser.
     */
    AsmContigVisitor visitContig(AsmVisitorCallback callback, String externalId, long internalId, boolean isDegenerate,
            NucleotideSequence consensusSequence, QualitySequence consensusQualities,
            long numberOfReads, long numberOfUnitigs, long numberOfVariants);

    /**
     * Visit a scaffold that is made up of multiple contigs. A scaffold
     * is the maximal unit of contiguous sequence output
     * by Celera Assembler.
     * A scaffold may consist of one contig or multiple contigs
     * and their relative coordinates.
     * @param callback the {@link AsmVisitorCallback} instance
     * which can be used to callback to the parser.
     * @param externalId the unique external id of this scaffold.
     * @param internalId an internal integer value that associates this scaffold with
     * future messages visited further on in the assembly pipeline. 
     * @param numberOfContigPairs  the number of contig pairs in this scaffold.
     * when numberOfContigPairs = 0, then this scaffold consists of exactly one contig.
     * When numberOfContigPairs  &amp;gt; 0, then the scaffold consists of multiple contigs whose
     * order, orientation and separation are derived from mate pairs.
     * @return an instance of {@link AsmScaffoldVisitor} that will be used
     * to visit the underlying scaffold data.  If a {@code null}
     * is returned, then this scaffold will be skipped.
     */
    AsmScaffoldVisitor visitScaffold(AsmVisitorCallback callback, String externalId, long internalId, int numberOfContigPairs);
    /**
     * Visit a scaffold that is only made up of one contig. A scaffold
     * is the maximal unit of contiguous sequence output
     * by Celera Assembler.
     * A scaffold may consist of one contig or multiple contigs
     * and their relative coordinates.
     * 
     * This method returns void since there is no underlying data
     * for this scaffold since it only contains a single
     * contig that has already been fully described.
     * 
     * @param callback the {@link AsmVisitorCallback} instance
     * which can be used to callback to the parser.
     * @param externalId the unique external id of this scaffold.
     * @param internalId an internal integer value that associates this scaffold with
     * future messages visited further on in the assembly pipeline. 
     * @param externalContigId the contig external id that is the only contig
     * in this scaffold.
     */
    void visitScaffold(AsmVisitorCallback callback, String externalId, long internalId, String externalContigId);

    
    /**
     * Indicates connections between scaffolds.   
     *  They summarize the edges in a graph whose nodes
     * are scaffolds.  The graph's edges are induced by mate pairs that have one read
     * in each scaffold.
     * By definition, the mates
     * in the scaffold link were not used to build a scaffold; they may 
     * have been too few in number or inconsistent with other mates.
     * @param externalScaffoldId1 the external id of one of the scaffolds.
     * @param externalScaffoldId2 the external id of one the other scaffold.
     * @param orientation The {@link LinkOrientation} of these two scaffold relative
     * to each other.
     * @param overlapType the {@link OverlapType}.
     * @param status the {@link OverlapStatus}.
     * @param numberOfEdges the number of contributing edges.
     * @param meanDistance the mean edge distance, may be negative.
     * @param stddev the standard deviation of edge distances.
     * @param matePairEvidence a set of {@link MatePairEvidence}s
     * that show the mate pairs that were used to determine
     * that these two scaffolds are linked.
     */
    void visitScaffoldLink(String externalScaffoldId1,String externalScaffoldId2, LinkOrientation orientation,
            OverlapType overlapType, OverlapStatus status, int numberOfEdges,
            float meanDistance, float stddev, Set&lt;MatePairEvidence&gt; matePairEvidence);
    /**
     * The end of the ASM file has been reached.
     */
    void visitEnd();
    /**
     * The parser has stopped parsing the ASM file
     * due to {@link AsmVisitorCallback#haltParsing()}
     * being called. the end of the ASM file was
     * not yet reached.
     */
    void halted();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>