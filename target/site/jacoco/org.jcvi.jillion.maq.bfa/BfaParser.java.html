<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BfaParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.maq.bfa</a> &gt; <span class="el_source">BfaParser.java</span></div><h1>BfaParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.maq.bfa;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import java.util.concurrent.atomic.AtomicBoolean;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.fasta.FastaParser;
import org.jcvi.jillion.fasta.FastaRecordVisitor;
import org.jcvi.jillion.fasta.FastaVisitor;
import org.jcvi.jillion.fasta.FastaVisitorCallback;
import org.jcvi.jillion.fasta.FastaVisitorCallback.FastaVisitorMemento;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;

/**
 * {@code BfaParser} is a {@link FastaParser}
 * implementation that can read 
 * MAQ's binary fasta file format ({@literal .bfa} files).
 * @author dkatzel
 *
 */
public abstract class BfaParser implements FastaParser{


	
	private final ByteOrder endian;
	/**
	 * Create a new {@link FastaParser} instance
	 * to parse the given binary fasta file (bfa) using
	 * the system endian.
	 * This is the same as calling: 
	 * {@link #create(File, ByteOrder) create(bfaFile, ByteOrder.nativeOrder())}
	 * @param bfaFile the binary fasta file to parse.
	 * @return a new {@link FastaParser} instance;
	 * will never be null.
	 * @throws IOException if the file does not exist.
	 * @throws NullPointerException if bfaFile is null.
	 */
	public static FastaParser create(File bfaFile) throws IOException{
<span class="nc" id="L66">		return create(bfaFile, ByteOrder.nativeOrder());</span>
	}
	/**
	 * Create a new {@link FastaParser} instance
	 * to parse the given binary fasta file (bfq) using
	 * the given {@link ByteOrder}.
	 * @param bfaFile the binary fasta file to parse.
	 * @param endian the {@link ByteOrder} to use to parse the file.
	 * Make sure the endian matches the endian of the machine that 
	 * Maq was run on (or matches the {@link ByteOrder}
	 * used by the {@link BfaWriterBuilder} )
	 * that produced the file.
	 * @return a new {@link FastaParser} instance;
	 * will never be null.
	 * @throws IOException if there is a problem file does not exist.
	 * @throws NullPointerException if either parameter is null.
	 */
	public static FastaParser create(File bfaFile, ByteOrder endian) throws IOException{
<span class="fc" id="L84">		return new BfaFileParser(bfaFile, endian);</span>
	}
	
	/**
	 * Create a new {@link FastaParser} instance
	 * to parse the given {@link InputStream} 
	 * which contains encoded data in binary fasta file (bfa)
	 * format using
	 * the system endian.
	 * This is the same as calling: 
	 * {@link #create(File, ByteOrder) create(bfaFileStream, ByteOrder.nativeOrder())}
	 * @param bfaFileStream the {@link InputStream}  to parse;
	 * can not be null.
	 * @return a new {@link FastaParser} instance;
	 * will never be null.
	 * @throws NullPointerException if inputstream is null.
	 */
	public static FastaParser create(InputStream bfaFileStream){
<span class="nc" id="L102">		return create(bfaFileStream, ByteOrder.nativeOrder());</span>
	}
	/**
	 * Create a new {@link FastaParser} instance
	 * to parse the given {@link InputStream} 
	 * which contains encoded data in binary fasta file (bfa)
	 * format using the given {@link ByteOrder}.
	 * @param bfaFileStream the {@link InputStream}  to parse;
	 * can not be null.
	 * @param endian the {@link ByteOrder} to use to parse the file.
	 * Make sure the endian matches the endian of the machine that 
	 * Maq was run on (or matches the {@link ByteOrder}
	 * used by the {@link BfaWriterBuilder} )
	 * that produced the file.
	 * @return a new {@link FastaParser} instance;
	 * will never be null.
	 * @throws NullPointerException if either parameter is null.
	 */
	public static FastaParser create(InputStream bfaFileStream, ByteOrder endian){
<span class="fc" id="L121">		return new BfaInputStreamParser(bfaFileStream, endian);</span>
	}
	
<span class="fc" id="L124">	private BfaParser(ByteOrder endian) {</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">		if(endian ==null){</span>
<span class="nc" id="L126">			throw new NullPointerException(&quot;endian can not be null&quot;);</span>
		}
<span class="fc" id="L128">		this.endian = endian;</span>
<span class="fc" id="L129">	}</span>
	
	abstract OpenAwareInputStream createInputStream() throws IOException;
	

	

	

	final void parseBfaData(FastaVisitor visitor, OpenAwareInputStream in, long offset) throws IOException {
<span class="fc" id="L139">		FastaRecordVisitor recordVisitor =null;</span>
<span class="fc" id="L140">		long currentOffset = offset;</span>
<span class="fc" id="L141">		Callback callback = createCallback(currentOffset);</span>
<span class="pc bpc" id="L142" title="1 of 4 branches missed.">		while(in.isOpen() &amp;&amp; callback.keepParsing()){</span>
<span class="fc" id="L143">			callback.updateCurrentOffset(currentOffset);</span>
<span class="fc" id="L144">			int nameLength =IOUtil.readSignedInt(in, endian);</span>
<span class="fc" id="L145">			String name = readNullTerminatedString(in, nameLength);</span>
<span class="fc" id="L146">			int numBases =IOUtil.readSignedInt(in, endian);</span>
<span class="fc" id="L147">			int numCompactedLongs = IOUtil.readSignedInt(in, endian);</span>
<span class="fc" id="L148">			recordVisitor =visitor.visitDefline(callback, name, null);</span>
			//record length is 3 ints for lengths
<span class="fc" id="L150">			currentOffset += 12 + numCompactedLongs*16 + nameLength;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">			if(recordVisitor ==null){</span>
				//skip
				//each record is 2 * number of Compacted longs
				//once array for the bases, one array for the mask
				//and each long is 4 bytes.
<span class="fc" id="L156">				IOUtil.blockingSkip(in, numCompactedLongs *16);</span>
			}else{				
<span class="fc" id="L158">				long[] bases =IOUtil.readLongArray(in, numCompactedLongs, endian);</span>
<span class="fc" id="L159">				long[] masks =IOUtil.readLongArray(in, numCompactedLongs, endian);</span>
				
<span class="fc" id="L161">				StringBuilder basesBuilder = new StringBuilder(numBases);</span>
				//use 2 loops
				//one for [i .. length -1)
				//and another loop for the last offset
				//so we don't have to do this extra shifting and conditional checks
				//every time!
<span class="fc bfc" id="L167" title="All 2 branches covered.">				for(int i=0; i&lt;bases.length-1; i++){</span>
<span class="fc" id="L168">					long maskValue = masks[i];</span>
<span class="fc" id="L169">					long basesValue = bases[i];</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">					for(int j=31; j &gt;=0; j--){						</span>
<span class="fc" id="L171">						int baseOffset = (i&lt;&lt;5) | (31 - j);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">						if(baseOffset &gt;= numBases){</span>
<span class="nc" id="L173">							break;</span>
						}
						//shifting by 1 is like 
						//multiplying by 2
<span class="fc" id="L177">						int shiftAmount = j*2;</span>
						//order of operations 
						//should make equations worth without
						//parenthesis but it makes it easier
						//for a human to read.
<span class="fc" id="L182">						long m = (maskValue &gt;&gt; shiftAmount) &amp;3;</span>
<span class="fc" id="L183">						long n = (basesValue&gt;&gt; shiftAmount) &amp;3;</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">						char base =m ==0 ? 'N' : getBaseFromInt((int)n);</span>
<span class="fc" id="L185">						basesBuilder.append(base);</span>
					}
					
				}
<span class="fc" id="L189">				int lastOffset = bases.length-1;</span>
<span class="fc" id="L190">				long maskValue = masks[lastOffset];</span>
<span class="fc" id="L191">				long basesValue = bases[lastOffset];</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">				for(int j=31; j &gt;=0; j--){					</span>
<span class="fc" id="L193">					int baseOffset = (lastOffset&lt;&lt;5) | (31 - j);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">					if(baseOffset &gt;= numBases){</span>
<span class="fc" id="L195">						break;</span>
					}
					//shifting by 1 is like 
					//multiplying by 2
<span class="fc" id="L199">					int shiftAmount = j*2;</span>
					//order of operations 
					//should make equations worth without
					//parenthesis but it makes it easier
					//for a human to read.
<span class="fc" id="L204">					long m = (maskValue &gt;&gt; shiftAmount) &amp;3;</span>
<span class="fc" id="L205">					long n = (basesValue&gt;&gt; shiftAmount) &amp;3;</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">					char base =m ==0 ? 'N' : getBaseFromInt((int)n);</span>
<span class="fc" id="L207">					basesBuilder.append(base);</span>
				}
				
<span class="fc" id="L210">				recordVisitor.visitBodyLine(basesBuilder.toString());</span>
				
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">				if(callback.keepParsing()){</span>
<span class="fc" id="L213">					recordVisitor.visitEnd();</span>
				}
			}
<span class="fc" id="L216">		}</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">		if(!callback.keepParsing()){</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">			if(recordVisitor !=null){</span>
<span class="fc" id="L219">				recordVisitor.halted();</span>
			}
<span class="fc" id="L221">			visitor.halted();</span>
		}
<span class="fc" id="L223">		visitor.visitEnd();</span>
<span class="fc" id="L224">	}</span>
	protected abstract Callback createCallback(long currentOffset);
	
	private static char getBaseFromInt(int b){
<span class="pc bpc" id="L228" title="1 of 5 branches missed.">		switch(b){</span>
<span class="fc" id="L229">			case 0 : return 'A';</span>
<span class="fc" id="L230">			case 1 : return 'C';</span>
<span class="fc" id="L231">			case 2: return 'G';</span>
<span class="fc" id="L232">			case 3 : return 'T';</span>
			//can't happen since b has to be between 0-3
<span class="nc" id="L234">			default: throw new IllegalStateException(&quot;invalid byte value : &quot; + b);</span>
		}
	}

	private String readNullTerminatedString(OpenAwareInputStream in,
			int nameLength) throws IOException {
<span class="fc" id="L240">		byte[] b= IOUtil.readByteArray(in, nameLength);</span>
		//last byte should be null so don't need to read that
<span class="fc" id="L242">		return new String(b, 0, nameLength-1, IOUtil.UTF_8);</span>
	}

	
	
	
	
	@Override
	public void parse(FastaVisitor visitor) throws IOException {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">		if(visitor ==null){</span>
<span class="nc" id="L252">			throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
		}
<span class="fc" id="L254">		OpenAwareInputStream in =null;</span>
		try{
<span class="fc" id="L256">			in = createInputStream();		</span>
<span class="fc" id="L257">			parseBfaData(visitor, in, 0);</span>
		}finally{
<span class="pc" id="L259">			IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L260">		}</span>
		
<span class="fc" id="L262">	}</span>
	
	private static final class BfaMemento implements FastaVisitorMemento{
		private final BfaParser parserInstance;
		private final long startOffset;
		
<span class="fc" id="L268">		public BfaMemento(BfaParser parserInstance, long startOffset) {</span>
<span class="fc" id="L269">			this.parserInstance = parserInstance;</span>
<span class="fc" id="L270">			this.startOffset = startOffset;</span>
<span class="fc" id="L271">		}</span>
		
		
	}

	private interface Callback extends FastaVisitorCallback{
		public boolean keepParsing();
		
		public void updateCurrentOffset(long offset);
	}
	
	private static final class BfaFileParser extends BfaParser{
		private final File bfaFile;
		
		protected BfaFileParser(File bfaFile, ByteOrder endian) throws IOException {
<span class="fc" id="L286">			super(endian);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">			if(!bfaFile.exists()){</span>
<span class="nc" id="L288">				throw new FileNotFoundException(bfaFile.getAbsolutePath());</span>
			}		

<span class="fc" id="L291">			this.bfaFile = bfaFile;</span>
<span class="fc" id="L292">		}</span>
		
		@Override
		public boolean canCreateMemento() {
<span class="fc" id="L296">			return true;</span>
		}
		@Override
		public boolean canParse() {
<span class="fc" id="L300">			return true;</span>
		}
		@Override
		protected Callback createCallback(long currentOffset) {
<span class="fc" id="L304">			return new MementoedCallback(currentOffset);</span>
		}
		
		@Override
		public boolean isReadOnceOnly() {
			//can read multiple times
			//since we have the 
			//reference to the File
<span class="fc" id="L312">			return false;</span>
		}

		@Override
		protected OpenAwareInputStream createInputStream() throws IOException{
<span class="fc" id="L317">			return new OpenAwareInputStream(new BufferedInputStream(new FileInputStream(bfaFile)));</span>
		}

		
		
		@Override
		public void parse(FastaVisitor visitor, FastaVisitorMemento memento)
				throws IOException {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">			if(visitor ==null){</span>
<span class="nc" id="L326">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">			if(memento == null){</span>
<span class="nc" id="L329">				throw new NullPointerException(&quot;memento can not be null&quot;);</span>
			}
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">			if(!(memento instanceof BfaMemento)){</span>
<span class="nc" id="L332">				throw new IllegalArgumentException(&quot;invalid memento type, must be created by this class&quot;);</span>
			}
<span class="fc" id="L334">			BfaMemento bfaMemento = (BfaMemento) memento;</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">			if(bfaMemento.parserInstance != this){</span>
<span class="nc" id="L336">				throw new IllegalArgumentException(&quot;invalid memento, must be created by this parser instance&quot;);</span>
			}
<span class="fc" id="L338">			long startOffset = bfaMemento.startOffset;</span>

<span class="fc" id="L340">			OpenAwareInputStream in =null;</span>
			try{
				//the file isn't compressed
				//so we can seek right to the offset
				//before reading anything.
<span class="fc" id="L345">				in = new OpenAwareInputStream(new BufferedInputStream(</span>
						new RandomAccessFileInputStream(bfaFile, startOffset)));
<span class="fc" id="L347">				parseBfaData(visitor, in, startOffset);</span>
			}finally{
<span class="pc" id="L349">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L350">			}</span>
			
<span class="fc" id="L352">		}</span>
		
		private final class MementoedCallback implements Callback{
			private final AtomicBoolean keepParsing;
			private long currentOffset;
			
			private MementoedCallback(){
<span class="nc" id="L359">				this(0);</span>
<span class="nc" id="L360">			}</span>
<span class="fc" id="L361">			private MementoedCallback(long startOffset){</span>
<span class="fc" id="L362">				this.currentOffset = startOffset;</span>
<span class="fc" id="L363">				keepParsing = new AtomicBoolean(true);</span>
<span class="fc" id="L364">			}</span>
			@Override
			public boolean canCreateMemento() {
<span class="fc" id="L367">				return true;</span>
			}

			@Override
			public FastaVisitorMemento createMemento() {
<span class="fc" id="L372">				return new BfaMemento(BfaFileParser.this, currentOffset);</span>
			}

			@Override
			public void haltParsing() {
<span class="fc" id="L377">				keepParsing.set(false);</span>
<span class="fc" id="L378">			}</span>
			
			public boolean keepParsing(){
<span class="fc" id="L381">				return keepParsing.get();</span>
			}
			
			public void updateCurrentOffset(long offset){
<span class="fc" id="L385">				this.currentOffset = offset;</span>
<span class="fc" id="L386">			}</span>
		}
	}
	
	private static final class NotMementoedCallback implements Callback{
		private final AtomicBoolean keepParsing;
		
<span class="fc" id="L393">		private NotMementoedCallback(){</span>
<span class="fc" id="L394">			keepParsing = new AtomicBoolean(true);</span>
<span class="fc" id="L395">		}</span>
		
		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L399">			return false;</span>
		}

		@Override
		public FastaVisitorMemento createMemento() {
<span class="nc" id="L404">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
		}

		@Override
		public void haltParsing() {
<span class="nc" id="L409">			keepParsing.set(false);</span>
<span class="nc" id="L410">		}</span>
		
		public boolean keepParsing(){
<span class="fc" id="L413">			return keepParsing.get();</span>
		}
		
		public void updateCurrentOffset(long offset){
			//no-op
<span class="fc" id="L418">		}</span>
	}
	
	private static final class BfaInputStreamParser extends BfaParser{
		private final OpenAwareInputStream inputStream;
<span class="fc" id="L423">		private boolean hasParsedBefore= false;</span>
		
		public BfaInputStreamParser(InputStream inputStream, ByteOrder endian) {
<span class="fc" id="L426">			super(endian);</span>
<span class="fc" id="L427">			this.inputStream = new OpenAwareInputStream(inputStream);</span>
<span class="fc" id="L428">		}</span>
		
		
		@Override
		public boolean isReadOnceOnly() {
			//can only parse Stream once
<span class="fc" id="L434">			return true;</span>
		}
		@Override
		public synchronized void parse(FastaVisitor visitor) throws IOException {
			//wrap in synchronized block so we only
			//can parse one visitor at a time (probably at all)
<span class="fc" id="L440">			super.parse(visitor);</span>
<span class="fc" id="L441">		}</span>

		@Override
		public void parse(FastaVisitor visitor, FastaVisitorMemento memento)
				throws IOException {
			//we probably will never see this in real usage
			//since inputstream implementation can't make mementors...
<span class="nc" id="L448">			throw new UnsupportedOperationException(&quot;can not use mementos with inputstream&quot;);</span>
		}

		@Override
		protected OpenAwareInputStream createInputStream() throws IOException {
			//this is a work around to fix a regression
			//where we give an empty stream
			//first time should not throw an error
			//even if there is nothing to parse.
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">			if(!hasParsedBefore){</span>
<span class="fc" id="L458">				return inputStream;</span>
			}
<span class="nc" id="L460">			hasParsedBefore = true;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">			if(canParse()){</span>
<span class="nc" id="L462">				return inputStream;</span>
			}
<span class="nc" id="L464">			throw new IllegalStateException(&quot;can not accept visitor - inputstream is closed&quot;);			</span>
		}
		@Override
		public boolean canParse() {
<span class="nc" id="L468">			return inputStream.isOpen();</span>
		}
		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L472">			return false;</span>
		}


		@Override
		protected Callback createCallback(long currentOffset) {
<span class="fc" id="L478">			return new NotMementoedCallback();</span>
	}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>