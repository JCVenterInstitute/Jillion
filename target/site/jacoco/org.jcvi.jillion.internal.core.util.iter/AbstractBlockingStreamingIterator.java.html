<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractBlockingStreamingIterator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.core.util.iter</a> &gt; <span class="el_source">AbstractBlockingStreamingIterator.java</span></div><h1>AbstractBlockingStreamingIterator.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.core.util.iter;

import java.io.IOException;
import java.util.NoSuchElementException;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;

/**
 * {@code AbstractBlockingStreamingIterator}
 * is a {@link StreamingIterator} that is
 * meant be used to iterate over a large computationally intensive
 * or memory intensive process.  Only 1 record (the next record
 * to be returned by {@link Iterator#next()}) will be referenced by this class.
 * This class will perform the intensive computation in a background Thread
 * and will block that Thread until the next item to be iterated 
 * is required.  Elements to be iterated over are placed onto the blocking
 * iterator by {@link #blockingPut(Object)}.
 * &lt;strong&gt;WARNING:&lt;/strong&gt; Client code must be very careful
 * to always make sure that this iterator is closed when finished.
 * If the iterator does not reach the end or
 * if the iterator is not explicitly closed via the {@link #close()}
 * method, then the background thread will block forever. This is 
 * especially true in situations when Exceptions are thrown by other objects.
 * Please make sure {@link StreamingIterator}s are closed in finally blocks.
 * &lt;p/&gt;
 * The background thread is not started until the {@link #start()}
 * method is called.  This allows for subclasses to set up
 * and initialize themselves in either the constructor
 * or other pre-process steps.
 * &lt;p/&gt;
 * Example:
 * &lt;pre&gt; 

     //Example implementation 
     //will compute the approximate value of &amp;pi;.
     //Each BigDecimal returned by this iterator
     //will be a more accurate approximation.
    //This class computes the value of &amp;pi; using the Madhava-Leibniz series:
    //&amp;pi; = 4 &amp;sum; ( (-1)&lt;sup&gt;k&lt;/sup&gt; / (2k + 1) )
     
    class ApproximatePiIterator extends AbstractBlockingStreamingIterator&amp;lt;BigDecimal&amp;gt;{
        private final int numOfIterations;
        
        public ApproximatePiIterator(int numOfIterations) {
            this.numOfIterations = numOfIterations;
        }
        
         
        protected void backgroundThreadRunMethod() throws RuntimeException {
           
            this.blockingPut(FOUR);
            
            BigDecimal currentValue = BigDecimal.valueOf(1);
            for(int i=1; i&amp;lt;numOfIterations; i++){
                BigDecimal x = BigDecimal.valueOf(1D/(2*i+1));
                if(i%2==0){
                    currentValue = currentValue.add(x);
                }else{
                    currentValue = currentValue.subtract(x);
                }
                this.blockingPut(currentValue.multiply(FOUR));
            }
        }
        
    }
    
    public static void main(String[] args){
        ApproximatePiIterator approxPi = new ApproximatePiIterator(1_000_000);
        approxPi.start();
        try{
           while(approxPi.hasNext()){
              System.out.println(approxPi.next());
           }
        }finally{
           IOUtil.closeAndIgnoreErrors(approxPi.close());
        }
    }
 * &lt;/pre&gt;
 * 
 * @author dkatzel
 *
 * @param &lt;T&gt; the type of elements being iterated over.
 */
<span class="fc" id="L108">public abstract class AbstractBlockingStreamingIterator&lt;T&gt; implements StreamingIterator&lt;T&gt;{</span>

<span class="fc" id="L110">	private final Object endOfFileToken = new Object();</span>
<span class="fc" id="L111">    private final BlockingQueue&lt;Object&gt; queue = new LinkedBlockingQueue&lt;Object&gt;(1);</span>
<span class="fc" id="L112">    private volatile Object nextRecord=null;</span>
<span class="fc" id="L113">    private volatile boolean isClosed=false;</span>
    
    private volatile RuntimeException uncaughtException;

    /**
     * @throws InterruptedException 
     * 
     */
    private void blockingGetNextRecord(){
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if(!isClosed){</span>
            try {
<span class="fc" id="L124">            	Object obj =null;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            	while(obj ==null){</span>
            		//to avoid a deadlock we will 
            		//stop blocking after 1 second
            		//to check if an exception was thrown
<span class="fc" id="L129">            		obj = queue.poll(1, TimeUnit.SECONDS);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            		if(obj ==null){</span>
            			//check exception
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">            			if(uncaughtException !=null){</span>
<span class="fc" id="L133">            				nextRecord = null;</span>
<span class="fc" id="L134">            				break;</span>
            			}
            		}else{
<span class="fc" id="L137">            			nextRecord = obj;</span>
            		}
            	}
				
<span class="nc" id="L141">			} catch (InterruptedException e) {</span>
				//assume interrupted is closed?
<span class="nc" id="L143">				IOUtil.closeAndIgnoreErrors(this);</span>
<span class="fc" id="L144">			}     </span>
        }
<span class="fc" id="L146">    }</span>
    /**
     * This starts the visiting in a separate thread.
     * This method must be called before a client may call
     * {@link #hasNext()} or {@link #next()}.
     */
    public void start(){
<span class="fc" id="L153">      final IteratorThread iteratorThread =new IteratorThread();</span>
<span class="fc" id="L154">        iteratorThread.start();</span>
        //if the vm exits while we are still blocking
        //we will run forever...
        //add shutdown hook to try to kill ourselves
<span class="fc" id="L158">        Runtime.getRuntime().addShutdownHook(new Thread(){</span>
            @Override
            public void run() {
<span class="fc" id="L161">                iteratorThread.kill();</span>
<span class="fc" id="L162">            }</span>
        });
<span class="fc" id="L164">        blockingGetNextRecord();</span>
		
<span class="fc" id="L166">    }</span>
    /**
     * This is the method that is called by the {@link Thread#run()}
     * instance in the background thread created and started 
     * in {@link #start()}.  Please set up and start the items
     * being iterated over.  Make sure
     * to call
     * {@link #blockingPut(Object)} when appropriate. 
     * Any uncaught exceptions will be thrown by the 
     * thread using the iterator the next time
     * {@link #next()} or {@link #hasNext()}
     * is used.
     * @throws RuntimeException - any exception not caught or handled by this background
     * thread should throw a RunTimeException which will be thrown
     * on the next call to {@link #next()} or {@link #hasNext()}.
     * 
     */
    protected abstract void backgroundThreadRunMethod() throws RuntimeException;
	/**
	 * This method must be called when the visitor has finished
	 * visiting in order to let the iterator know that there
	 * are no more records left to block for.
	 */
    private void finishedIterating(){
<span class="fc" id="L190">    	blockingPut(endOfFileToken);</span>
<span class="fc" id="L191">    }</span>
    /**
     * Put the given object onto the queue to be iterated over
     * and block until there is room for it in the queue.
     * @param obj the object to put.
     */
    public final void blockingPut(Object obj){
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if(!isClosed){</span>
	        try {
<span class="fc" id="L200">	            queue.put(obj);</span>
<span class="nc" id="L201">	        } catch (InterruptedException e) {</span>
<span class="nc" id="L202">	            throw new IllegalStateException(e);</span>
<span class="fc" id="L203">	        }</span>
	    }
<span class="fc" id="L205">    }</span>
    /**
     * 
    * {@inheritDoc}
    * &lt;p&gt;
    * Not supported.
    * @throws UnsupportedOperationException always.
     */
	@Override
	public final void remove() {
<span class="nc" id="L215">		throw new UnsupportedOperationException();		</span>
	}

	/**
    * {@inheritDoc}
    */
    @Override
    public final void close(){
<span class="fc bfc" id="L223" title="All 2 branches covered.">    	if(isClosed){</span>
<span class="fc" id="L224">    		return;</span>
    	}
<span class="fc" id="L226">        isClosed=true;</span>
<span class="fc" id="L227">        nextRecord=endOfFileToken;</span>
<span class="fc" id="L228">        queue.clear();	        </span>
<span class="fc" id="L229">    }</span>
	
    private void setErroredOut(RuntimeException uncaughtException){
<span class="fc" id="L232">		AbstractBlockingStreamingIterator.this.uncaughtException = uncaughtException;</span>
<span class="fc" id="L233">		nextRecord=endOfFileToken;</span>
		
<span class="fc" id="L235">		queue.clear();</span>
<span class="fc" id="L236">    }</span>
	/**
	 * Safety-net to close the iterator
	 * in case it hasn't been closed already.
	 * Client code should always explicitly
	 * close a {@link StreamingIterator}
	 * but this finalizer is used just in case.
	 * This method can not be relied upon 
	 * since an object is not guaranteed to 
	 * get finalized by the garbage collector.
	 */
    @Override
	protected void finalize() throws IOException {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    	if(!isClosed){</span>
<span class="nc" id="L250">    		close();</span>
    	}
<span class="nc" id="L252">	}</span>
		/**
	    * {@inheritDoc}
	    */
	    @Override
	    public final T next() {
<span class="fc bfc" id="L258" title="All 2 branches covered.">	        if(!hasNext()){</span>
<span class="fc" id="L259">	            throw new NoSuchElementException(&quot;no records&quot;);</span>
	        }
	        //if we are here then nextRecord must
	        //be type T so we can safely cast
	        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L264">			T next = (T)nextRecord;</span>
<span class="fc" id="L265">            blockingGetNextRecord();</span>
	        
<span class="fc" id="L267">	        return next;</span>
	    }

	    
	     @Override
	     @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
	     public final boolean hasNext() {
<span class="fc bfc" id="L274" title="All 4 branches covered.">	         if(!isClosed &amp;&amp; uncaughtException !=null){</span>
<span class="fc" id="L275">                throw uncaughtException;</span>
             }
	         
<span class="fc bfc" id="L278" title="All 4 branches covered.">	        return !isClosed &amp;&amp; nextRecord !=endOfFileToken;</span>
	     }
	    
	     
	     /**
	 	 * @return the isClosed
	 	 */
	     public final boolean isClosed() {
<span class="fc" id="L286">	 		return isClosed;</span>
	 	}

	     /**
	      * Background thread that runs this iterator
	      * and can be killed
	      * @author dkatzel
	      *
	      *
	      */
<span class="fc" id="L296">	     private class IteratorThread extends Thread{</span>
	         /**
	          * closes the blocked iterator.
	          */
	         public void kill(){
<span class="fc" id="L301">	             IOUtil.closeAndIgnoreErrors(AbstractBlockingStreamingIterator.this);                </span>
<span class="fc" id="L302">	         }</span>
	         @Override
	         public void run() {
	             try{
<span class="fc" id="L306">	                 backgroundThreadRunMethod();</span>
<span class="fc" id="L307">	                 finishedIterating();</span>
<span class="fc" id="L308">	             }catch(RuntimeException e){</span>
<span class="fc" id="L309">	            	 setErroredOut(e);                </span>
<span class="fc" id="L310">	             }</span>
<span class="fc" id="L311">	         }</span>
	     }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>