<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IteratorUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.util.iter</a> &gt; <span class="el_source">IteratorUtil.java</span></div><h1>IteratorUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core.util.iter;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.RandomAccess;
import java.util.function.Function;
import java.util.function.Supplier;


public final class IteratorUtil {

<span class="nc" id="L36">	private IteratorUtil(){</span>
		//can not instantiate
<span class="nc" id="L38">	}</span>
	
	/**
     * Creates an {@link Iterator} of Type E
     * that does not have any elements.
     * @param &lt;E&gt; the type of element to be iterated over.
     * @return an instance of {@link Iterator};
     * never null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt;  Iterator&lt;E&gt; createEmptyIterator(){
<span class="fc" id="L49">        return EmptyIterator.INSTANCE;</span>
    }
    
    /**
     * Creates an {@link StreamingIterator} of Type E
     * that does not have any elements.
     * @param &lt;E&gt; the type of element to be iterated over.
     * @return an instance of {@link StreamingIterator};
     * never null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt;  StreamingIterator&lt;E&gt; createEmptyStreamingIterator(){
<span class="fc" id="L61">        return IteratorUtil.createStreamingIterator(EmptyIterator.INSTANCE);</span>
    }
    /**
     * Creates an efficient {@link Iterator} over an array.
     * 
     * @param array the array to iterate over; can not be null.
     * 
     * @param &lt;E&gt; the type of elements to be iterated over.
     */
    public static &lt;E&gt; Iterator&lt;E&gt; createIteratorFromArray(E[] array){
<span class="fc" id="L71">    	return new ArrayIterator&lt;E&gt;(array);</span>
    }
    /**
     * Create a new {@link PeekableStreamingIterator} instance
     * which wraps the given iterator.
     * @param iter the Iterator to wrap in a peekable iterator; can not be null.
     * 
     * @return a new {@link PeekableStreamingIterator};
     * never null.
     * @throws NullPointerException if iter is null.
     * 
     * @param &lt;E&gt; the type of elements to be iterated over.
     */
    public static &lt;E&gt; PeekableIterator&lt;E&gt; createPeekableIterator(Iterator&lt;E&gt; iter){
<span class="fc" id="L85">    	return new PeekableIteratorImpl&lt;E&gt;(iter);</span>
    }
    /**
     * Create a new {@link StreamingIterator} instance
     * which wraps the given iterator.
     * @param iter the Iterator to wrap in a streaming iterator; can not be null.
     * @return a new {@link StreamingIterator};
     * never null.
     * @throws NullPointerException if iter is null.
     * 
     * @param &lt;E&gt; the type of elements to be iterated over.
     */
    public static &lt;E&gt; StreamingIterator&lt;E&gt; createStreamingIterator(Iterator&lt;E&gt; iter){
<span class="fc" id="L98">    	return StreamingIteratorAdapter.adapt(iter);</span>
    }
    /**
     * Create a new {@link PeekableStreamingIterator} instance
     * which wraps the given iterator.
     * @param iter the Iterator to wrap in a peekable streaming iterator; can not be null.
     * @return a new {@link PeekableStreamingIterator};
     * never null.
     * @throws NullPointerException if iter is null.
     * 
     * @param &lt;E&gt; the type of elements to be iterated over.
     */
    public static &lt;E&gt; PeekableStreamingIterator&lt;E&gt; createPeekableStreamingIterator(Iterator&lt;E&gt; iter){
<span class="fc" id="L111">    	return new PeekableStreamingIteratorImpl&lt;E&gt;(createStreamingIterator(iter));</span>
    }
    
    /**
     * Convenience method to create a new {@link PeekableIterator}
     * from an {@link Iterable}.  This is the same as
     * {@link #createPeekableIterator(Iterator) createPeekableIterator(iter.iterator()}
     * @param iter the Iterable to use; can not be null.
     * @return a new {@link PeekableStreamingIterator};
     * never null.
     * @throws NullPointerException if iter is null.
     * 
     * @param &lt;E&gt; the type of elements to be iterated over.
     */
    public static &lt;E&gt; PeekableIterator&lt;E&gt; createPeekableIterator(Iterable&lt;E&gt; iter){
<span class="nc" id="L126">    	return createPeekableIterator(iter.iterator());</span>
    }
    /**
     * Convenience method to create a new {@link StreamingIterator}
     * from an {@link Iterable}.  This is the same as
     * {@link #createStreamingIterator(Iterator) createStreamingIterator(iter.iterator()}
     * @param iter the Iterable to use; can not be null.
     * @return a new {@link StreamingIterator};
     * never null.
     * @throws NullPointerException if iter is null.
     */
    public static &lt;E&gt; StreamingIterator&lt;E&gt; createStreamingIterator(Iterable&lt;E&gt; iter){
<span class="nc" id="L138">    	return createStreamingIterator(iter.iterator());</span>
    }
    /**
     * Convenience method to create a new {@link PeekableStreamingIterator}
     * from an {@link Iterable}.  This is the same as
     * {@link #createPeekableStreamingIterator(Iterator) createPeekableStreamingIterator(iter.iterator()}
     * @param iter the Iterable to use; can not be null.
     * @return a new {@link PeekableStreamingIterator};
     * never null.
     * @throws NullPointerException if iter is null.
     */
    public static &lt;E&gt; PeekableStreamingIterator&lt;E&gt; createPeekableStreamingIterator(Iterable&lt;E&gt; iter){
<span class="nc" id="L150">    	return createPeekableStreamingIterator(iter.iterator());</span>
    }
    
    
    public static &lt;E&gt; PeekableStreamingIterator&lt;E&gt; createPeekableStreamingIterator(StreamingIterator&lt;E&gt; iter){
<span class="fc" id="L155">    	return new PeekableStreamingIteratorImpl&lt;E&gt;(iter);</span>
    }
    /**
     * Create a new {@link Iterator} instance
     * that wraps several {@link Iterator}s behind a single
     * {@link Iterator} instance.  Once all the elements in the first
     * iterator have been iterated over, the next iterator in the chain
     * gets used.
     * @return a new {@link Iterator} instance; never null.
     * @throws NullPointerException if the input collection
     * is null or if any element in the collection is null.
     */
    public static &lt;E&gt; Iterator&lt;E&gt; createChainedIterator(Collection&lt;? extends Iterator&lt;E&gt;&gt; iterators){
<span class="nc" id="L168">    	return ChainedIterator.create(iterators);</span>
    }
    /**
     * Create a new {@link StreamingIterator} instance
     * that wraps several {@link StreamingIterator}s behind a single
     * {@link StreamingIterator} instance.  Once all the elements in the first
     * iterator have been iterated over, the next iterator in the chain
     * gets used.  If at any time, {@link StreamingIterator#close()}
     * is called, then all downstream {@link StreamingIterator} are closed as well.
     * @return a new {@link StreamingIterator} instance; never null.
     * @throws NullPointerException if the input collection
     * is null or if any element in the collection is null.
     */
    public static &lt;E&gt; StreamingIterator&lt;E&gt; createChainedStreamingIterator(Collection&lt;? extends StreamingIterator&lt;? extends E&gt;&gt; iterators){
<span class="fc" id="L182">    	return new ChainedStreamingIterator&lt;E&gt;(iterators);</span>
    }
    private static class PeekableIteratorImpl&lt;T&gt; implements PeekableIterator&lt;T&gt;{

    	private final Iterator&lt;T&gt; iter;
    	private T next;
<span class="fc" id="L188">    	private boolean doneIterating=false;</span>
    	
<span class="fc" id="L190">		PeekableIteratorImpl(Iterator&lt;T&gt; iter) {</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">			if(iter==null){</span>
<span class="nc" id="L192">				throw new NullPointerException();</span>
			}
<span class="fc" id="L194">			this.iter = iter;</span>
<span class="fc" id="L195">			updateNext();</span>
<span class="fc" id="L196">		}</span>
		
		private void updateNext(){
<span class="fc bfc" id="L199" title="All 2 branches covered.">			if(iter.hasNext()){</span>
<span class="fc" id="L200">				next=iter.next();</span>
			}else{
<span class="fc" id="L202">				doneIterating=true;</span>
			}
<span class="fc" id="L204">		}</span>
		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L207" title="All 2 branches covered.">			return !doneIterating;</span>
		}
		@Override
		public T next() {
<span class="fc" id="L211">			T ret = next;</span>
<span class="fc" id="L212">			updateNext();</span>
<span class="fc" id="L213">			return ret;</span>
		}
		
		@Override
		public void remove() {
<span class="nc" id="L218">			throw new UnsupportedOperationException(&quot;peekable iterators can not remove&quot;);</span>
			
		}
		@Override
		public T peek() {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">			if(hasNext()){</span>
<span class="fc" id="L224">				return next;</span>
			}
<span class="nc" id="L226">			throw new NoSuchElementException();</span>
		}
    	
    	
    }
    
    private static class PeekableStreamingIteratorImpl&lt;T&gt; implements PeekableStreamingIterator&lt;T&gt;{

    	private final StreamingIterator&lt;T&gt; iter;
    	private T next;
<span class="fc" id="L236">    	private boolean doneIterating=false;</span>
    	
<span class="fc" id="L238">    	PeekableStreamingIteratorImpl(StreamingIterator&lt;T&gt; iter) {</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    		if(iter==null){</span>
<span class="nc" id="L240">				throw new NullPointerException();</span>
			}
<span class="fc" id="L242">			this.iter = iter;</span>
<span class="fc" id="L243">			updateNext();</span>
<span class="fc" id="L244">		}</span>
		
		private void updateNext(){
<span class="fc bfc" id="L247" title="All 2 branches covered.">			if(iter.hasNext()){</span>
<span class="fc" id="L248">				next=iter.next();</span>
			}else{
<span class="fc" id="L250">				doneIterating=true;</span>
			}
<span class="fc" id="L252">		}</span>
		
		@Override
		public void close() {
<span class="fc" id="L256">			doneIterating=true;</span>
<span class="fc" id="L257">			iter.close();</span>
			
<span class="fc" id="L259">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L263" title="All 2 branches covered.">			return !doneIterating;</span>
		}
		@Override
		public T next() {
<span class="fc bfc" id="L267" title="All 2 branches covered.">			if(hasNext()){</span>
<span class="fc" id="L268">				T ret = next;</span>
<span class="fc" id="L269">				updateNext();</span>
<span class="fc" id="L270">				return ret;</span>
			}
<span class="fc" id="L272">			throw new NoSuchElementException();</span>
		}
		
		@Override
		public void remove() {
<span class="nc" id="L277">			throw new UnsupportedOperationException(&quot;peekable iterators can not remove&quot;);</span>
			
		}
		@Override
		public T peek() {
<span class="fc bfc" id="L282" title="All 2 branches covered.">			if(hasNext()){</span>
<span class="fc" id="L283">				return next;</span>
			}
<span class="fc" id="L285">			throw new NoSuchElementException();</span>
		}
    }
    
    /**
     * {@code EmptyIterator} is a NullObject implementation
     * of {@link Iterator}; an EmptyIterator will never 
     * have any elements to iterate over.
     * @author dkatzel
     *
     *
     */
    private static final class EmptyIterator&lt;E&gt; implements Iterator&lt;E&gt; {
        /**
         * Singleton instance of Empty iterator that can be shared 
         * by all.
         */
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L303">    	static final EmptyIterator INSTANCE  = new EmptyIterator();</span>
        /**
         * Private constructor so no one can subclass.
         */
<span class="fc" id="L307">        private EmptyIterator(){}</span>
        /**
         * Never has a next.
         * @return {@code false}
         */
        @Override
        public boolean hasNext() {
<span class="fc" id="L314">            return false;</span>
        }
        /**
         * Will always throw an NoSuchElementException.
         * @throws NoSuchElementException because there will never be a next.
         */
        @Override
        public E next() {
<span class="fc" id="L322">            throw new NoSuchElementException(&quot;no elements in empty iterator&quot;);</span>
        }
        /**
         * Does nothing.
         */
        @Override
        public void remove() {
            //no-op
<span class="fc" id="L330">        }</span>

    }
    /**
     * Interface for converting one type into
     * another.
     * @author dkatzel
     *
     * @param &lt;From&gt; the input type to be converted.
     * @param &lt;To&gt; the output type that is converted from.
     */
    public interface TypeAdapter&lt;From, To&gt;{
    	/**
    	 * Convert the given {@literal &lt;From&gt;} type into
    	 * the {@literal &lt;To&gt;} type.
    	 * @param from the instance to convert.  It is possible
    	 * that this parameter is null.
    	 * @return a new {@literal &lt;To&gt;} or  {@code null}.
    	 */
    	To adapt(From from);
    }
    
    public static &lt;From, To&gt; StreamingIterator&lt;To&gt; createStreamingIterator(StreamingIterator&lt;From&gt; iter, TypeAdapter&lt;From,To&gt; adapter){
<span class="nc" id="L353">    	return new AdaptedStreamingIterator&lt;From,To&gt;(iter, adapter);</span>
    }
    
    public static &lt;From, To&gt; StreamingIterator&lt;To&gt; createStreamingIterator(Iterator&lt;From&gt; iter, TypeAdapter&lt;From,To&gt; adapter){
<span class="fc" id="L357">    	return new AdaptedStreamingIterator&lt;From,To&gt;(createStreamingIterator(iter), adapter);</span>
    }
    
    private static final class AdaptedStreamingIterator&lt;From, To&gt; implements StreamingIterator&lt;To&gt;{

    	private final StreamingIterator&lt;From&gt; delegate;
    	private final TypeAdapter&lt;From,To&gt; adapter;
    	
<span class="fc" id="L365">		public AdaptedStreamingIterator(StreamingIterator&lt;From&gt; delegate, TypeAdapter&lt;From,To&gt; adapter) {</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">			if(delegate ==null){</span>
<span class="nc" id="L367">				throw new NullPointerException(&quot;delegate can not be null&quot;);</span>
			}
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">			if(adapter ==null){</span>
<span class="nc" id="L370">				throw new NullPointerException(&quot;adapter can not be null&quot;);</span>
			}
<span class="fc" id="L372">			this.delegate = delegate;</span>
<span class="fc" id="L373">			this.adapter = adapter;</span>
<span class="fc" id="L374">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L378">			return delegate.hasNext();</span>
		}

		@Override
		public void close() {
<span class="fc" id="L383">			delegate.close();</span>
			
<span class="fc" id="L385">		}</span>

		@Override
		public To next() {
<span class="fc" id="L389">			return adapter.adapt(delegate.next());</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L394">			delegate.remove();</span>
			
<span class="nc" id="L396">		}</span>
    	
    }
    /**
     * Map the values in the given iterator to a different type.
     * @param iter the input {@link Iterator}; can not be null.
     * @param mapper a function that converts the types in the input iterator into
     * the return type. Can not be null but if the input iterator contains nulls, this mapper must support nulls as well.
     * @return a new Iterator of the return type.
     * 
     * @throws NullPointerException if any parameter is null.
     * @since 5.3
     */
    public static &lt;T, R&gt; Iterator&lt;R&gt; map(Iterator&lt;T&gt; iter, Function&lt;T, R&gt; mapper) {
<span class="nc" id="L410">        Objects.requireNonNull(iter);</span>
<span class="nc" id="L411">        Objects.requireNonNull(mapper);</span>
        
<span class="nc" id="L413">        return new Iterator&lt;R&gt;() {</span>

            @Override
            public boolean hasNext() {
<span class="nc" id="L417">                return iter.hasNext();</span>
            }

            @Override
            public R next() {
<span class="nc" id="L422">                return mapper.apply(iter.next());</span>
            }
        };
    }
    @SafeVarargs
    public static &lt;T&gt; StreamingIterator&lt;T&gt; chainStreamingSuppliers(Supplier&lt;? extends StreamingIterator&lt;? extends T&gt;&gt;... suppliers) {
<span class="fc" id="L428">        return chainStreamingSuppliers(Arrays.asList(suppliers));</span>
    }
        
    public static &lt;T&gt; StreamingIterator&lt;T&gt; chainStreamingSuppliers(Collection&lt;? extends Supplier&lt;? extends StreamingIterator&lt;? extends T&gt;&gt;&gt; suppliers) {
<span class="fc" id="L432">        return new ChainedStreamingIteratorFromSuppliers&lt;&gt;(suppliers);</span>
        
    }
    
    @SafeVarargs
    public static &lt;T&gt; Iterator&lt;T&gt; chainSuppliers(Supplier&lt;? extends Iterator&lt;? extends T&gt;&gt;... suppliers) {
<span class="fc" id="L438">        return chainSuppliers(Arrays.asList(suppliers));</span>
    }
        
    public static &lt;T&gt; Iterator&lt;T&gt; chainSuppliers(Collection&lt;? extends Supplier&lt;? extends Iterator&lt;? extends T&gt;&gt;&gt; suppliers) {
<span class="fc" id="L442">        return ChainedIteratorOfSuppliers.create(suppliers);</span>
        
    }
    /**
     *  Create a new Iterator that will iterate over the given list and start over again
     *  when it reaches the end of the list.  This iterator will never end if the list is not empty.
     * @param randomAccessList a list that implements the RandomAccess marker interface.
     * 
     * @return a new Iterator that starts at the beginning of the list.
     * 
     * @since 5.3
     */
    public static &lt;T, L extends List&lt;T&gt; &amp; RandomAccess&gt; Iterator&lt;T&gt; rollover(L randomAccessList){
<span class="nc" id="L455">        return new RollOverListIterator&lt;T&gt;(randomAccessList);</span>
        
    }
    /**
     *  Create a new Iterator that will iterate over the given list and start over again
     *  when it reaches the end of the list.  This iterator will never end if the list is not empty.
     * @param randomAccessList a list that implements the RandomAccess marker interface.
     * 
     * @param startOffset the offset to start iterating from.  If this value is beyond the list size,
     * then the start location will roll over accordingly.
     * 
     * @return a new Iterator that starts at the specified offset.
     * 
     * @since 5.3
     */
    public static &lt;T, L extends List&lt;T&gt; &amp; RandomAccess&gt; Iterator&lt;T&gt; rollover(L randomAccessList, int startOffset){
<span class="fc" id="L471">        return new RollOverListIterator&lt;T&gt;(randomAccessList, startOffset);</span>
        
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>