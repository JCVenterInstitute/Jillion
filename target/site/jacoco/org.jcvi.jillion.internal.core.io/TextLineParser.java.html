<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TextLineParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.core.io</a> &gt; <span class="el_source">TextLineParser.java</span></div><h1>TextLineParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.core.io;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.util.FIFOQueue;
import org.jcvi.jillion.internal.core.util.GrowableCharArray;
/**
 * {@code TextLineParser} can read lines from on {@link InputStream}.  The main
 * difference between TextLineParser and other similar JDK classes is TextLineParser
 * will include the end of line characters in the {@link #nextLine()}
 * methods.  Most JDK classes chop off these characters and the few classes
 * that could could be configured to include these characters are slow.
 * This class considers a line to be terminated by either '\n',
 * (UNIX format) or '\r\n' (Windows/DOS) or '\r' (Apple family until Mac OS 9). 
 * &lt;p/&gt;
 * This class is not Thread-safe
 * @author dkatzel
 *
 *
 */
public final class TextLineParser implements LineParser{
	/**
	 * {@value} chars, is the initial
	 * capacity since this is probably
	 * going to be mostly used by 
	 * human readable text files and
	 * genomic file formats which often
	 * are &lt; 100 characters per line.
	 * If the line is longer, then the buffer
	 * will grow accordingly.
	 */
	private static final int INITIAL_LINE_CAPACITY = 200;
	
	/**
	 * Our pushed back byte is not set.
	 */
	private static final int NOT_SET = -2;
	/**
	 * End of File.
	 */
	private static final int EOF = -1;
	/**
	 * Line feed.
	 */
	private static final char LF = '\n';
	/**
	 * Carriage return.
	 */
	private static final char CR = '\r';
	
	private final InputStream in;
<span class="pc" id="L77">	private final Object endOfFile = new Object();</span>
<span class="pc" id="L78">	private final FIFOQueue&lt;Object&gt; nextQueue = new FIFOQueue&lt;Object&gt;();</span>
<span class="pc" id="L79">	boolean doneFile = false;</span>
	
	private long position;
	private int numberOfBytesInNextLine;
	/**
	 * This is an extra byte we read from
	 * the previous line that we
	 * want to &quot;unread&quot; so we can read it again
	 * in the next line.
	 * 
	 * This is used to distinguish from
	 * some older operating systems which use 
	 * '\r\n' from '\r' as end of line strings.
	 * If it's the later, the byte after 
	 * '\r' is &quot;unread&quot; so it can be read again
	 * as the beginning of the next line.
	 * 
	 *  This is used instead of a PushBackInputStream
	 *  because it is faster to only check
	 *  the unread byte once per
	 *  getLine() call instead of every read().
	 */
<span class="pc" id="L101">	private int pushedBackValue=NOT_SET;</span>
	
	public TextLineParser(File f) throws IOException{
<span class="fc" id="L104">		this(new BufferedInputStream(new FileInputStream(f)));</span>
<span class="fc" id="L105">	}</span>
<span class="nc" id="L106">	public TextLineParser(File samFile, long initialPosition) throws IOException {</span>
		
<span class="nc" id="L108">		this.position = initialPosition;</span>
<span class="nc" id="L109">		this.in = new RandomAccessFileInputStream(samFile, initialPosition);</span>
<span class="nc" id="L110">		getNextLine();</span>
<span class="nc" id="L111">	}</span>
	public TextLineParser(InputStream in) throws IOException{
<span class="fc" id="L113">		this(in, 0L);</span>
<span class="fc" id="L114">	}</span>
	
<span class="fc" id="L116">	public TextLineParser(InputStream in, long initialPosition) throws IOException{</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		if(in ==null){</span>
<span class="fc" id="L118">			throw new NullPointerException(&quot;inputStream can not be null&quot;);</span>
		}
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		if(initialPosition &lt;0){</span>
<span class="nc" id="L121">			throw new IllegalArgumentException(&quot;initial position must be &gt;=0&quot;);</span>
		}
<span class="fc" id="L123">		this.position = initialPosition;</span>
<span class="fc" id="L124">		this.in = in;</span>
<span class="fc" id="L125">		getNextLine();</span>
<span class="fc" id="L126">	}</span>
	
	
	private void getNextLine() throws IOException{
<span class="fc bfc" id="L130" title="All 2 branches covered.">		if(doneFile){</span>
<span class="fc" id="L131">			return;</span>
		}
<span class="fc" id="L133">		GrowableCharArray builder = new GrowableCharArray(INITIAL_LINE_CAPACITY);</span>
		int value;
<span class="fc bfc" id="L135" title="All 2 branches covered.">		if(pushedBackValue ==NOT_SET){</span>
<span class="fc" id="L136">			value = in.read();</span>
		}else{			
<span class="fc" id="L138">			value = pushedBackValue;</span>
<span class="fc" id="L139">			pushedBackValue=NOT_SET;</span>
		}
<span class="fc" id="L141">		numberOfBytesInNextLine=0;</span>
		
		
		while(true){	
<span class="fc bfc" id="L145" title="All 2 branches covered.">			if(value == EOF){</span>
<span class="fc" id="L146">				doneFile =true;</span>
<span class="fc" id="L147">				close();</span>
<span class="fc" id="L148">				break;</span>
			}
<span class="fc" id="L150">			++numberOfBytesInNextLine;</span>
<span class="fc" id="L151">			builder.append((char)value);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">			if(value == CR){</span>
				//check if next value is LF
				//since CR+LF is how Windows represents an end of line
<span class="fc" id="L155">				int nextChar = in.read();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">				if(nextChar == LF){</span>
<span class="fc" id="L157">					++numberOfBytesInNextLine;</span>
<span class="fc" id="L158">					builder.append(LF);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">				}else if(nextChar !=EOF){</span>
					//not windows formatted line
					//could be Mac 0S 9 which only uses '\r'
					//put that value back
<span class="fc" id="L163">					pushedBackValue =nextChar;</span>
				}
				
				break;
			}
<span class="fc bfc" id="L168" title="All 2 branches covered.">			if(value == LF){</span>
<span class="fc" id="L169">				break;</span>
			}
<span class="fc" id="L171">			value = in.read();</span>
		}
<span class="fc bfc" id="L173" title="All 2 branches covered.">		if(builder.getCurrentLength()&gt;0){</span>
<span class="fc" id="L174">			nextQueue.add(builder.createNewString());</span>
		}
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if(doneFile){</span>
<span class="fc" id="L177">			nextQueue.add(endOfFile);</span>
		}
		
<span class="fc" id="L180">	}</span>
	
	/**
	 * Get the number of bytes returned by
	 * {@link #nextLine()} so far.
	 * The value returned is not affected
	 * by how much looking ahead or 
	 * buffering has been done to the
	 * underlying input stream.
	 * @return a number &gt;=0.
	 */
	@Override
	public long getPosition() {
<span class="fc" id="L193">		return position;</span>
	}

	/**
	 * Does the inputStream have another line
	 * to read.  If there are no more lines to read,
	 * then {@link #nextLine()} will return {@code null}.
	 * @return {@code true} if there are more lines to be read;
	 * {@code false} otherwise.
	 * @see #nextLine()
	 */
	@Override
    @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
	public boolean hasNextLine(){
<span class="fc" id="L207">		Object next = nextQueue.peek();</span>
		
<span class="fc bfc" id="L209" title="All 2 branches covered.">		return next!= endOfFile;</span>
	}
	/**
	 * Get the next line (including end of line characters)
	 * but without advancing the position into the 
	 * stream.  Calling this method multiple times without
	 * calling {@link #nextLine()} in between will
	 * return the same String.
	 * @return the String that will be returned by 
	 * {@link #nextLine()} without actually advancing
	 * to the next line.
	 * 
	 */
	@Override
    @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
	public String peekLine(){
<span class="fc" id="L225">		Object next= nextQueue.peek();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">		if(next == endOfFile){</span>
<span class="fc" id="L227">			return null;</span>
		}
<span class="fc" id="L229">		return (String)next;</span>
	}
	/**
	 * Get the next line (including end of line characters)
	 * as a String.
	 * @return a the next line; or {@code null} if there are no
	 * more lines.
	 * @throws IOException if there is a problem reading the next
	 * line.
	 */
	@Override
    @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
	public String nextLine() throws IOException{
<span class="fc" id="L242">		Object next= nextQueue.poll();</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">		if(next == endOfFile){</span>
<span class="nc" id="L244">			return null;</span>
		}
<span class="fc" id="L246">		position+=numberOfBytesInNextLine;</span>
<span class="fc" id="L247">		getNextLine();</span>
<span class="fc" id="L248">		return (String)next;</span>
	}
	/**
	 * 
	 * {@inheritDoc}
	 */
        @Override
	public void close() throws IOException {
<span class="fc" id="L256">		IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L257">		nextQueue.clear();</span>
		
<span class="fc" id="L259">	}</span>
    @Override
    public boolean tracksPosition() {
<span class="fc" id="L262">        return true;</span>
    }
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>