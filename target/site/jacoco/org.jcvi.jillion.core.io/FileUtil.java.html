<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FileUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.io</a> &gt; <span class="el_source">FileUtil.java</span></div><h1>FileUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core.io;

import java.io.File;
import java.io.IOException;

import org.jcvi.jillion.internal.core.util.LIFOQueue;
/**
 * {@code FileUtil} is a Utility class
 * containing common static methods to work with {@link File}
 * objects.
 * @author dkatzel
 *
 */
public final class FileUtil {
	/**
     * The Unix separator character.  We need to explicitly hardcode
     * this value since we need to check against unix and windows
     * and not rely on the OS to tell us which one to use.
     * 
     */
    private static final char UNIX_SEPARATOR = '/';

    /**
     * The Windows separator character.  We need to explicitly hardcode
     * this value since we need to check against unix and windows
     * and not rely on the OS to tell us which one to use.
     */
    private static final char WINDOWS_SEPARATOR = '\\';
    
<span class="nc" id="L50">    private FileUtil(){</span>
    	//can not instantiate.
<span class="nc" id="L52">    }</span>
    /**
	 * Creates a String of the relative path from the given root to the other given file.
	 * @param root the File to start from.
	 * @param otherFile the File to get to.
	 * @return a String of containing the relative file path required
	 * to traverse the file system to get from one file to the other.
	 * @throws IOException if there is a problem finding the location of either
	 * file on the file system.
	 */
	public static String createRelavitePathFrom(File root, File otherFile) throws IOException{
<span class="nc" id="L63">		return createRelavitePathFrom(root, otherFile, File.separatorChar);</span>
	}
	/**
	 * Creates a String of the relative path from the given root to the other given file.
	 * @param root the File to start from.
	 * @param otherFile the File to get to.
	 * @param pathSeparator the path separator for this File system.
	 * @return a String of containing the relative file path required
	 * to traverse the file system to get from one file to the other.
	 * @throws IOException if there is a problem finding the location of either
	 * file on the file system.
	 */
	public static String createRelavitePathFrom(File root, File otherFile, char pathSeparator) throws IOException{
<span class="fc" id="L76">		LIFOQueue&lt;String&gt; rootStack = getCanonicalStackFor(root);</span>
<span class="fc" id="L77">		LIFOQueue&lt;String&gt; otherStack = getCanonicalStackFor(otherFile);</span>
		
		//find point where elements on stack no longer equal
<span class="fc bfc" id="L80" title="All 6 branches covered.">		while(!rootStack.isEmpty() &amp;&amp; !otherStack.isEmpty() &amp;&amp; rootStack.peek().equals(otherStack.peek())){</span>
<span class="fc" id="L81">			rootStack.remove();</span>
<span class="fc" id="L82">			otherStack.remove();</span>
		}
<span class="fc" id="L84">		StringBuilder relativePath= new StringBuilder();</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">		while(!rootStack.isEmpty()){</span>
<span class="fc" id="L86">			relativePath.append(&quot;..&quot;).append(pathSeparator);</span>
<span class="fc" id="L87">			rootStack.remove();</span>
		}
<span class="fc bfc" id="L89" title="All 2 branches covered.">		while(!otherStack.isEmpty()){</span>
<span class="fc" id="L90">			relativePath.append(otherStack.remove()).append(pathSeparator);</span>
		}
<span class="fc bfc" id="L92" title="All 2 branches covered.">		if(relativePath.length()==0){</span>
<span class="fc" id="L93">			return &quot;&quot;;</span>
		}
		//chop off last separator
<span class="fc" id="L96">		return relativePath.substring(0, relativePath.length()-1);</span>
		
	}
	
	private static LIFOQueue&lt;String&gt; getCanonicalStackFor(File f) throws IOException{
<span class="fc" id="L101">			LIFOQueue&lt;String&gt; stack = new LIFOQueue&lt;String&gt;();</span>
<span class="fc" id="L102">			File currentCanonicalPath = f.getCanonicalFile();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">			while(currentCanonicalPath != null) {</span>
<span class="fc" id="L104">				stack.add(currentCanonicalPath.getName());</span>
<span class="fc" id="L105">				currentCanonicalPath = currentCanonicalPath.getParentFile();</span>
			}
			
<span class="fc" id="L108">		return stack;</span>
	}
	
	private static int indexOfLastSeparator(String filename) {
<span class="fc" id="L112">        int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);</span>
<span class="fc" id="L113">        int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);</span>
<span class="fc" id="L114">        return Math.max(lastUnixPos, lastWindowsPos);</span>
    }
	private static int indexOfExtension(String filename) {
<span class="fc" id="L117">        int extensionPos = filename.lastIndexOf('.');</span>
<span class="fc" id="L118">        int lastSeparator = indexOfLastSeparator(filename);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        return (lastSeparator &gt; extensionPos ? -1 : extensionPos);</span>
    }
	/**
	 * Get the extension part of a file.  For example,
	 * if the file points to a file named &quot;Readme.txt&quot;
	 * then this method will return &quot;txt&quot;.
	 * @param file the file to get the extension for.  If this
	 * value is null, then null will be returned.
	 * @return the String of the extension, or null
	 * if the file is null, or the empty string &quot;&quot; if there is no extension.
	 */
	public static String getExtension(File file){
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if(file ==null){</span>
<span class="nc" id="L132">			return null;</span>
		}
<span class="fc" id="L134">		String filename = file.getName();</span>
<span class="fc" id="L135">		return getExtension(filename);</span>
	}
	/**
	 * Get the extension part of a filepath.  For example,
	 * if the given filepath is to a file named &quot;Readme.txt&quot; or
	 * &quot;/path/to/Readme.txt&quot; 
	 * then this method will return &quot;txt&quot;.
	 * @param filepath the filepath to get the extension for.  If this
	 * value is null, then null will be returned.
	 * @return the String of the extension, or null
	 * if filepath is null, or the empty string &quot;&quot; if there is no extension.
	 */
	public static String getExtension(String filepath) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if(filepath ==null){</span>
<span class="nc" id="L149">			return null;</span>
		}
<span class="fc" id="L151">		int extensionIndex = indexOfExtension(filepath);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">		if (extensionIndex == -1) {</span>
<span class="fc" id="L153">            return &quot;&quot;;</span>
        } else {
<span class="fc" id="L155">            return filepath.substring(extensionIndex + 1);</span>
        }
	}
	/**
	 * Get the base portion of the file name from the given {@link File}.  For example,
	 * if the given {@link File} points to a file named &quot;Readme.txt&quot; or
	 * &quot;/path/to/Readme.txt&quot; 
	 * then this method will return &quot;Readme&quot;.
	 * @param file the {@link File} to get the base name for.  If this
	 * value is null, then null will be returned.
	 * @return the String of the base name, or null
	 * if File is null, or the empty string &quot;&quot; if there is no basepath.
	 */
	public static String getBaseName(File file){
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">		if(file ==null){</span>
<span class="nc" id="L170">			return null;</span>
		}
<span class="fc" id="L172">		return getBaseName(file.getName());</span>
	}
	/**
	 * Get the base portion of the file name from the given filepath.  For example,
	 * if the given filepath is to a file named &quot;Readme.txt&quot; or
	 * &quot;/path/to/Readme.txt&quot; 
	 * then this method will return &quot;Readme&quot;.
	 * @param filename the filepath to get the base name for.  If this
	 * value is null, then null will be returned.
	 * @return the String of the base name, or null
	 * if filepath is null, or the empty string &quot;&quot; if there is no basepath.
	 */
	public static String getBaseName(String filename) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if(filename ==null){</span>
<span class="nc" id="L186">			return null;</span>
		}
<span class="fc" id="L188">		int lastSeparatorIndex = indexOfLastSeparator(filename);		</span>
<span class="fc" id="L189">		int extensionIndex = indexOfExtension(filename);</span>
		
<span class="fc bfc" id="L191" title="All 2 branches covered.">		if (extensionIndex == -1) {</span>
<span class="fc" id="L192">            return filename.substring(lastSeparatorIndex+1);</span>
        } else {
<span class="fc" id="L194">            return filename.substring(lastSeparatorIndex+1,extensionIndex);</span>
        }
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>