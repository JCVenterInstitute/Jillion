<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InputStreamSupplier.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.io</a> &gt; <span class="el_source">InputStreamSupplier.java</span></div><h1>InputStreamSupplier.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core.io;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Optional;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.internal.core.io.MagicNumberInputStream;

/**
 * A Supplier function that can create multiple
 * new {@link InputStream}s from the same source file.
 * Different implementations may be able to handle
 * different file encodings or compressions.
 * 
 * @author dkatzel
 * 
 * @since 5.0
 *
 */
@FunctionalInterface
public interface InputStreamSupplier {
    /**
     * Create a new {@link InputStream} that starts
     * at the beginning of the file.
     * 
     * @return a new {@link InputStream}; should
     *          never be null but might not have any bytes to read.
     *          
     * @throws IOException if there is a problem creating the {@link InputStream}.
     */
    InputStream get() throws IOException;
    /**
     * Create a new {@link InputStream} that starts 
     * at the specified byte start offset.
     * 
     * @param startOffset the number of &lt;strong&gt;uncompressed&lt;/strong&gt;
     *          bytes to skip over before returning the InputStream.
     * @return a new {@link InputStream}; should
     *          never be null but might not have any bytes to read.
     *          
     * @throws IOException if there is a problem creating the {@link InputStream}
     *                   or skipping over the desired number of bytes.
     *          
     * @implNote the default implementation creates a new {@link InputStream}
     *                 via {@link #get()} and then skips over {@code startOffset}
     *                 number of bytes. Implementations should override this method
     *                 if they are able to more efficiently start in the middle of an {@link InputStream}.
     */
    default InputStream get(long startOffset) throws IOException{
<span class="fc" id="L72">        InputStream in = get();</span>
<span class="fc" id="L73">        IOUtil.blockingSkip(in, startOffset);</span>
<span class="fc" id="L74">        return in;</span>
    }
    
    /**
     * Create a new {@link InputStream} that starts 
     * at the specified byte start offset.
     * 
     * @param range the {@link Range} of &lt;strong&gt;uncompressed&lt;/strong&gt;
     *          bytes to read in this file/
     *          .
     * @return a new {@link InputStream}; should
     *          never be null but might not have any bytes to read.
     *          
     * @throws IOException if there is a problem creating the {@link InputStream}
     *                   or skipping over the desired number of bytes.
     *          
     * @implNote the default implementation creates a new {@link InputStream}
     *                 via {@link #get()} and then skips over {@code startOffset}
     *                 number of bytes. Implementations should override this method
     *                 if they are able to more efficiently start in the middle of an {@link InputStream}.
     */
    default InputStream get(Range range) throws IOException{
<span class="fc" id="L96">        InputStream in = get(range.getBegin());</span>
       
<span class="fc" id="L98">        return new SubLengthInputStream(in, range.getLength());</span>
    }
    
    /**
     * Get the {@link File} object
     * that is the source of this inputStream.
     * 
     * @return an {@link Optional} File that may be empty
     * if the file source is not known.
     * 
     * @since 5.2
     */
    default Optional&lt;File&gt; getFile(){
<span class="nc" id="L111">        return Optional.empty();</span>
    }
    /**
     * Create a new {@link InputStreamSupplier} for the given {@link File}
     * and try to correctly automatically decompress it.
     * 
     * The first few bytes of the given file are parsed to see if 
     * it is one of the few compressed file formats that have
     * built-in JDK InputStream implementations.
     * 
     * Currently the only supported formats are:
     * &lt;ul&gt;
     * &lt;li&gt;uncompressed&lt;/li&gt;
     * &lt;li&gt;zip - single entry only&lt;/li&gt;
     * &lt;li&gt;gzip&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * If the file is not one of these types, then it is assumed
     * to be uncompressed and an {@link InputStreamSupplier}
     * implementation based on {@link FileInputStream}
     * will be returned.
     * 
     * File encoding is determined by the actual contents
     * of the file.  The file name is not examined at all
     * so input files may use any file name extension conventions without
     * worrying about this method misinterpreting.
     * 
     * 
     * @param f the {@link File} object to create an {@link InputStreamSupplier} for;
     * can not be null, must exist,must be readable and should continue to exist for the lifetime
     * of this {@link InputStreamSupplier}.
     * 
     * @return a new {@link InputStreamSupplier}; will never be null.
     * @throws IOException if there is a problem reading this file.
     * @throws NullPointerException if f is null.
     */
    public static InputStreamSupplier forFile(File f) throws IOException{
<span class="fc" id="L148">       IOUtil.verifyIsReadable(f);</span>
       
       //check that file isn't empty
       //if the file is emtpy then there's no magic number
<span class="fc bfc" id="L152" title="All 2 branches covered.">       if(f.length() ==0){</span>
<span class="fc" id="L153">    	   return new RawFileInputStreamSupplier(f);</span>
       }
       
       byte[] magicNumber;
<span class="pc" id="L157">       try(MagicNumberInputStream magicNumInputStream = new MagicNumberInputStream(f)){</span>
<span class="fc" id="L158">           magicNumber= magicNumInputStream.peekMagicNumber();</span>
<span class="pc bpc" id="L159" title="6 of 8 branches missed.">       }</span>
       
<span class="pc bpc" id="L161" title="3 of 8 branches missed.">       if (magicNumber[0] == (byte)0x50 &amp;&amp; magicNumber[1] == (byte)0x4B &amp;&amp; magicNumber[2] == (byte)0x03 &amp;&amp; magicNumber[3]== (byte) 0x04){</span>
           //zipped
<span class="fc" id="L163">           return new BasicZipInputStreamSupplier(f);</span>
       }
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">       if( magicNumber[0] == (byte) 0x1F &amp;&amp; magicNumber[1] == (byte)0x8B){</span>
           //gzip
<span class="fc" id="L167">           return new GZipInputStreamSupplier(f);</span>
       }
       
<span class="fc" id="L170">        return new RawFileInputStreamSupplier(f);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>