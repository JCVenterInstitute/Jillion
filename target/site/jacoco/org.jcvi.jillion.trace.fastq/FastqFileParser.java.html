<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FastqFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.fastq</a> &gt; <span class="el_source">FastqFileParser.java</span></div><h1>FastqFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trace.fastq;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.io.InputStreamSupplier;
import org.jcvi.jillion.internal.core.io.LineParser;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.PositionlessLineParser;
import org.jcvi.jillion.internal.core.io.TextLineParser;
import org.jcvi.jillion.trace.fastq.FastqVisitor.FastqVisitorCallback;
import org.jcvi.jillion.trace.fastq.FastqVisitor.FastqVisitorCallback.FastqVisitorMemento;
/**
 * Contains factory methods to create
 * new {@link FastqParser} objects that will parse a single 
 * fastq encoded file or {@link InputStream} and call the appropriate
 * visitXXX methods on the given {@link FastqVisitor}.
 * The implementations of the public factory methods only
 * support the simplest most common usecases of fastq files
 * and parsing fastq files.
 * 
 * &lt;ol&gt;

 * &lt;li&gt;Each fastq record is assumed to be only 4 lines long&lt;/li&gt;
 * &lt;li&gt;No records have comments on the defline&lt;/li&gt;
 * &lt;li&gt; {@link FastqVisitorMemento}s are not
 * supported &lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * If these restrictions do not properly describe your fastq file
 * to be parsed or you want to use  {@link FastqVisitorMemento}s,
 * then please use the {@link FastqFileParserBuilder}
 * object instead which has additional configuration options to 
 * support all of these features but comes with a performance penality.
 * 
 * @author dkatzel
 * 
 * @see FastqFileParserBuilder
 *
 */
public abstract class FastqFileParser implements FastqParser{

<span class="fc" id="L70">	private static final Pattern CASAVA_1_8_DEFLINE_PATTERN = Pattern.compile(&quot;^@(\\S+\\s+\\d:[N|Y]:\\d+:(\\S+)?)\\s*$&quot;);</span>
	
<span class="fc" id="L72">	private final StringBuilder sequenceBuilder = new StringBuilder(2000);</span>
<span class="fc" id="L73">	private final StringBuilder qualityBuilder = new StringBuilder(2000);</span>
	
	private final boolean hasComments;
	
	private final  boolean multiLine;
	
	
	/**
	 * Create a new {@link FastqFileParser} instance
	 * that will parse the given fastq encoded
	 * inputStream that does not contain defline comments and is
	 * only 4 lines per fastq record.  Please Note that inputStream implementations
	 * of the FastqFileParser can not create {@link FastqVisitorMemento}s
	 * or use {@link #parse(FastqVisitor, FastqVisitorMemento)}
	 * method.
	 * &lt;p&gt;
	 * If you need to parse Fastq files that have
	 * comments or have more than 4 lines per record
	 * please use {@link FastqFileParserBuilder}
	 * which has additional configuration options.
	 *
	 * @param in the fastq encoded inputstream to parse.
	 * @throws NullPointerException if inputstream is null.
	 * 
	 * @return a new {@link FastqParser} instance; will never be null.
	 * 
	 * @see FastqFileParserBuilder#FastqFileParserBuilder(InputStream)
	 */
	public static FastqParser create(InputStream in){
<span class="fc" id="L102">		return create(in, false, false);</span>
	}
	
	/**
         * Create a new {@link FastqFileParser} instance
         * that will parse the given fastq encoded
         * File which may be zipped or gzipped, but does not contain defline comments and is
         * only 4 lines per fastq record.  Please Note the returned implementations
         * of the FastqFileParser can not create {@link FastqVisitorMemento}s
         * or use {@link #parse(FastqVisitor, FastqVisitorMemento)}
         * method.
         * &lt;p&gt;
         * If you need to parse Fastq files that have
         * comments or have more than 4 lines per record
         * or you want to use {@link FastqVisitorMemento}s
         * please use {@link FastqFileParserBuilder}
         * which has additional configuration options.
         *
         * @param fastq the fastq encoded file to parse; must
         * exist and be readable; may be a &quot;normal&quot; fastq file, or zipped or gzipped.
         * 
         * @throws NullPointerException if fastq is null.
         * @throws IOException if fastq does not exist or is not readable.
         * 
         * @return a new {@link FastqParser} instance; will never be null.
         * 
         * @see FastqFileParserBuilder#FastqFileParserBuilder(File)
         */
        public static FastqParser create(File fastq) throws IOException{
<span class="fc" id="L131">                return create(InputStreamSupplier.forFile(fastq), false, false, false);</span>
        }
	
	/**
         * Create a new {@link FastqFileParser} instance
         * that will parse the given fastq encoded
         * inputStream.  Please Note that inputStream implementations
         * of the FastqFileParser can not create {@link FastqVisitorMemento}s
         * or use {@link #accept(FastqVisitor, FastqVisitorMemento)}
         * method.
         * @param in the fastq encoded inputstream to parse.
         * @param hasComments do the deflines of the sequences contain comments.  If 
         * set to {@code true} then a more computationally intensive parsing is performed
         * to try to distinguish the id from the comment.  Remember some Fastq id's can have spaces
         * which makes comment detection difficult and complex.
         * 
         * @throws NullPointerException if inputstream is null.
         * 
         * @return a new {@link FastqParser} instance; will never be null.
         */
        static FastqParser create(InputStream in, boolean hasComments, boolean multiLine){
<span class="fc" id="L152">                return new InputStreamFastqFileParser(in, hasComments, multiLine);</span>
        }
        
        
        static FastqFileParser create(InputStreamSupplier supplier, boolean hasComments, boolean multiLine, boolean trackPosition) throws IOException{
<span class="fc" id="L157">            return new FileBasedFastqFileParser(supplier,hasComments, multiLine, trackPosition);</span>
        }
        
<span class="fc" id="L160">	private FastqFileParser(boolean hasComments, boolean multiLine){</span>
<span class="fc" id="L161">		this.hasComments = hasComments;</span>
<span class="fc" id="L162">		this.multiLine = multiLine;</span>
<span class="fc" id="L163">	}</span>
	
	void parseFastqFile(FastqVisitor visitor, LineParser parser) throws IOException{
<span class="fc bfc" id="L166" title="All 2 branches covered.">		ParserState parserState = parser.tracksPosition() ? new ParserState(parser.getPosition()) : new ParserState(0);</span>
<span class="fc bfc" id="L167" title="All 4 branches covered.">		while(parserState.keepParsing() &amp;&amp; parser.hasNextLine()){</span>
<span class="fc" id="L168">			parserState=parseNextRecord(visitor, parser, parserState);</span>
		}
<span class="fc bfc" id="L170" title="All 2 branches covered.">		if(parserState.keepParsing()){</span>
<span class="fc" id="L171">			visitor.visitEnd();</span>
		}else{
<span class="fc" id="L173">			visitor.halted();</span>
		}
<span class="fc" id="L175">	}</span>
	
	private ParserState parseNextRecord(FastqVisitor visitor, LineParser parser, ParserState parserState) throws IOException{
<span class="fc" id="L178">		String deflineText = parser.nextLine();</span>
<span class="fc" id="L179">		 AbstractFastqVisitorCallback callback = createCallback(parserState);</span>
		 FastqRecordVisitor recordVisitor;
		 String id;
<span class="fc bfc" id="L182" title="All 2 branches covered.">		if(hasComments){</span>
<span class="fc" id="L183">    		    Defline defline = Defline.parse(deflineText);</span>
<span class="fc" id="L184">    		    id = defline.getId();</span>
    		
<span class="fc" id="L186">                   recordVisitor= visitor.visitDefline(callback, id, defline.getComment());</span>
<span class="fc" id="L187">		}else{</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		    if(deflineText.charAt(0) != '@'){</span>
<span class="nc" id="L189">		        throw new IllegalStateException(String.format(&quot;invalid fastq file, could not parse seq id from '%s'&quot;,deflineText));</span>
		            
		    }
<span class="fc" id="L192">		    id = deflineText.substring(1).trim();</span>
<span class="fc" id="L193">		    recordVisitor= visitor.visitDefline(callback, id, null);</span>
		}
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if(!parserState.keepParsing()){</span>
<span class="fc" id="L196">            	return parserState;</span>
            }
<span class="fc" id="L198">            return parseRecordBody(parser,recordVisitor,parserState, id);		</span>
        
	}

	
	private ParserState parseRecordBody(LineParser parser,
			FastqRecordVisitor recordVisitor, ParserState parserState, String currentId) throws IOException {
		//if we aren't visiting this read
		//we shouldn't spend any time parsing the
		//bases or qualities	
<span class="fc bfc" id="L208" title="All 2 branches covered.">		if(recordVisitor ==null){</span>
<span class="fc" id="L209">			skipCurrentRecord(parser);</span>
			//set new end position for mementos to work
<span class="fc" id="L211">			return parserState.updatePosition(parser);</span>
		}
		
		//default to 2000 bp since most sequences are only that much anyway
        //builder will grow if we get too big
        
<span class="fc" id="L217">        String line = parser.nextLine();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if(line ==null){</span>
        	//end of file before we got enough sequence
<span class="nc" id="L220">			throw new IOException(</span>
<span class="nc" id="L221">    				String.format(&quot;unexpected end of file. no sequence for current record '%s'&quot;,currentId));</span>
        }
<span class="fc" id="L223">    	sequenceBuilder.append(line.trim());</span>
<span class="fc" id="L224">    	boolean inBasecallBlock = multiLine;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        while(inBasecallBlock){</span>
<span class="fc" id="L226">        	line = parser.nextLine();</span>
<span class="fc" id="L227">        	inBasecallBlock = notQualityDefLine(line);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        	if(inBasecallBlock){</span>
<span class="fc" id="L229">        		sequenceBuilder.append(line.trim());</span>
        	}
        }
        
       
<span class="fc" id="L234">        recordVisitor.visitNucleotides(sequenceBuilder.toString());</span>
        
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if(!parserState.keepParsing()){</span>
<span class="nc" id="L237">            recordVisitor.halted();</span>
<span class="nc" id="L238">            return parserState.updatePosition(parser);</span>
        }
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if(!multiLine){</span>
            //read qual defline
<span class="fc" id="L242">            String qualDefline=parser.nextLine();</span>
            //should start with +
<span class="pc bpc" id="L244" title="2 of 4 branches missed.">            if(qualDefline ==null || qualDefline.charAt(0) != '+'){</span>
<span class="nc" id="L245">                throw new IOException(&quot;invalid quality defline. should start with '+' but was &quot; + qualDefline);</span>
            }
        }
        //now parse the qualities
<span class="fc" id="L249">        int expectedQualities =  sequenceBuilder.length();</span>
        
        //clear builders
<span class="fc" id="L252">        sequenceBuilder.setLength(0);</span>
        
<span class="fc" id="L254">        qualityBuilder.setLength(0);</span>
        //needs to be a do-while loop
        //to cover the case where the read is empty
        //(contains 0 bases) we still need to read a quality line
        do{    	
<span class="fc" id="L259">    		line = parser.nextLine();</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">    		if(line ==null){</span>
    			//end of file before we got enough qualities
<span class="fc" id="L262">    			throw new IOException(</span>
<span class="fc" id="L263">        				String.format(&quot;too few quality values for current record '%s' : &quot;</span>
<span class="fc" id="L264">        						+ &quot;expected %d but was %d&quot;, currentId, expectedQualities, qualityBuilder.length()));</span>
        	
    		}
<span class="fc" id="L267">    		qualityBuilder.append(line.trim());</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">    	}while(qualityBuilder.length() &lt; expectedQualities);</span>
        
        
<span class="fc bfc" id="L271" title="All 2 branches covered.">    	if(qualityBuilder.length()&gt; expectedQualities){</span>
    		//we actually might have read too much and are somewhere inside the next 
    		//record 
    		//(reading the defline and possibly even the bases line of the next record)
    		
<span class="fc" id="L276">    		throw new IOException(</span>
<span class="fc" id="L277">    				String.format(&quot;incorrect number of quality values for current record: expected %d &quot;</span>
    						+ &quot;but was %d if there are too few qualities the parser may have &quot;
<span class="fc" id="L279">    						+ &quot;read into the next record&quot;, expectedQualities, qualityBuilder.length()));</span>
    	}
<span class="fc" id="L281">    	recordVisitor.visitEncodedQualities(qualityBuilder.toString());</span>
    	
<span class="fc" id="L283">		ParserState endParserState = parserState.updatePosition(parser);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">		if (endParserState.keepParsing()){</span>
<span class="fc" id="L285">			recordVisitor.visitEnd();</span>
		}else{
<span class="nc" id="L287">			recordVisitor.halted();</span>
		}

<span class="fc" id="L290">		return endParserState;</span>
	}
	private void skipCurrentRecord(LineParser parser) throws IOException {
        
<span class="fc bfc" id="L294" title="All 2 branches covered.">	    if(multiLine){</span>
<span class="fc" id="L295">		String line = parser.nextLine();</span>
<span class="fc" id="L296">		int numberOfBasesSeen=0;</span>
     	
<span class="fc bfc" id="L298" title="All 2 branches covered.">		while(notQualityDefLine(line)){</span>
			//still in bases 
<span class="fc" id="L300">			numberOfBasesSeen += line.trim().length();</span>
<span class="fc" id="L301">			line = parser.nextLine();</span>
		}
		
		//handle special case of empty read
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">		if(numberOfBasesSeen==0){</span>
			//skip blank line
<span class="nc" id="L307">			parser.nextLine();</span>
<span class="nc" id="L308">			return;</span>
		}
<span class="fc" id="L310">		int numberOfQualitiesLeft= numberOfBasesSeen;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">		while(numberOfQualitiesLeft&gt;0){</span>
<span class="fc" id="L312">			line = parser.nextLine();</span>
<span class="fc" id="L313">			numberOfQualitiesLeft -= line.trim().length();</span>
		}
		//be consistent with errors if too many 
		//qualities
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">		if(numberOfQualitiesLeft&lt; 0 ){</span>
<span class="nc" id="L318">    		    throw new IOException(</span>
<span class="nc" id="L319">    				String.format(&quot;too many quality values for current record: expected %d but was %d&quot;, </span>
<span class="nc" id="L320">    						numberOfBasesSeen, </span>
<span class="nc" id="L321">    						numberOfBasesSeen - numberOfQualitiesLeft));</span>
    	        }
<span class="fc" id="L323">	    }else{</span>
<span class="fc" id="L324">	        parser.nextLine(); //bases</span>
<span class="fc" id="L325">	        parser.nextLine(); //qual defline</span>
<span class="fc" id="L326">	        parser.nextLine(); // qualities</span>
	    }
		
<span class="fc" id="L329">	}</span>
	private boolean notQualityDefLine(String line) {
<span class="fc bfc" id="L331" title="All 2 branches covered.">		return line.charAt(0) !='+';</span>
	}

	protected abstract AbstractFastqVisitorCallback createCallback(ParserState parserState);
	
	
	
	
	private static final class Defline{
		private final String id,comment;

<span class="fc" id="L342">		private Defline(String id, String comment) {</span>
<span class="fc" id="L343">			this.id = id;</span>
<span class="fc" id="L344">			this.comment = comment;</span>
<span class="fc" id="L345">		}</span>
		
		public static Defline parse(String fastqDefline){
<span class="fc" id="L348">			Matcher casava18Matcher = CASAVA_1_8_DEFLINE_PATTERN.matcher(fastqDefline);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">			if(casava18Matcher.matches()){</span>
<span class="nc" id="L350">				return new Defline(casava18Matcher.group(1),null);</span>
			}
<span class="fc" id="L352">			Matcher beginSeqMatcher =FastqUtil.SEQ_DEFLINE_PATTERN.matcher(fastqDefline);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">	        if(!beginSeqMatcher.find()){</span>
<span class="nc" id="L354">	            throw new IllegalStateException(String.format(&quot;invalid fastq file, could not parse seq id from '%s'&quot;,fastqDefline));</span>
	        }
<span class="fc" id="L356">	        return new Defline(beginSeqMatcher.group(1), beginSeqMatcher.group(3));</span>
		}
		public String getId() {
<span class="fc" id="L359">			return id;</span>
		}

		public String getComment() {
<span class="fc" id="L363">			return comment;</span>
		}

	}
	
	private abstract static class AbstractFastqVisitorCallback implements FastqVisitorCallback{
		private final ParserState parserState;
		
		
<span class="fc" id="L372">		public AbstractFastqVisitorCallback(ParserState parserState) {</span>
<span class="fc" id="L373">			this.parserState = parserState;</span>
<span class="fc" id="L374">		}</span>

		@Override
		public void haltParsing() {
<span class="fc" id="L378">			parserState.stopParsing();</span>
			
<span class="fc" id="L380">		}</span>

		final ParserState getParserState() {
<span class="fc" id="L383">			return parserState;</span>
		}

		
		
	}
	
	private static class NoMementoCallback extends AbstractFastqVisitorCallback{

		
		
		public NoMementoCallback(ParserState parserState) {
<span class="fc" id="L395">			super(parserState);</span>
<span class="fc" id="L396">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L400">			return false;</span>
		}

		@Override
		public FastqVisitorMemento createMemento() {
<span class="nc" id="L405">			throw new UnsupportedOperationException(&quot;can not create memento&quot;);</span>
		}
		
	}
	
	private static class MementoCallback extends AbstractFastqVisitorCallback{
		
		public MementoCallback(ParserState parserState){
<span class="fc" id="L413">			super(parserState);</span>
<span class="fc" id="L414">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="fc" id="L418">			return true;</span>
		}

		@Override
		public FastqVisitorMemento createMemento() {
<span class="fc" id="L423">			return OffsetMemento.valueOf(getParserState().getCurrentOffset());</span>
			//return new LongOffsetMemento(getParserState().getCurrentOffset());
		}
		
	}

	
	
	private static class ParserState{
		private final long currentOffset;
		private final AtomicBoolean keepParsing;
		
		
		ParserState(long startOffset){
<span class="fc" id="L437">			this(startOffset, new AtomicBoolean(true));</span>
<span class="fc" id="L438">		}</span>
		

		public final long getCurrentOffset() {
<span class="fc" id="L442">			return currentOffset;</span>
		}
<span class="fc" id="L444">		private ParserState(long startOffset, AtomicBoolean keepParsing){</span>
<span class="fc" id="L445">			this.currentOffset = startOffset;</span>
<span class="fc" id="L446">			this.keepParsing = keepParsing;</span>
<span class="fc" id="L447">		}</span>
		
		void stopParsing(){
<span class="fc" id="L450">			keepParsing.set(false);</span>
<span class="fc" id="L451">		}</span>
		
		public boolean keepParsing(){
<span class="fc" id="L454">			return keepParsing.get();</span>
		}
		
		ParserState setOffset(long newOffset){
<span class="fc" id="L458">			return new ParserState(newOffset, keepParsing);</span>
		}
		
		ParserState updatePosition(LineParser parser){
<span class="fc bfc" id="L462" title="All 2 branches covered.">		    if(parser.tracksPosition()){</span>
<span class="fc" id="L463">		        return setOffset(parser.getPosition());</span>
		    }
<span class="fc" id="L465">		    return this;</span>
		}
	}
	
	private static class FileBasedFastqFileParser extends FastqFileParser{
		private final InputStreamSupplier supplier;
		private final boolean trackPosition;
		
		public FileBasedFastqFileParser(InputStreamSupplier supplier, 
		        boolean hasComments, boolean multiLine,
		        boolean trackPosition) throws IOException {
<span class="fc" id="L476">		    super(hasComments, multiLine);</span>
<span class="fc" id="L477">		    Objects.requireNonNull(supplier);</span>
<span class="fc" id="L478">			this.trackPosition = trackPosition;</span>
<span class="fc" id="L479">			this.supplier=supplier;</span>
<span class="fc" id="L480">		}</span>


		@Override
        public Optional&lt;File&gt; getFile() {
<span class="fc" id="L485">            return supplier.getFile();</span>
        }


        @Override
		public boolean canCreateMemento() {
<span class="fc" id="L491">			return true;</span>
		}


		@Override
		public boolean isReadOnceOnly() {
<span class="fc" id="L497">			return false;</span>
		}


		@Override
		public boolean canParse() {
<span class="fc" id="L503">			return true;</span>
		}


		@Override
		protected AbstractFastqVisitorCallback createCallback(
				ParserState parserState) {
<span class="fc" id="L510">			return new MementoCallback(parserState);</span>
		}


		@Override
		public void parse(FastqVisitor visitor) throws IOException {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">			if(visitor ==null){</span>
<span class="nc" id="L517">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
			
<span class="fc" id="L520">			try(InputStream in = supplier.get()){</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">				LineParser parser = trackPosition? new TextLineParser(in) :new PositionlessLineParser(in);</span>
<span class="fc" id="L522">				parseFastqFile(visitor, parser);			</span>
<span class="pc bpc" id="L523" title="4 of 8 branches missed.">			}</span>
<span class="fc" id="L524">		}</span>


		@Override
		public void parse(FastqVisitor visitor, FastqVisitorMemento memento)
				throws IOException {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">			if(!(memento instanceof OffsetMemento)){</span>
<span class="nc" id="L531">				throw new IllegalArgumentException(&quot;unknown memento type, instance must be generated by this parser&quot;);</span>
			}
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">			if(visitor ==null){</span>
<span class="nc" id="L534">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
<span class="fc" id="L536">			long startOffset = ((OffsetMemento)memento).getValue();</span>
			
<span class="pc" id="L538">                        try (InputStream in = supplier.get(startOffset)) {</span>
                           
<span class="fc" id="L540">                            TextLineParser parser = new TextLineParser(in, startOffset);</span>
<span class="fc" id="L541">                            parseFastqFile(visitor, parser);</span>
<span class="pc bpc" id="L542" title="6 of 8 branches missed.">                        }</span>
			
<span class="fc" id="L544">		}		</span>
	}
	
	private static class InputStreamFastqFileParser extends FastqFileParser{
		private final OpenAwareInputStream in;
		
		public InputStreamFastqFileParser(InputStream in,boolean hasComments, boolean multiLine) {
<span class="fc" id="L551">		        super(hasComments, multiLine);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">			if(in==null){</span>
<span class="nc" id="L553">				throw new NullPointerException(&quot;inputstream can not be null&quot;);</span>
			}
<span class="fc" id="L555">			this.in = new OpenAwareInputStream(in);</span>
<span class="fc" id="L556">		}</span>

		
		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L561">			return false;</span>
		}


		@Override
		public boolean isReadOnceOnly() {
<span class="nc" id="L567">			return true;</span>
		}


		@Override
		public synchronized void parse(FastqVisitor visitor) throws IOException {
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">			if(!canParse()){</span>
<span class="nc" id="L574">				throw new IllegalStateException(&quot;can not accept, inputStream closed&quot;);</span>
			}
			//synchronized to only let in one visitor at a time since they will
			//all share the inputstream...
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">			if(visitor ==null){</span>
<span class="nc" id="L579">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
			try{
<span class="fc" id="L582">				LineParser parser = new PositionlessLineParser(in);</span>
<span class="fc" id="L583">				parseFastqFile(visitor, parser);</span>
			}finally{
<span class="fc" id="L585">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L586">			}</span>
			
<span class="fc" id="L588">		}</span>

		@Override
		public boolean canParse() {
<span class="fc" id="L592">			return in.isOpen();</span>
		}

		@Override
		public void parse(FastqVisitor visitor, FastqVisitorMemento memento)
				throws IOException {
<span class="nc" id="L598">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
			
		}

		@Override
		protected AbstractFastqVisitorCallback createCallback(
				ParserState parserState) {
<span class="fc" id="L605">			return new NoMementoCallback(parserState);</span>
		}


        @Override
        public Optional&lt;File&gt; getFile() {
<span class="nc" id="L611">            return Optional.empty();</span>
        }
		
	}
	
<span class="fc" id="L616">	public abstract static class OffsetMemento implements FastqVisitorMemento {</span>
		private static final long UNSIGNED_MAX_BYTE = 0xFF;
		private static final long UNSIGNED_MAX_SHORT = 0xFFFF;
		//need the &quot;L&quot; at the end to make the value a long otherwise it's an int with value -1 !
		private static final long UNSIGNED_MAX_INT = 0xFFFFFFFFL;
		/**
		 * Create a new instance of a {@link OffsetMemento}
		 * which will wrap the given value but use
		 * as few bytes as possible.
		 * @param value the value to wrap; may
		 * be negative.
		 * @return a n{@link OffsetMemento} instance that
		 * wraps the given value in as few bytes as possible.
		 */
		public static OffsetMemento valueOf(long value){
			//TODO: should we do caching to return 
			//already created instances (flyweight)?
			//This is probably going to be used mostly
			//for file offsets. If we wrap
			//several fastq files, each of which have
			//the same number of bases we might get a lot of
			//duplicate instances...
			
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">			if(value &lt;0){</span>
<span class="nc" id="L640">				throw new IllegalArgumentException(&quot;can not have negative offset&quot;);</span>
			}
<span class="fc bfc" id="L642" title="All 2 branches covered.">			if(value &lt;=UNSIGNED_MAX_BYTE){</span>
<span class="fc" id="L643">				return new ByteWidthOffsetMemento(value);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">			}else if(value &lt;=UNSIGNED_MAX_SHORT){</span>
<span class="fc" id="L645">				return new ShortWidthOffsetMemento(value);</span>
			}
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">			else if(value &lt;=UNSIGNED_MAX_INT){</span>
<span class="fc" id="L648">				return new IntWidthOffsetMemento(value);</span>
			}
<span class="nc" id="L650">			return new LongWidthOffsetMemento(value);</span>
		}
		/**
		 * Get the wrapped value as a long.
		 * @return the value; may be negative.
		 */
		public abstract long getValue();
		
		@Override
		public String toString() {
<span class="nc" id="L660">			return Long.toString(getValue());</span>
		}
		@Override
		public boolean equals(Object obj){
<span class="nc bnc" id="L664" title="All 2 branches missed.">			if(obj ==null){</span>
<span class="nc" id="L665">				return false;</span>
			}
<span class="nc bnc" id="L667" title="All 2 branches missed.">			if(obj instanceof OffsetMemento){</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">				return getValue()==((OffsetMemento)obj).getValue();</span>
			}
<span class="nc" id="L670">			return false;</span>
		}
		
		@Override
		public int hashCode() {
<span class="nc" id="L675">			final int prime = 31;</span>
<span class="nc" id="L676">			long value = getValue();</span>
<span class="nc" id="L677">			return prime * (int) (value ^ (value &gt;&gt;&gt; 32));</span>
		}
		
		
	}
	
	private static class ByteWidthOffsetMemento extends OffsetMemento{
		
		private final byte value;

<span class="fc" id="L687">		public ByteWidthOffsetMemento(long value) {</span>
<span class="fc" id="L688">			this.value = IOUtil.toSignedByte((int)value);</span>
<span class="fc" id="L689">		}</span>

		@Override
		public long getValue() {
<span class="fc" id="L693">			return IOUtil.toUnsignedByte(value);</span>
		}
		
	}
	
	private static class ShortWidthOffsetMemento extends OffsetMemento{
		
		private final short value;

<span class="fc" id="L702">		public ShortWidthOffsetMemento(long value) {</span>
<span class="fc" id="L703">			this.value = IOUtil.toSignedShort((int)value);</span>
<span class="fc" id="L704">		}</span>

		@Override
		public long getValue() {
<span class="fc" id="L708">			return IOUtil.toUnsignedShort(value);</span>
		}
		
	}
	
	private static class IntWidthOffsetMemento extends OffsetMemento{
		
		private final int value;

<span class="fc" id="L717">		public IntWidthOffsetMemento(long value) {</span>
<span class="fc" id="L718">			this.value = IOUtil.toSignedInt(value);</span>
<span class="fc" id="L719">		}</span>

		@Override
		public long getValue() {
<span class="nc" id="L723">			return IOUtil.toUnsignedInt(value);</span>
		}
		
	}
	private static class LongWidthOffsetMemento extends OffsetMemento{
		
		private final long value;

<span class="nc" id="L731">		public LongWidthOffsetMemento(long value) {</span>
<span class="nc" id="L732">			this.value = value;</span>
<span class="nc" id="L733">		}</span>

		@Override
		public long getValue() {
<span class="nc" id="L737">			return value;</span>
		}	
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>