<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LargeFastqFileDataStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.fastq</a> &gt; <span class="el_source">LargeFastqFileDataStore.java</span></div><h1>LargeFastqFileDataStore.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Dec 15, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.trace.fastq;

import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.function.Predicate;

import org.jcvi.jillion.core.datastore.DataStoreClosedException;
import org.jcvi.jillion.core.datastore.DataStoreEntry;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.core.util.streams.ThrowingBiConsumer;
import org.jcvi.jillion.internal.core.datastore.DataStoreStreamingIterator;
import org.jcvi.jillion.internal.core.util.Sneak;
import org.jcvi.jillion.internal.core.util.iter.AbstractBlockingStreamingIterator;
/**
 * {@code LargeFastqFileDataStore} is a {@link FastqDataStore} implementation
 * to be used a very large Fastq Files.  No data contained in this
 * fastq file is stored in memory except it's size (which is lazy loaded).
 * This means that each call to {@link FastqDataStore#get(String)}
 * or {@link FastqDataStore#contains(String)} requires re-parsing the fastq file
 * which can take some time.  
 * It is recommended that instances are wrapped
 * in  a cached datastore using
 * {@link DataStoreUtil#createNewCachedDataStore(Class, DataStore, int)}.
 * @author dkatzel
 *
 *
 */
final class LargeFastqFileDataStore implements FastqFileDataStore {
    private final FastqQualityCodec qualityCodec;
    private final FastqParser parser;
    
<span class="fc" id="L59">    private Long size=null;</span>
    private volatile boolean closed;
    private final Predicate&lt;String&gt; filter;
    private final Predicate&lt;FastqRecord&gt; recordFilter;
    
   
    
  
    /**
     * Create a new {@link FastqDataStore} instance for the given
     * {@link FastqParser} which will only contain all the
     * records in the file that are accepted by the given filter.  
     * This implementation will use the given
     * {@link FastqQualityCodec} to decode the qualities of the fastq record
     * (if provided)
     * @param parser the {@link FastqParser} instance
     * that will parse some fastq data source that will be parsed
     * to create a {@link FastqDataStore}; (can not be null, and must exist).
     * @param filter the {@link Predicate} used to filter out records
     * from the datastore. If this value is null,
     * then all records in the file will be included in the datastore.
     * @param qualityCodec the {@link FastqQualityCodec} that should be used
     * to decode the fastq file.  If this value is null, then 
     * the datastore implementation will try to guess the codec used which might
     * have a performance penalty associated with it.
     * @return a new {@link FastqDataStore} instance, will never be null.
     * @throws NullPointerException if any parameter is null.
     */
    static FastqFileDataStore create(FastqParser parser, FastqQualityCodec qualityCodec, Predicate&lt;String&gt; filter, Predicate&lt;FastqRecord&gt; recordFilter) throws IOException{
    	
<span class="fc" id="L89">    	return new LargeFastqFileDataStore(parser, qualityCodec,filter, recordFilter);</span>
    }
    /**
     * @param qualityCodec
     * @throws FileNotFoundException 
     */
<span class="fc" id="L95">    private LargeFastqFileDataStore(FastqParser parser, FastqQualityCodec qualityCodec,Predicate&lt;String&gt; filter, Predicate&lt;FastqRecord&gt; recordFilter) throws IOException {</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">    	if(parser==null){</span>
<span class="nc" id="L97">    		throw new NullPointerException(&quot;parser can not be null&quot;);</span>
    	}    	
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">    	if(filter==null){</span>
<span class="nc" id="L100">    		throw new NullPointerException(&quot;filter can not be null&quot;);</span>
    	}
    	
<span class="fc" id="L103">    	this.parser = parser;</span>
<span class="fc" id="L104">    	this.filter = filter;</span>
<span class="fc" id="L105">        this.qualityCodec = qualityCodec;   </span>
<span class="fc" id="L106">        this.recordFilter = recordFilter;</span>
<span class="fc" id="L107">    }</span>

    @Override
    public Optional&lt;File&gt; getFile() {
<span class="nc" id="L111">        return parser.getFile();</span>
    }
    @Override
    public synchronized void close() throws IOException {
<span class="fc" id="L115">        closed = true;        </span>
<span class="fc" id="L116">    }</span>
    
    @Override
    public FastqQualityCodec getQualityCodec() {
<span class="fc" id="L120">        return qualityCodec;</span>
    }
    /**
     * {@inheritDoc}
     */
     @Override
     public synchronized boolean isClosed() {
<span class="fc" id="L127">         return closed;</span>
     }
    
    @Override
    public synchronized boolean contains(String id) throws DataStoreException {
<span class="fc" id="L132">        throwExceptionIfClosed();</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if(!filter.test(id)){</span>
<span class="nc" id="L134">        	return false;</span>
        }
              
<span class="pc" id="L137">        try(StreamingIterator&lt;String&gt; iter = idIterator()){</span>
        	
<span class="fc bfc" id="L139" title="All 2 branches covered.">            while(iter.hasNext()){</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">                if(iter.next().equals(id)){                    </span>
<span class="fc" id="L142">                    return true;</span>
                }
            }
<span class="fc" id="L145">            return false;</span>
<span class="pc bpc" id="L146" title="8 of 12 branches missed.">        }</span>
        
    }
    private void throwExceptionIfClosed(){
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if(closed){</span>
<span class="fc" id="L151">            throw new DataStoreClosedException(&quot;datastore is closed&quot;);</span>
        }
<span class="fc" id="L153">    }</span>
    @Override
    public synchronized FastqRecord get(String id) throws DataStoreException {
<span class="fc" id="L156">    	 throwExceptionIfClosed();</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if(!filter.test(id)){</span>
<span class="nc" id="L158">        	return null;</span>
        }
<span class="pc" id="L160">        try(StreamingIterator&lt;FastqRecord&gt; iter = iterator()){</span>
        	
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            while(iter.hasNext()){</span>
<span class="fc" id="L163">                FastqRecord fastQ = iter.next();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                if(fastQ.getId().equals(id)){                    </span>
<span class="fc" id="L165">                    return fastQ;</span>
                }
<span class="fc" id="L167">            }</span>
<span class="pc bpc" id="L168" title="10 of 12 branches missed.">        }</span>
        //not found
<span class="nc" id="L170">       return null;</span>
    }

    @Override
    public synchronized StreamingIterator&lt;String&gt; idIterator() throws DataStoreException {
<span class="fc" id="L175">        throwExceptionIfClosed();</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (recordFilter == null) {</span>
<span class="fc" id="L177">            NoLambdaFastqIdIterator iterator = new NoLambdaFastqIdIterator();</span>
<span class="fc" id="L178">            iterator.start();</span>
<span class="fc" id="L179">            return DataStoreStreamingIterator.create(this, iterator);</span>
        }
<span class="nc" id="L181">        return new LambdaFilteredFastqIdIterator(iterator());</span>
    }

    @Override
    public synchronized long getNumberOfRecords() throws DataStoreException {
<span class="fc" id="L186">        throwExceptionIfClosed();</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if(size ==null){</span>
<span class="fc" id="L188">            long count=0;</span>
<span class="fc" id="L189">            StreamingIterator&lt;FastqRecord&gt; iter = iterator();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            while(iter.hasNext()){</span>
<span class="fc" id="L191">                count++;</span>
<span class="fc" id="L192">                iter.next();</span>
            }
<span class="fc" id="L194">            size = Long.valueOf(count);</span>
        }
<span class="fc" id="L196">        return size;</span>
    }
    
    @Override
    public synchronized StreamingIterator&lt;FastqRecord&gt; iterator() {
<span class="fc" id="L201">        throwExceptionIfClosed();</span>
<span class="fc" id="L202">        LargeFastqFileIterator iter = new LargeFastqFileIterator();</span>
<span class="fc" id="L203">    	iter.start();</span>
    	
<span class="fc" id="L205">    	return DataStoreStreamingIterator.create(this,iter);</span>
  
    }
    
    
    @Override
    public &lt;E extends Throwable&gt; void forEach(ThrowingBiConsumer&lt;String, FastqRecord, E&gt; consumer)
            throws IOException, E {
        //we can be faster by avoiding the blocking iterators
<span class="fc" id="L214">        parser.parse(new AbstractFastqVisitor() {</span>

            @Override
            public FastqRecordVisitor visitDefline(
                    FastqVisitorCallback callback, String id,
                    String optionalComment) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (filter.test(id)) {</span>
                    //don't waste CPU time saving a few bytes of memory
                    //since we are only iterating through
                    //and will probably throw the read away after reading it once.
<span class="fc" id="L224">                    return new AbstractFastqRecordVisitor(id,optionalComment,qualityCodec, true) {</span>
                            
                            @Override
                            protected void visitRecord(FastqRecord record) {
<span class="fc bfc" id="L228" title="All 4 branches covered.">                                if(recordFilter ==null || recordFilter.test(record)){</span>
                                    try {
<span class="fc" id="L230">                                        consumer.accept(id, record);</span>
<span class="fc" id="L231">                                    } catch (Throwable t) {</span>
<span class="nc" id="L232">                                        Sneak.sneakyThrow(t);</span>
<span class="fc" id="L233">                                    }</span>
                                }
<span class="fc" id="L235">                            }</span>
                    };
                }
<span class="fc" id="L238">                return null;</span>
            }
            
        });
<span class="fc" id="L242">    }</span>
    @Override
	public synchronized StreamingIterator&lt;DataStoreEntry&lt;FastqRecord&gt;&gt; entryIterator()
			throws DataStoreException {
<span class="nc" id="L246">    	throwExceptionIfClosed();</span>
<span class="nc" id="L247">    	StreamingIterator&lt;DataStoreEntry&lt;FastqRecord&gt;&gt; iter = new StreamingIterator&lt;DataStoreEntry&lt;FastqRecord&gt;&gt;(){</span>

<span class="nc" id="L249">    		StreamingIterator&lt;FastqRecord&gt; fastqs = iterator();</span>
			@Override
			public boolean hasNext() {
<span class="nc" id="L252">				return fastqs.hasNext();</span>
			}

			@Override
			public void close() {
<span class="nc" id="L257">				fastqs.close();</span>
<span class="nc" id="L258">			}</span>

			@Override
			public DataStoreEntry&lt;FastqRecord&gt; next() {
<span class="nc" id="L262">				FastqRecord record = fastqs.next();</span>
<span class="nc" id="L263">				return new DataStoreEntry&lt;FastqRecord&gt;(record.getId(), record);</span>
			}

			@Override
			public void remove() {
<span class="nc" id="L268">				throw new UnsupportedOperationException();</span>
			}
    		
    	};
<span class="nc" id="L272">		return DataStoreStreamingIterator.create(this,iter);</span>
	}

    private static final class LambdaFilteredFastqIdIterator implements StreamingIterator&lt;String&gt;{
        private final StreamingIterator&lt;FastqRecord&gt; iter;
        
<span class="nc" id="L278">        public LambdaFilteredFastqIdIterator(StreamingIterator&lt;FastqRecord&gt; iter) {</span>
<span class="nc" id="L279">            this.iter = iter;</span>
<span class="nc" id="L280">        }</span>

        @Override
        public boolean hasNext() {
<span class="nc" id="L284">            return iter.hasNext();</span>
        }

        @Override
        public void close() {
<span class="nc" id="L289">            iter.close();</span>
<span class="nc" id="L290">        }</span>

        @Override
        public String next() {
<span class="nc" id="L294">           return iter.next().getId();</span>
        }
        
    }
<span class="fc" id="L298">	private final class NoLambdaFastqIdIterator extends AbstractBlockingStreamingIterator&lt;String&gt; implements StreamingIterator&lt;String&gt;{</span>

    	


		@Override
    	protected void backgroundThreadRunMethod() {
    		try {
    			
<span class="fc" id="L307">    			FastqVisitor visitor = new FastqVisitor() {</span>
					
					@Override
					public void visitEnd() {
						//no-op						
<span class="fc" id="L312">					}</span>
					@Override
					public void halted(){
						//no-op
<span class="fc" id="L316">			    	}</span>
					@Override
					public FastqRecordVisitor visitDefline(final FastqVisitorCallback callback,
							String id, String optionalComment) {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">						if(NoLambdaFastqIdIterator.this.isClosed()){</span>
<span class="nc" id="L321">							callback.haltParsing();							</span>
						}
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">						if (filter.test(id)) {						   </span>
<span class="fc" id="L324">						        blockingPut(id);</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">                                                        if(NoLambdaFastqIdIterator.this.isClosed()){</span>
<span class="fc" id="L326">                                                            callback.haltParsing();                                                 </span>
                                                        }
<span class="fc" id="L328">                                                        return null;</span>
						    
						   
							
						}
						
<span class="nc" id="L334">						return null;</span>
					}
				};
    			
<span class="fc" id="L338">               parser.parse(visitor);</span>
<span class="nc" id="L339">           } catch (IOException e) {</span>
                
                //should never happen
<span class="nc" id="L342">                throw new RuntimeException(e);</span>
<span class="fc" id="L343">            }</span>
    		
<span class="fc" id="L345">    	}</span>
    }
    
    /**
     * {@code LargeFastQFileIterator} is an Iterator of {@link FastqRecord}s meant for large
     * fastq files (although small fastqs will work too).
     * @author dkatzel
     *
     *
     */
<span class="fc" id="L355">    private final class LargeFastqFileIterator extends AbstractBlockingStreamingIterator&lt;FastqRecord&gt; implements StreamingIterator&lt;FastqRecord&gt;{</span>

    	


		@Override
    	protected void backgroundThreadRunMethod() {
    		try {
    			
<span class="fc" id="L364">    			FastqVisitor visitor = new FastqVisitor() {</span>
					
					@Override
					public void visitEnd() {
						//no-op						
<span class="fc" id="L369">					}</span>
					@Override
					public void halted(){
						//no-op
<span class="fc" id="L373">			    	}</span>
					@Override
					public FastqRecordVisitor visitDefline(final FastqVisitorCallback callback,
							String id, String optionalComment) {
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">						if(LargeFastqFileIterator.this.isClosed()){</span>
<span class="nc" id="L378">							callback.haltParsing();</span>
<span class="nc" id="L379">							return null;</span>
						}
<span class="fc bfc" id="L381" title="All 2 branches covered.">						if (filter.test(id)) {</span>
							//don't waste CPU time saving a few bytes of memory
							//since we are only iterating through
							//and will probably throw the read away after reading it once.
<span class="fc" id="L385">							return new AbstractFastqRecordVisitor(id,optionalComment,qualityCodec, true) {</span>
								
								@Override
								protected void visitRecord(FastqRecord record) {
<span class="fc bfc" id="L389" title="All 4 branches covered.">								        if(recordFilter ==null || recordFilter.test(record)){</span>
<span class="fc" id="L390">        									blockingPut(record);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">        									if(LargeFastqFileIterator.this.isClosed()){</span>
<span class="fc" id="L392">        										callback.haltParsing();</span>
        									}
								        }
<span class="fc" id="L395">								}</span>
							};
						}
<span class="fc" id="L398">						return null;</span>
					}
				};
    			
<span class="fc" id="L402">                parser.parse(visitor);</span>
<span class="nc" id="L403">           } catch (IOException e) {</span>
                
                //should never happen
<span class="nc" id="L406">                throw new RuntimeException(e);</span>
<span class="fc" id="L407">            }</span>
    		
<span class="fc" id="L409">    	}</span>
    }
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>