<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SCFUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.trace.chromat.scf</a> &gt; <span class="el_source">SCFUtils.java</span></div><h1>SCFUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Sep 15, 2008
 *
 * @author dkatzel
 */
package org.jcvi.jillion.internal.trace.chromat.scf;

import java.nio.ShortBuffer;
import java.util.Arrays;
import java.util.List;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.pos.Position;
import org.jcvi.jillion.core.pos.PositionSequence;
import org.jcvi.jillion.internal.trace.chromat.scf.section.Section;

/**
 * &lt;code&gt;SCFUtils&lt;/code&gt; is an Utility class
 * that contains helper methods for SCF Parsing
 * and Encoding.
 * @author dkatzel
 *
 *
 */
public final class SCFUtils {

    
    /**
     * This is the size in bytes of the SCF Header
     * as defined in the SCF File Format Specification.
     */
    public static final int HEADER_SIZE = 128;
    /**
     * This is the order the {@link Section}s
     * should be encoded in a SCF File.
     */
<span class="fc" id="L57">    public static final List&lt;Section&gt; ORDER_OF_SECTIONS =</span>
<span class="fc" id="L58">                                                Arrays.asList(Section.SAMPLES,</span>
                                                Section.BASES,
                                                Section.COMMENTS,
                                                Section.PRIVATE_DATA);


    /**
     * Magic number of a SCF Header that tells parser
     * that this is indeed an SCF file.
     * The actual values are ASCII for &lt;code&gt;.scf&lt;/code&gt;.
     */
<span class="fc" id="L69">    private static final byte[] MAGIC_NUMBER = new byte[]{0x2E,0x73,0x63,0x66};</span>
    /**
     * private constructor so no one can create it.
     */
<span class="nc" id="L73">    private SCFUtils(){</span>
    	//can not instantiate
<span class="nc" id="L75">    }</span>
    /**
     * Get the magic number that all SCF encoded
     * files need to have in its header
     * to declare itself an SCF encoded file.
     * @return the magic number as a byte array.
     */
    public static final byte[] getMagicNumber(){
    	//defensive copy since java arrays are mutable even if declared final
    	//(someone can still modify the contents just not the size)
<span class="fc" id="L85">        byte[] ret = new byte[MAGIC_NUMBER.length];</span>
<span class="fc" id="L86">        System.arraycopy(MAGIC_NUMBER, 0, ret, 0, ret.length);</span>
<span class="fc" id="L87">        return ret;</span>
    }
    /**
     * Is the given byte array a valid SCF magic number?
     * @param magicNumber the magic number as a byte array.
     * @return {@code true} if the magic number is correct;
     * {@code false} otherwise.
     */
    public static boolean isMagicNumber(byte[] magicNumber){
<span class="fc" id="L96">        return Arrays.equals(MAGIC_NUMBER, magicNumber);</span>
    }
    /**
     * my own implementation of SCF's delta delta algorithm.
     * &lt;br/&gt;psuedo code:
     * &lt;pre&gt;position[i]+= 2*position[i-1]-position[i-2]&lt;/pre&gt;
     * I think mine is more clear than the &quot;fast&quot; version provided
     * in IO_Lib's misc_scf.c which is:
     * &lt;pre&gt;
        uint_2 p_sample1, p_sample2;
        p_sample1 = p_sample2 = 0;
        for (i = 0; i &lt; num_samples; i++) {
            &amp;nbsp;&amp;nbsp;&amp;nbsp;p_sample1  = p_sample1 + samples[i];
            &amp;nbsp;&amp;nbsp;&amp;nbsp;samples[i] = p_sample1 + p_sample2;
            &amp;nbsp;&amp;nbsp;&amp;nbsp;p_sample2  = samples[i];
        }
        &lt;/pre&gt;
     * @param positions the positions data to be encoded.
     */
    public static void deltaDeltaDecode(short[] positions) {
        //special cases when i&lt;2;
        // i=0 is not changed
        //i=1 can only take into account the previous
        //position since there is no index =-1
<span class="fc" id="L120">        positions[1]+= 2*positions[0];</span>
        //now handle where i&gt;=2
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for(int i=2; i&lt;positions.length; i++){</span>
<span class="fc" id="L123">            positions[i] += (short)(2*positions[i-1]-positions[i-2]);</span>
        }
<span class="fc" id="L125">    }</span>

    public static ShortBuffer deltaDeltaEncode(ShortBuffer original){
<span class="fc" id="L128">        ShortBuffer buffer=copy(original);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        for(int i=buffer.limit()-1; i&gt;1; i--){</span>
<span class="fc" id="L130">            final short deltaDelta = (short)(buffer.get(i) - 2*buffer.get(i-1)+buffer.get(i-2));</span>
<span class="fc" id="L131">            buffer.put(i, deltaDelta);</span>
        }
        //special case i=1
<span class="fc" id="L134">        buffer.put(1, (short)(buffer.get(1) - 2*buffer.get(0)));</span>
        //leave i=0 as is
        //reset position to beginning.
<span class="fc" id="L137">         return (ShortBuffer)buffer.rewind();</span>
    }
    public static ShortBuffer deltaDeltaEncode(PositionSequence original){
<span class="fc" id="L140">    	ShortBuffer buffer = ShortBuffer.allocate((int)original.getLength());</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">    	for(Position pos : original){</span>
<span class="fc" id="L142">    		buffer.put(IOUtil.toSignedShort(pos.getValue()));</span>
<span class="fc" id="L143">    	}</span>
<span class="fc" id="L144">    	buffer.rewind();</span>
<span class="fc" id="L145">    	return  deltaDeltaEncode(buffer);</span>
    }
    public static short[] deltaDeltaEncode(short[] original){
<span class="fc" id="L148">        return deltaDeltaEncode(ShortBuffer.wrap(original)).array();</span>
    }

    public static ShortBuffer copy(ShortBuffer original) {
<span class="fc" id="L152">        ShortBuffer aCopy=ShortBuffer.allocate(original.remaining());</span>
<span class="fc" id="L153">        aCopy.put(original);</span>
<span class="fc" id="L154">        return (ShortBuffer)aCopy.rewind();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>