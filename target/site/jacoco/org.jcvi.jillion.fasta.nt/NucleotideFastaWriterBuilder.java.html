<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NucleotideFastaWriterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.fasta.nt</a> &gt; <span class="el_source">NucleotideFastaWriterBuilder.java</span></div><h1>NucleotideFastaWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.fasta.nt;


import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.datastore.DataStoreFilters;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.util.JoinedStringBuilder;
import org.jcvi.jillion.core.util.MapUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.fasta.FastaWriter;
import org.jcvi.jillion.internal.fasta.FastaUtil;
import org.jcvi.jillion.internal.fasta.InMemorySortedFastaWriter;
import org.jcvi.jillion.internal.fasta.TmpDirSortedFastaWriter;
import org.jcvi.jillion.shared.fasta.AbstractResidueFastaWriter;
/**
 * {@code NucleotideFastaWriterBuilder} is a Builder
 * class that will create a new instance of 
 * {@link NucleotideFastaWriter}
 * that will write fasta encoded data
 * to the given File or {@link OutputStream}.
 * @author dkatzel
 *
 */
public final class NucleotideFastaWriterBuilder extends AbstractResidueFastaWriter.Builder&lt;Nucleotide, NucleotideSequence, NucleotideSequenceBuilder, NucleotideFastaRecord,NucleotideFastaWriter, NucleotideFastaWriterBuilder&gt; {
		private boolean nonRedundant;
		private Integer expectedCapacity;
		
		private File outputFile;
		private boolean createIndex;
		
		/**
		 * Create a new Builder that will use
		 * the given File to write
		 * out the fasta records.  Any contents
		 * that previously existed in this file
		 * will be overwritten.  If this file or
		 * any parent directories do not exist,
		 * then they will be created.
		 * 
		 * Since 5.3, if the file extension is either {@code &quot;.gz&quot; or &quot;.zip&quot;}
		 * then the writer will automatically compress the output for you.
		 * 
		 * @param outputFile the File to use;
		 * can not be null.
		 * @throws NullPointerException if outputFile is null.
		 * @throws IOException if the file exists but 
		 * is a directory rather than a regular file, 
		 * does not exist but cannot be created, 
		 * or cannot be opened for any other reason.
		 */
		public NucleotideFastaWriterBuilder(File outputFile) throws IOException {
<span class="fc" id="L85">			super(outputFile);</span>
<span class="fc" id="L86">			this.outputFile = outputFile;</span>
<span class="fc" id="L87">		}</span>
		/**
		 * Create a new Builder that will use
		 * the given {@link OutputStream} to write
		 * out the fasta records.
		 * @param out the {@link OutputStream} to use;
		 * can not be null.
		 * @throws NullPointerException if out is null.
		 */
		public NucleotideFastaWriterBuilder(OutputStream out) {
<span class="fc" id="L97">			super(out);</span>
<span class="fc" id="L98">		}</span>
		
		
		@Override
        protected NucleotideFastaWriterBuilder getThis() {
<span class="fc" id="L103">            return this;</span>
        }
        /**
		 * Write out the Fasta as a
		 * non-redundant database (like BLAST's nr).
		 * Identical sequences will have their deflines merged
		 * into a single defline where each record is separated by control-A characters
		 * invisible to most programs.
		 * &lt;br/&gt;
		 * In the example below both entries gi|1469284 and gi|1477453 
		 * have the same sequence, in every respect:
		 * &lt;pre&gt;
		 * &gt;gi|3023276|sp|Q57293|AFUC_ACTPL   Ferric transport ATP-binding protein afuC
		 * ^Agi|1469284|gb|AAB05030.1|   afuC gene product ^Agi|1477453|gb|AAB17216.1|
		 * afuC [Actinobacillus pleuropneumoniae]
		 * ATGAACAACGATTTTCTGGTGCTGAAAAACATTACCAAAAGCTTTGGCAAAGCGACCGTG
		 * ATTGATAACCTGGATCTGGTGATTAAACGCGGCACCATGGTGACCCTGCTGGGCCCGAGC
		 * GGCTGCGGCAAAACCACCGTGCTGCGCCTGGTGGCGGGCCTGGAAAACCCGACCAGCGGC
		 * CAGATTTTTATTGATGGCGAAGATGTGACCAAAAGCAGCATTCAGAACCGCGATATTTGC
		 * ATTGTGTTTCAGAGCTATGCGCTGTTTCCGCATATGAGCATTGGCGATAACGTGGGCTAT
		 * GGCCTGCGCATGCAGGGCGTGAGCAACGAAGAACGCAAACAGCGCGTGAAAGAAGCGCTG
		 * GAACTGGTGGATCTGGCGGGCTTTGCGGATCGCTTTGTGGATCAGATTAGCGGCGGCCAG
		 * CAGCAGCGCGTGGCGCTGGCGCGCGCGCTGGTGCTGAAACCGAAAGTGCTGATTCTGGAT
		 * GAACCGCTGAGCAACCTGGATGCGAACCTGCGCCGCAGCATGCGCGAAAAAATTCGCGAA
		 * CTGCAGCAGCGCCTGGGCATTACCAGCCTGTATGTGACCCATGATCAGACCGAAGCGTTT
		 * GCGGTGAGCGATGAAGTGATTGTGATGAACAAAGGCACCATTATGCAGAAAGCGCGCCAG
		 * AAAATTTTTATTTATGATCGCATTCTGTATAGCCTGCGCAACTTTATGGGCGAAAGCACC
		 * ATTTGCGATGGCAACCTGAACCAGGGCACCGTGAGCATTGGCGATTATCGCTTTCCGCTG
		 * CATAACGCGGCGGATTTTAGCGTGGCGGATGGCGCGTGCCTGGTGGGCGTGCGCCCGGAA
		 * GCGATTCGCCTGACCGCGACCGGCGAAACCAGCCAGCGCTGCCAGATTAAAAGCGCGGTG
		 * TATATGGGCAACCATTGGGAAATTGTGGCGAACTGGAACGGCAAAGATGTGCTGATTAAC
		 * GCGAACCCGGATCAGTTTGATCCGGATGCGACCAAAGCGTTTATTCATTTTACCGAACAG
		 * GGCATTTTTCTGCTGAACAAAGAA
		 * &lt;/pre&gt;
		 * 
		 * @return this
		 * 
		 * @since 5.0
		 */
		public NucleotideFastaWriterBuilder makeNonRedundant(){
<span class="fc" id="L143">			this.nonRedundant = true;</span>
<span class="fc" id="L144">			this.expectedCapacity = null;</span>
<span class="fc" id="L145">			return this;</span>
		}
		/**
		 * Write out the Fasta as a
		 * non-redundant database (like BLAST's nr).
		 * Identical sequences will have their deflines merged
		 * into a single defline where each record is separated by control-A characters
		 * invisible to most programs.
		 * &lt;br/&gt;
		 * In the example below both entries gi|1469284 and gi|1477453 
		 * have the same sequence, in every respect:
		 * &lt;pre&gt;
		 * &gt;gi|3023276|sp|Q57293|AFUC_ACTPL   Ferric transport ATP-binding protein afuC
		 * ^Agi|1469284|gb|AAB05030.1|   afuC gene product ^Agi|1477453|gb|AAB17216.1|
		 * afuC [Actinobacillus pleuropneumoniae]
		 * ATGAACAACGATTTTCTGGTGCTGAAAAACATTACCAAAAGCTTTGGCAAAGCGACCGTG
		 * ATTGATAACCTGGATCTGGTGATTAAACGCGGCACCATGGTGACCCTGCTGGGCCCGAGC
		 * GGCTGCGGCAAAACCACCGTGCTGCGCCTGGTGGCGGGCCTGGAAAACCCGACCAGCGGC
		 * CAGATTTTTATTGATGGCGAAGATGTGACCAAAAGCAGCATTCAGAACCGCGATATTTGC
		 * ATTGTGTTTCAGAGCTATGCGCTGTTTCCGCATATGAGCATTGGCGATAACGTGGGCTAT
		 * GGCCTGCGCATGCAGGGCGTGAGCAACGAAGAACGCAAACAGCGCGTGAAAGAAGCGCTG
		 * GAACTGGTGGATCTGGCGGGCTTTGCGGATCGCTTTGTGGATCAGATTAGCGGCGGCCAG
		 * CAGCAGCGCGTGGCGCTGGCGCGCGCGCTGGTGCTGAAACCGAAAGTGCTGATTCTGGAT
		 * GAACCGCTGAGCAACCTGGATGCGAACCTGCGCCGCAGCATGCGCGAAAAAATTCGCGAA
		 * CTGCAGCAGCGCCTGGGCATTACCAGCCTGTATGTGACCCATGATCAGACCGAAGCGTTT
		 * GCGGTGAGCGATGAAGTGATTGTGATGAACAAAGGCACCATTATGCAGAAAGCGCGCCAG
		 * AAAATTTTTATTTATGATCGCATTCTGTATAGCCTGCGCAACTTTATGGGCGAAAGCACC
		 * ATTTGCGATGGCAACCTGAACCAGGGCACCGTGAGCATTGGCGATTATCGCTTTCCGCTG
		 * CATAACGCGGCGGATTTTAGCGTGGCGGATGGCGCGTGCCTGGTGGGCGTGCGCCCGGAA
		 * GCGATTCGCCTGACCGCGACCGGCGAAACCAGCCAGCGCTGCCAGATTAAAAGCGCGGTG
		 * TATATGGGCAACCATTGGGAAATTGTGGCGAACTGGAACGGCAAAGATGTGCTGATTAAC
		 * GCGAACCCGGATCAGTTTGATCCGGATGCGACCAAAGCGTTTATTCATTTTACCGAACAG
		 * GGCATTTTTCTGCTGAACAAAGAA
		 * &lt;/pre&gt;
		 * If this method is called multiple times, then only the last
		 * method call will be respected. (Last call wins)
		 * 
		 * @param expectedSize the expected number of non-redundant records.
		 * This is only uses as a performance optimization to initialize
		 * internal datastructures.  Must be &gt;0.
		 * 
		 * @return this
		 * 
		 * @throws IllegalArgumentException if expectedSize &lt; 1
		 * 
		 * @since 5.0
		 */
		public NucleotideFastaWriterBuilder makeNonRedundant(int expectedSize){

<span class="nc bnc" id="L194" title="All 2 branches missed.">			if(expectedSize &lt;1){</span>
<span class="nc" id="L195">				throw new IllegalArgumentException(&quot;expected size must be &gt;= 1&quot;);					</span>
			}
<span class="nc" id="L197">			this.expectedCapacity = expectedSize;			</span>
<span class="nc" id="L198">			this.nonRedundant = true;</span>
<span class="nc" id="L199">			return this;</span>
		}
		
		/**
		 * While writing out the Nucleotide Fasta File,
		 * also write a {@code .fai} Fasta Index File 
		 * which is used by Samtools.  The index
		 * file will follow Samtools naming conventions and write
		 * the file to the same directory as the output fasta and name
		 * it {@code $outputFile.fai}; this option is only used
		 * if this writer was created by using the 
		 * {@link #NucleotideFastaWriterBuilder(File)} constructor.
		 * 
		 * @param createIndex {@code true} if a fai file should be created;
		 * {@code false} otherwise.
		 * 
		 * @return  this.
		 * 
		 * @since 5.1
		 */
		public NucleotideFastaWriterBuilder createIndex(boolean createIndex){
<span class="fc" id="L220">			this.createIndex = createIndex;</span>
<span class="fc" id="L221">			return this;</span>
		}

		@Override
		protected NucleotideFastaWriter create(
				OutputStream out, int numberOfResiduesPerLine, Charset charSet, String eol) {
			
<span class="fc bfc" id="L228" title="All 2 branches covered.">			if(nonRedundant){</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">				if(expectedCapacity ==null){</span>
<span class="fc" id="L230">					return new NonRedundantNucleotideSequenceFastaWriter(out, numberOfResiduesPerLine, charSet, eol);</span>
				}
<span class="nc" id="L232">				return new NonRedundantNucleotideSequenceFastaWriter(out, numberOfResiduesPerLine, charSet, eol, expectedCapacity);</span>
			}
<span class="fc" id="L234">			return new NucleotideSequenceFastaRecordWriterImpl(out, numberOfResiduesPerLine, charSet,eol);</span>
		}
		
		
		
		
		@Override
		public NucleotideFastaWriter build() {
<span class="fc" id="L242">			NucleotideFastaWriter writer = super.build();</span>
<span class="pc bpc" id="L243" title="1 of 4 branches missed.">			if(createIndex &amp;&amp; outputFile !=null){</span>
<span class="fc" id="L244">				File faiFile = new File(outputFile.getParentFile(), outputFile.getName() +&quot;.fai&quot;);</span>
<span class="fc" id="L245">				return new FaiNucleotideFastaWriter(outputFile, faiFile, writer);</span>
			}
<span class="fc" id="L247">			return writer;</span>
		}
		@Override
		protected NucleotideFastaWriter createTmpDirSortedWriterWriter(
				FastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; delegate,
				Comparator&lt;NucleotideFastaRecord&gt; comparator, int cacheSize,
				File tmpDir) {
<span class="fc" id="L254">			return new TmpDirSortedNucleotideFastaWriter(delegate, comparator, cacheSize, tmpDir);</span>
		}
		@Override
		protected NucleotideFastaWriter createInMemorySortedWriterWriter(
				FastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; delegate,
				Comparator&lt;NucleotideFastaRecord&gt; comparator) {
<span class="fc" id="L260">			return new InMemorySortedNucleotideFastaWriter(delegate, comparator);</span>
		}




		private static final class NucleotideSequenceFastaRecordWriterImpl extends AbstractResidueFastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideSequenceBuilder, NucleotideFastaRecord&gt; implements NucleotideFastaWriter{

			private NucleotideSequenceFastaRecordWriterImpl(OutputStream out,
					int numberOfResiduesPerLine, Charset charSet, String eol) {
<span class="fc" id="L270">				super(out, numberOfResiduesPerLine, charSet,eol);</span>
<span class="fc" id="L271">			}</span>
		}
		
		private static interface NonRedundantEntry{
			String getId();
			String getComment();
			
			default String getNonRedundantId(){
<span class="fc" id="L279">				String id = getId();</span>
<span class="fc" id="L280">				String comment = getComment();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">				StringBuilder builder = new StringBuilder(id.length() + (comment ==null?0 : comment.length()+1));</span>
<span class="fc" id="L282">				builder.append(id);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">				if(comment !=null){</span>
<span class="fc" id="L284">					builder.append(' ').append(comment);</span>
				}
<span class="fc" id="L286">				return builder.toString();</span>
			}
			
		}
		
		private static final class CommentedNonRedundantEntry implements NonRedundantEntry{
			private final String id, comment;			
			
<span class="fc" id="L294">			public CommentedNonRedundantEntry(String id, String comment) {</span>
<span class="fc" id="L295">				this.id = id;</span>
<span class="fc" id="L296">				this.comment = comment;</span>
<span class="fc" id="L297">			}</span>

			@Override
			public String getId() {
<span class="fc" id="L301">				return id;</span>
			}

			@Override
			public String getComment() {
<span class="fc" id="L306">				return comment;</span>
			}

			@Override
			public int hashCode() {
<span class="fc" id="L311">				final int prime = 31;</span>
<span class="fc" id="L312">				int result = 1;</span>
<span class="fc" id="L313">				result = prime * result +  id.hashCode();</span>
<span class="fc" id="L314">				result = prime * result	+  comment.hashCode();</span>
				
<span class="fc" id="L316">				return result;</span>
			}

			@Override
			public boolean equals(Object obj) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">				if (this == obj) {</span>
<span class="nc" id="L322">					return true;</span>
				}
<span class="nc bnc" id="L324" title="All 2 branches missed.">				if (obj == null) {</span>
<span class="nc" id="L325">					return false;</span>
				}
<span class="nc bnc" id="L327" title="All 2 branches missed.">				if (!(obj instanceof NonRedundantEntry)) {</span>
<span class="nc" id="L328">					return false;</span>
				}
<span class="nc" id="L330">				NonRedundantEntry other = (NonRedundantEntry) obj;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">				if (!getComment().equals(other.getComment())) {</span>
<span class="nc" id="L332">					return false;</span>
				}
<span class="nc bnc" id="L334" title="All 2 branches missed.">				if (!getId().equals(other.getId())) {</span>
<span class="nc" id="L335">					return false;</span>
				}
<span class="nc" id="L337">				return true;</span>
			}
			
			
			
		}
		
		private static final class NoCommentedNonRedundantEntry implements NonRedundantEntry{
			private final String id;			
			
<span class="fc" id="L347">			public NoCommentedNonRedundantEntry(String id) {</span>
<span class="fc" id="L348">				this.id = id;</span>
<span class="fc" id="L349">			}</span>

			@Override
			public String getId() {
<span class="fc" id="L353">				return id;</span>
			}

			@Override
			public String getComment() {
<span class="fc" id="L358">				return null;</span>
			}

			@Override
			public int hashCode() {
<span class="fc" id="L363">				final int prime = 31;</span>
<span class="fc" id="L364">				int result = 1;</span>
<span class="fc" id="L365">				result = prime * result +  id.hashCode();</span>
<span class="fc" id="L366">				result = prime * result	; //null comment </span>
<span class="fc" id="L367">				return result;</span>
			}

			@Override
			public boolean equals(Object obj) {
<span class="nc bnc" id="L372" title="All 2 branches missed.">				if (this == obj) {</span>
<span class="nc" id="L373">					return true;</span>
				}
<span class="nc bnc" id="L375" title="All 2 branches missed.">				if (obj == null) {</span>
<span class="nc" id="L376">					return false;</span>
				}
<span class="nc bnc" id="L378" title="All 2 branches missed.">				if (!(obj instanceof NonRedundantEntry)) {</span>
<span class="nc" id="L379">					return false;</span>
				}
<span class="nc" id="L381">				NonRedundantEntry other = (NonRedundantEntry) obj;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">				if (other.getComment() !=null) {</span>
<span class="nc" id="L383">					return false;</span>
				}
<span class="nc bnc" id="L385" title="All 2 branches missed.">				if (!getId().equals(other.getId())) {</span>
<span class="nc" id="L386">					return false;</span>
				}
<span class="nc" id="L388">				return true;</span>
			}
			
			
			
		}
		
		private static final class NonRedundantNucleotideSequenceFastaWriter implements NucleotideFastaWriter{

			
			private final Map&lt;NucleotideSequence, Set&lt;NonRedundantEntry&gt;&gt; nonRedundantMap;
			
			private final NucleotideSequenceFastaRecordWriterImpl delegateWriter;
			
			public NonRedundantNucleotideSequenceFastaWriter(OutputStream out,
					int numberOfResiduesPerLine, Charset charSet, String eol){
<span class="fc" id="L404">				this(out, numberOfResiduesPerLine, charSet, eol, 1000);</span>
<span class="fc" id="L405">			}</span>
			public NonRedundantNucleotideSequenceFastaWriter(OutputStream out,
<span class="fc" id="L407">					int numberOfResiduesPerLine, Charset charSet, String eol, int expectedSize){</span>
<span class="fc" id="L408">				nonRedundantMap = new LinkedHashMap&lt;&gt;(MapUtil.computeMinHashMapSizeWithoutRehashing(expectedSize));</span>
				
<span class="fc" id="L410">				delegateWriter = new NucleotideSequenceFastaRecordWriterImpl(out, numberOfResiduesPerLine, charSet, eol);</span>
<span class="fc" id="L411">			}</span>
			
			@Override
			public void close() throws IOException {
				try{
<span class="fc bfc" id="L416" title="All 2 branches covered.">					for(Entry&lt;NucleotideSequence, Set&lt;NonRedundantEntry&gt;&gt; entry : nonRedundantMap.entrySet()){</span>
<span class="fc" id="L417">						NucleotideSequence sequence = entry.getKey();</span>
						
<span class="fc" id="L419">						String ids =JoinedStringBuilder.create(entry.getValue())</span>
<span class="fc" id="L420">											.glue(FastaUtil.getNonRedundantSeparator())</span>
<span class="fc" id="L421">											.transform(NonRedundantEntry::getNonRedundantId)</span>
<span class="fc" id="L422">											.build();</span>
						
<span class="fc" id="L424">						delegateWriter.write(ids, sequence);</span>
<span class="fc" id="L425">					}</span>
				}finally{
<span class="pc" id="L427">					delegateWriter.close();</span>
<span class="fc" id="L428">				}</span>
				
<span class="fc" id="L430">			}</span>

			@Override
			public void write(NucleotideFastaRecord record) throws IOException {
<span class="nc" id="L434">				write(record.getId(), record.getSequence(), record.getComment());</span>
				
<span class="nc" id="L436">			}</span>

			@Override
			public void write(String id, NucleotideSequence sequence)
					throws IOException {
<span class="fc" id="L441">				write(id, sequence, null);</span>
				
<span class="fc" id="L443">			}</span>

			@Override
			public void write(String id, NucleotideSequence sequence,
					String optionalComment) throws IOException {
				NonRedundantEntry entry;
<span class="fc bfc" id="L449" title="All 2 branches covered.">				if(optionalComment ==null){</span>
<span class="fc" id="L450">					entry = new NoCommentedNonRedundantEntry(id);</span>
				}else{
<span class="fc" id="L452">					entry = new CommentedNonRedundantEntry(id, optionalComment);</span>
				}
				
<span class="fc" id="L455">				nonRedundantMap.computeIfAbsent(sequence, k-&gt; new LinkedHashSet&lt;&gt;())</span>
<span class="fc" id="L456">									.add(entry);</span>
				
				
<span class="fc" id="L459">			}</span>
			
			
		}
		
		
		private static final class InMemorySortedNucleotideFastaWriter extends InMemorySortedFastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; implements NucleotideFastaWriter{

			public InMemorySortedNucleotideFastaWriter(FastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; writer,
					Comparator&lt;NucleotideFastaRecord&gt; comparator) {
<span class="fc" id="L469">				super(writer, comparator);</span>
<span class="fc" id="L470">			}</span>

			@Override
			protected NucleotideFastaRecord createRecord(String id, NucleotideSequence sequence, String optionalComment) {
<span class="nc" id="L474">				return new NucleotideFastaRecordBuilder(id, sequence)</span>
<span class="nc" id="L475">								.comment(optionalComment)</span>
<span class="nc" id="L476">								.build();</span>
			}
			
		}
		
		private static final class TmpDirSortedNucleotideFastaWriter extends TmpDirSortedFastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; implements NucleotideFastaWriter{

			

			public TmpDirSortedNucleotideFastaWriter(
					FastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; finalWriter,
					Comparator&lt;NucleotideFastaRecord&gt; comparator, int cacheSize,
					File tmpDir) {
<span class="fc" id="L489">				super(finalWriter, comparator, tmpDir, cacheSize);</span>
<span class="fc" id="L490">			}</span>

			@Override
			protected StreamingIterator&lt;NucleotideFastaRecord&gt; createStreamingIteratorFor(
					File tmpFastaFile) throws IOException, DataStoreException {
<span class="fc" id="L495">				return LargeNucleotideSequenceFastaIterator.createNewIteratorFor(tmpFastaFile, DataStoreFilters.alwaysAccept(),null);</span>
			}

			@Override
			protected FastaWriter&lt;Nucleotide, NucleotideSequence, NucleotideFastaRecord&gt; createNewTmpWriter(
					File tmpFile) throws IOException {
<span class="fc" id="L501">				return new NucleotideFastaWriterBuilder(tmpFile)</span>
<span class="fc" id="L502">									.build();</span>
			}

			@Override
			protected NucleotideFastaRecord createFastaRecord(String id,
					NucleotideSequence sequence, String optionalComment) {

<span class="nc" id="L509">				return new NucleotideFastaRecordBuilder(id, sequence)</span>
<span class="nc" id="L510">									.comment(optionalComment)</span>
<span class="nc" id="L511">									.build();</span>
			}
			
		}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>