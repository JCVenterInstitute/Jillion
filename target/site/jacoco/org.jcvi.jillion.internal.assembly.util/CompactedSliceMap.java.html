<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CompactedSliceMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.assembly.util</a> &gt; <span class="el_source">CompactedSliceMap.java</span></div><h1>CompactedSliceMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.assembly.util;

import java.util.Arrays;
import java.util.Iterator;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.assembly.util.GapQualityValueStrategy;
import org.jcvi.jillion.assembly.util.Slice;
import org.jcvi.jillion.assembly.util.SliceBuilder;
import org.jcvi.jillion.assembly.util.SliceMap;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceDataStore;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.iter.ArrayIterator;
import org.jcvi.jillion.core.util.iter.StreamingIterator;

/**
 * @author dkatzel
 * 
 * 
 */
public final class CompactedSliceMap implements SliceMap {
<span class="fc" id="L49">    private static final PhredQuality DEFAULT_QUALITY = PhredQuality.valueOf(30);</span>
	private final Slice[] slices;
	

    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(Contig&lt;PR&gt; contig,QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="fc" id="L54">        return new CompactedSliceMap(contig, qualityDataStore, qualityValueStrategy, DEFAULT_QUALITY);</span>
    }
    
    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(
    		StreamingIterator&lt;PR&gt; iter, NucleotideSequence consensusSequence,
    		QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="fc" id="L60">        return new CompactedSliceMap(iter, consensusSequence, qualityDataStore, qualityValueStrategy, DEFAULT_QUALITY);</span>
    }
    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(
    		StreamingIterator&lt;PR&gt; iter, NucleotideSequence consensusSequence,
    		PhredQuality defaultQuality,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="fc" id="L65">        return new CompactedSliceMap(iter, consensusSequence, null, qualityValueStrategy, defaultQuality);</span>
    }
   
    private &lt;PR extends AssembledRead, C extends Contig&lt;PR&gt;&gt;  CompactedSliceMap(
            C contig, QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy, PhredQuality defaultQuality) throws DataStoreException {
<span class="fc" id="L70">		this(contig.getReadIterator(), contig.getConsensusSequence(), qualityDataStore,</span>
				qualityValueStrategy,defaultQuality);
<span class="fc" id="L72">    }</span>
    private &lt;PR extends AssembledRead, C extends Contig&lt;PR&gt;&gt;  CompactedSliceMap(StreamingIterator&lt;PR&gt; readIter,
    		NucleotideSequence consensusSequence, QualitySequenceDataStore qualityDataStore,
			GapQualityValueStrategy qualityValueStrategy, PhredQuality defaultQuality)
<span class="fc" id="L76">			throws DataStoreException {</span>
<span class="fc" id="L77">		SliceBuilder builders[] = initializeSliceBuilders(consensusSequence);</span>
		
    	try{
<span class="fc bfc" id="L80" title="All 2 branches covered.">    		while(readIter.hasNext()){</span>
<span class="fc" id="L81">    			PR read = readIter.next();</span>
<span class="fc" id="L82">    			int start = (int)read.getGappedStartOffset();</span>
<span class="fc" id="L83">    			int i=0;</span>
<span class="fc" id="L84">    			String id =read.getId();</span>
<span class="fc" id="L85">    			Direction dir = read.getDirection();</span>
<span class="fc" id="L86">    			Iterator&lt;PhredQuality&gt; validRangeGappedQualitiesIterator =null;</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">    			if(qualityDataStore==null){</span>
<span class="fc" id="L88">    				validRangeGappedQualitiesIterator = createNewDefaultQualityIterator(defaultQuality);</span>

    			}else{
<span class="fc" id="L91">    				QualitySequence fullQualities = qualityDataStore.get(id);</span>
        			
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        			if(fullQualities ==null){</span>
<span class="nc" id="L94">        				throw new NullPointerException(&quot;could not get qualities for &quot;+id);</span>
        			}
<span class="fc" id="L96">        			validRangeGappedQualitiesIterator = qualityValueStrategy.getGappedValidRangeQualitySequenceFor(read, fullQualities)</span>
<span class="fc" id="L97">        													.iterator();</span>
        			
    			}
<span class="fc" id="L100">    			Iterator&lt;Nucleotide&gt; baseIterator = read.getNucleotideSequence().iterator();</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    			while(baseIterator.hasNext()){</span>
<span class="fc" id="L102">    				Nucleotide base = baseIterator.next();</span>
<span class="fc" id="L103">    				PhredQuality quality = validRangeGappedQualitiesIterator.next();</span>
<span class="fc" id="L104">    				builders[start+i].add(id, base, quality, dir);</span>
<span class="fc" id="L105">    				i++;</span>
<span class="fc" id="L106">    			}</span>
<span class="fc" id="L107">    		}</span>
    		//done building
<span class="fc" id="L109">    		this.slices = new Slice[builders.length];</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    		for(int i=0; i&lt;slices.length; i++){</span>
<span class="fc" id="L111">    			slices[i]= builders[i].build();</span>
    		}
    	}finally{
<span class="pc" id="L114">    		IOUtil.closeAndIgnoreErrors(readIter);</span>
<span class="fc" id="L115">    	}</span>
<span class="fc" id="L116">	}</span>

    private SliceBuilder[] initializeSliceBuilders(NucleotideSequence consensus){
<span class="fc" id="L119">    	SliceBuilder builders[] = new SliceBuilder[(int)consensus.getLength()];</span>
<span class="fc" id="L120">		int i=0;</span>
<span class="fc" id="L121">		Iterator&lt;Nucleotide&gt; iter = consensus.iterator();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">		while(iter.hasNext()){</span>
<span class="fc" id="L123">			builders[i++] = new SliceBuilder().setConsensus(iter.next());</span>
		}
<span class="fc" id="L125">    	return builders;</span>
    }

    private Iterator&lt;PhredQuality&gt; createNewDefaultQualityIterator(
			final PhredQuality defaultQuality) {
<span class="fc" id="L130">		return new Iterator&lt;PhredQuality&gt;(){</span>
				
			@Override
			public boolean hasNext() {
				//always return true
<span class="nc" id="L135">				return true;</span>
			}
			@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(
					value = {&quot;IT_NO_SUCH_ELEMENT&quot;}, 
					justification = &quot;only used for fake data will never have no such element exception&quot;)				
			@Override
			public PhredQuality next() {
<span class="fc" id="L142">				return defaultQuality;</span>
			}

			@Override
			public void remove() {
				//no-op				
<span class="nc" id="L148">			}</span>
			
		};
	}
	/**
     * {@inheritDoc}
     */
    @Override
    public Iterator&lt;Slice&gt; iterator() {
<span class="fc" id="L157">        return new ArrayIterator&lt;Slice&gt;(slices, false);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Slice getSlice(long offset) {
<span class="fc" id="L165">        return slices[(int) offset];</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getSize() {
<span class="fc" id="L173">        return slices.length;</span>
    }
	@Override
	public int hashCode() {
<span class="fc" id="L177">		final int prime = 31;</span>
<span class="fc" id="L178">		int result = 1;</span>
<span class="fc" id="L179">		result = prime * result + Arrays.hashCode(slices);</span>
<span class="fc" id="L180">		return result;</span>
	}
	@Override
	public boolean equals(Object obj) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">		if (this == obj) {</span>
<span class="fc" id="L185">			return true;</span>
		}
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L188">			return false;</span>
		}
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		if (!(obj instanceof SliceMap)) {</span>
<span class="nc" id="L191">			return false;</span>
		}
<span class="fc" id="L193">		SliceMap other = (SliceMap) obj;</span>
<span class="fc" id="L194">		Iterator&lt;Slice&gt; iter = iterator();</span>
<span class="fc" id="L195">		Iterator&lt;Slice&gt; otherIter = other.iterator();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">		while(iter.hasNext()){</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">			if(!otherIter.hasNext()){</span>
<span class="nc" id="L198">				return false;</span>
			}
<span class="fc bfc" id="L200" title="All 2 branches covered.">			if(!iter.next().equals(otherIter.next())){</span>
<span class="fc" id="L201">				return false;</span>
			}
		}
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">		if(otherIter.hasNext()){</span>
<span class="nc" id="L205">			return false;</span>
		}
		
<span class="fc" id="L208">		return true;</span>
	}

    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>