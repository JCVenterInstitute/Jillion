<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConsensusCollectors.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util.consensus</a> &gt; <span class="el_source">ConsensusCollectors.java</span></div><h1>ConsensusCollectors.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.util.consensus;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collector.Characteristics;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.util.GapQualityValueStrategy;
import org.jcvi.jillion.assembly.util.SliceElement;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.datastore.DataStoreEntry;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.core.qual.QualitySequenceDataStore;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.internal.assembly.util.CompactedSliceElement;

/**
 * Utility class of {@link Collector}s that can compute
 * Consensus sequence from a {@link java.util.stream.Stream} of sequence data.
 * 
 * @author dkatzel
 *
 * @since 5.2
 */
public final class ConsensusCollectors {

    

<span class="nc" id="L61">    private ConsensusCollectors(){</span>
        //can not instantiate
<span class="nc" id="L63">    }</span>
    
    public static Collector&lt;SliceElement[], ConsensusCombiner, NucleotideSequence&gt; toSliceConsensus(ConsensusCaller caller){
        
<span class="nc" id="L67">        Objects.requireNonNull(caller);</span>
       
        
<span class="nc" id="L70">        return Collector.of(ConsensusCombiner::new,</span>
                ConsensusCombiner::add, 
                ConsensusCombiner::merge, 
<span class="nc" id="L73">                (ConsensusCombiner combiner)-&gt;  combiner.computeConsensus(caller)</span>
<span class="nc" id="L74">                        .turnOffDataCompression(true)</span>
<span class="nc" id="L75">                        .build(),</span>
                Characteristics.UNORDERED);
        
    }
    
    public static Collector&lt;DataStoreEntry&lt;NucleotideSequence&gt;, ConsensusCombiner, NucleotideSequence&gt; toDataStoreConsensus(ConsensusCaller caller){
<span class="nc" id="L81">        return toDataStoreConsensus(caller, PhredQuality.valueOf(25));</span>
    }
    
    public static Collector&lt;DataStoreEntry&lt;NucleotideSequence&gt;, ConsensusCombiner, NucleotideSequence&gt; toDataStoreConsensus(ConsensusCaller caller, PhredQuality defaultQuality){
<span class="nc" id="L85">        return new DataStoreConsensusCaller(caller, defaultQuality);</span>
    }
    
    public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller){
<span class="nc" id="L89">        return toAssemblyConsensus(caller, PhredQuality.valueOf(25));</span>
    }
    
    public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, NucleotideSequence referenceOrOldConsensus){
<span class="nc" id="L93">        return toAssemblyConsensus(caller, PhredQuality.valueOf(25), referenceOrOldConsensus);</span>
    }
 
    public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, PhredQuality defaultQuality){
<span class="nc" id="L97">        Objects.requireNonNull(caller);</span>
<span class="nc" id="L98">        Objects.requireNonNull(defaultQuality);</span>
        
<span class="nc" id="L100">        return new DefaultQualityAssemblyConsensusCollector(caller, defaultQuality);</span>
        
    }
    
    public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, PhredQuality defaultQuality, NucleotideSequence referenceOrOldConsensus){
<span class="nc" id="L105">        Objects.requireNonNull(caller);</span>
<span class="nc" id="L106">        Objects.requireNonNull(defaultQuality);</span>
        
<span class="nc" id="L108">        return new DefaultQualityAssemblyConsensusCollector(caller, defaultQuality, referenceOrOldConsensus);</span>
        
    }
    
    public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, QualitySequenceDataStore gappedQualityDataStore){
        
<span class="nc" id="L114">        Objects.requireNonNull(caller);</span>
<span class="nc" id="L115">        Objects.requireNonNull(gappedQualityDataStore);</span>
        
<span class="nc" id="L117">       return new AssemblyDataStoreConsensusCollector(caller, gappedQualityDataStore);</span>
        
    }
    
 public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, QualitySequenceDataStore gappedQualityDataStore, NucleotideSequence referenceOrOldConsensus){
        
<span class="nc" id="L123">        Objects.requireNonNull(caller);</span>
<span class="nc" id="L124">        Objects.requireNonNull(gappedQualityDataStore);</span>
        
<span class="nc" id="L126">       return new AssemblyDataStoreConsensusCollector(caller, gappedQualityDataStore, referenceOrOldConsensus);</span>
        
    }
    
 public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, QualitySequenceDataStore rawQualityDataStore, GapQualityValueStrategy gapQualityValueStrategy){
   
        
<span class="nc" id="L133">       return toAssemblyConsensus(caller, rawQualityDataStore, gapQualityValueStrategy, null);</span>
        
    }
 
 public static Collector&lt;AssembledRead, ConsensusCombiner, NucleotideSequence&gt; toAssemblyConsensus(ConsensusCaller caller, QualitySequenceDataStore rawQualityDataStore, GapQualityValueStrategy gapQualityValueStrategy, NucleotideSequence referenceOrOldConsensus){
     
<span class="nc" id="L139">     Objects.requireNonNull(caller);</span>
<span class="nc" id="L140">     Objects.requireNonNull(rawQualityDataStore);</span>
<span class="nc" id="L141">     Objects.requireNonNull(gapQualityValueStrategy);</span>
     
<span class="nc" id="L143">    return new UngappedConverterAssemblyConsensusCollector(caller, rawQualityDataStore, gapQualityValueStrategy,referenceOrOldConsensus);</span>
     
 }
    
    private static class UngappedConverterAssemblyConsensusCollector extends AssemblyDataStoreConsensusCollector{

        private final GapQualityValueStrategy strategy;
        
       
        
        public UngappedConverterAssemblyConsensusCollector(ConsensusCaller caller, QualitySequenceDataStore qualities, GapQualityValueStrategy strategy, NucleotideSequence referenceConsensus) {
<span class="nc" id="L154">            super(caller, qualities, referenceConsensus);</span>
<span class="nc" id="L155">           this.strategy = strategy;</span>
<span class="nc" id="L156">        }</span>

        @Override
        protected QualitySequence toGappedQualitySequence(AssembledRead read, QualitySequence rawQualities) {
<span class="nc" id="L160">            return strategy.getGappedValidRangeQualitySequenceFor(read, rawQualities);</span>
        }
        
        
        
    }

    private static abstract class AbstractAssemblyConsensusCollector extends AbstractConsensusCollector&lt;AssembledRead&gt; {

       
        public AbstractAssemblyConsensusCollector(ConsensusCaller caller) {
<span class="nc" id="L171">           super(caller);</span>
<span class="nc" id="L172">        }</span>

        @Override
        protected NucleotideSequence getSequenceFor(AssembledRead read) {
<span class="nc" id="L176">            return read.getNucleotideSequence();</span>
        }

        @Override
        protected int getStartOffset(AssembledRead read) {
<span class="nc" id="L181">            return (int) read.getBegin();</span>
        }

        @Override
        protected int getLength(AssembledRead read) {
<span class="nc" id="L186">            return (int) read.getLength();</span>
        }

        @Override
        protected String getId(AssembledRead read) {
<span class="nc" id="L191">            return read.getId();</span>
        }

        @Override
        protected Direction getDirection(AssembledRead read) {
<span class="nc" id="L196">            return read.getDirection();</span>
        }

    }
    
    
    private static class DataStoreConsensusCaller extends AbstractConsensusCollector&lt;DataStoreEntry&lt;NucleotideSequence&gt;&gt;{

        private final byte defaultQuality;
        
        public DataStoreConsensusCaller(ConsensusCaller caller, PhredQuality defaultQuality) {
<span class="nc" id="L207">            super(caller);</span>
<span class="nc" id="L208">            this.defaultQuality = defaultQuality.getQualityScore();</span>
<span class="nc" id="L209">        }</span>
        
        @Override
        protected QualitySequence getQualitySequenceFor(
                DataStoreEntry&lt;NucleotideSequence&gt; read) {
<span class="nc" id="L214">            int length = getLength(read);</span>
<span class="nc" id="L215">            byte[] array = new byte[length];</span>
<span class="nc" id="L216">            Arrays.fill(array, defaultQuality);</span>
            
<span class="nc" id="L218">            return new QualitySequenceBuilder(array)</span>
<span class="nc" id="L219">                            .turnOffDataCompression(true)</span>
<span class="nc" id="L220">                            .build();</span>
        }

        @Override
        protected NucleotideSequence getSequenceFor(
                DataStoreEntry&lt;NucleotideSequence&gt; read) {
<span class="nc" id="L226">            return read.getValue();</span>
        }

        @Override
        protected int getStartOffset(DataStoreEntry&lt;NucleotideSequence&gt; read) {
            //everything starts at 0
<span class="nc" id="L232">            return 0;</span>
        }

        @Override
        protected int getLength(DataStoreEntry&lt;NucleotideSequence&gt; read) {
<span class="nc" id="L237">            return (int) read.getValue().getLength();</span>
        }

        @Override
        protected String getId(DataStoreEntry&lt;NucleotideSequence&gt; read) {
<span class="nc" id="L242">            return read.getKey();</span>
        }

        @Override
        protected Direction getDirection(DataStoreEntry&lt;NucleotideSequence&gt; read) {
            //Everything defaults to forward
<span class="nc" id="L248">            return Direction.FORWARD;</span>
        }
        
    }
    
    private static abstract class AbstractConsensusCollector&lt;T&gt; implements
    Collector&lt;T, ConsensusCombiner, NucleotideSequence&gt; {

    private final ConsensusCaller caller;
    
<span class="nc" id="L258">    public AbstractConsensusCollector(ConsensusCaller caller) {</span>
<span class="nc" id="L259">        this.caller = caller;</span>
<span class="nc" id="L260">    }</span>
    
    @Override
    public Supplier&lt;ConsensusCombiner&gt; supplier() {
<span class="nc" id="L264">        return ConsensusCombiner::new;</span>
    }
    
    @Override
    public BiConsumer&lt;ConsensusCombiner, T&gt; accumulator() {
    
<span class="nc" id="L270">        return this::addRead;</span>
    }
    
    protected abstract QualitySequence getQualitySequenceFor(T read);
    protected abstract NucleotideSequence getSequenceFor(T read);
    
    protected abstract int getStartOffset(T read);
    protected abstract int getLength(T read);
    protected abstract String getId(T read);
    protected abstract Direction getDirection(T read);
    
    protected void addRead(ConsensusCombiner combiner, T read) {
<span class="nc" id="L282">        int startOffset = getStartOffset(read);</span>
<span class="nc" id="L283">        int length = getLength(read);</span>
    
<span class="nc" id="L285">        SliceElement[] array = new SliceElement[length];</span>
<span class="nc" id="L286">        String id = getId(read);</span>
<span class="nc" id="L287">        int i = 0;</span>
    
<span class="nc" id="L289">        NucleotideSequence seq = getSequenceFor(read);</span>
<span class="nc" id="L290">        QualitySequence quals = getQualitySequenceFor(read);</span>
    
<span class="nc" id="L292">        Iterator&lt;Nucleotide&gt; nIter = seq.iterator();</span>
<span class="nc" id="L293">        Iterator&lt;PhredQuality&gt; qIter = quals.iterator();</span>
<span class="nc" id="L294">        Direction dir = getDirection(read);</span>
        
<span class="nc bnc" id="L296" title="All 2 branches missed.">        while (nIter.hasNext()) {</span>
<span class="nc" id="L297">            Nucleotide n = nIter.next();</span>
<span class="nc" id="L298">            PhredQuality q = qIter.next();</span>
<span class="nc" id="L299">            array[i++] = new CompactedSliceElement(id, n, q, dir);</span>
<span class="nc" id="L300">        }</span>
    
<span class="nc" id="L302">        combiner.add(array, startOffset);</span>
        
    
<span class="nc" id="L305">    }</span>
    
    
    @Override
    public BinaryOperator&lt;ConsensusCombiner&gt; combiner() {
<span class="nc" id="L310">        return ConsensusCombiner::merge;</span>
    }
    
    @Override
    public Function&lt;ConsensusCombiner, NucleotideSequence&gt; finisher() {
<span class="nc" id="L315">        return (combiner) -&gt; combiner.computeConsensus(caller)</span>
<span class="nc" id="L316">                .turnOffDataCompression(true).build();</span>
    }
    
    @Override
    public Set&lt;Characteristics&gt; characteristics() {
<span class="nc" id="L321">        return EnumSet.of(Characteristics.UNORDERED);</span>
    }

}
    
    private static class DefaultQualityAssemblyConsensusCollector extends AbstractAssemblyConsensusCollector{
        private final byte defaultQuality;

        private final NucleotideSequence referenceConsensus;
        
        protected DefaultQualityAssemblyConsensusCollector(
                ConsensusCaller caller, PhredQuality defaultQuality) {
<span class="nc" id="L333">            this(caller, defaultQuality, null);</span>
<span class="nc" id="L334">        }</span>
        
        protected DefaultQualityAssemblyConsensusCollector(
                ConsensusCaller caller, PhredQuality defaultQuality, NucleotideSequence reference) {
<span class="nc" id="L338">            super(caller);</span>
<span class="nc" id="L339">            this.defaultQuality = defaultQuality.getQualityScore();</span>
<span class="nc" id="L340">            this.referenceConsensus = reference;</span>
<span class="nc" id="L341">        }</span>
       

        @Override
        public Function&lt;ConsensusCombiner, NucleotideSequence&gt; finisher() {
<span class="nc" id="L346">            return (combiner) -&gt; {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">               if(referenceConsensus !=null){</span>
<span class="nc" id="L348">                   combiner.setReferenceSequence(referenceConsensus);</span>
               }
<span class="nc" id="L350">               return super.finisher().apply(combiner);</span>
            };
                   
        }
        @Override
        protected QualitySequence getQualitySequenceFor(AssembledRead read) {
<span class="nc" id="L356">            int length = (int)read.getLength();</span>
<span class="nc" id="L357">            byte[] array = new byte[length];</span>
<span class="nc" id="L358">            Arrays.fill(array, defaultQuality);</span>
<span class="nc" id="L359">            return new QualitySequenceBuilder(array)</span>
<span class="nc" id="L360">                            .turnOffDataCompression(true)</span>
<span class="nc" id="L361">                            .build();</span>
        }
        
        
        
    }
    
    private static class AssemblyDataStoreConsensusCollector
            extends AbstractAssemblyConsensusCollector{
        
        private final QualitySequenceDataStore qualities;
        private NucleotideSequence referenceConsensus;
        
        public AssemblyDataStoreConsensusCollector(ConsensusCaller caller, QualitySequenceDataStore qualities){
<span class="nc" id="L375">            this(caller, qualities, null);</span>
<span class="nc" id="L376">        }</span>
        public AssemblyDataStoreConsensusCollector(ConsensusCaller caller, QualitySequenceDataStore qualities, NucleotideSequence referenceConsensus) {
<span class="nc" id="L378">           super(caller);</span>
<span class="nc" id="L379">            this.qualities = qualities;</span>
<span class="nc" id="L380">            this.referenceConsensus = referenceConsensus;</span>
<span class="nc" id="L381">        }</span>

        
        @Override
        public Function&lt;ConsensusCombiner, NucleotideSequence&gt; finisher() {
<span class="nc" id="L386">            return (combiner) -&gt; {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">               if(referenceConsensus !=null){</span>
<span class="nc" id="L388">                   combiner.setReferenceSequence(referenceConsensus);</span>
               }
<span class="nc" id="L390">               return super.finisher().apply(combiner);</span>
            };
                   
        }
        @Override
        protected QualitySequence getQualitySequenceFor(AssembledRead read) {
<span class="nc" id="L396">            String id = read.getId();</span>
            try{
<span class="nc" id="L398">                return toGappedQualitySequence(read, qualities.get(id));</span>
<span class="nc" id="L399">            } catch (DataStoreException e) {</span>
<span class="nc" id="L400">                throw new IllegalStateException(&quot;error getting quality values for read &quot; + id);</span>
             }
        }

       
        
        protected QualitySequence toGappedQualitySequence(AssembledRead read, QualitySequence quals){
          //we will assume already gapped?
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if(read.getLength() != quals.getLength()){</span>
<span class="nc" id="L409">                throw new IllegalStateException(&quot;quality sequence length does not match gapped nucleotide sequence length &quot; + read.getId());</span>
            }
<span class="nc" id="L411">            return quals;</span>
        }

      

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>