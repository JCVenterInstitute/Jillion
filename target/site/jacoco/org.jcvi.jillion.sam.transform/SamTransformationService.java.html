<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SamTransformationService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam.transform</a> &gt; <span class="el_source">SamTransformationService.java</span></div><h1>SamTransformationService.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam.transform;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.jcvi.jillion.assembly.AssemblyTransformationService;
import org.jcvi.jillion.assembly.AssemblyTransformer;
import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.assembly.ReadInfo;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceDataStore;
import org.jcvi.jillion.core.util.MapUtil;
import org.jcvi.jillion.fasta.nt.NucleotideFastaDataStore;
import org.jcvi.jillion.fasta.nt.NucleotideFastaFileDataStoreBuilder;
import org.jcvi.jillion.internal.core.util.GrowableIntArray;
import org.jcvi.jillion.sam.SamParser;
import org.jcvi.jillion.sam.SamParserFactory;
import org.jcvi.jillion.sam.SamRecord;
import org.jcvi.jillion.sam.SamRecordFlag;
import org.jcvi.jillion.sam.SamRecordFlags;
import org.jcvi.jillion.sam.SamVisitor;
import org.jcvi.jillion.sam.VirtualFileOffset;
import org.jcvi.jillion.sam.cigar.Cigar;
import org.jcvi.jillion.sam.cigar.Cigar.ClipType;
import org.jcvi.jillion.sam.cigar.CigarElement;
import org.jcvi.jillion.sam.cigar.CigarOperation;
import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamReferenceSequence;
/**
 * {@code SamTransformationService}
 * is a class that can parse a SAM file
 * and call the appropriate methods
 * on a given {@link AssemblyTransformer}
 * so the transformer can get assembly and alignment 
 * information from the SAM file without knowing
 * anything about how SAM files are formatted.
 * 
 * @author dkatzel
 *
 */
public final class SamTransformationService implements AssemblyTransformationService{

	
	private final NucleotideSequenceDataStore referenceDataStore;
	private final SamParser parser;
	
	/**
	 * Create a new {@link SamTransformationService} using
	 * the given SAM encoded file and a fasta file of the ungapped
	 * references sequences referred to in the SAM.  The ids in the fasta file
	 * must match the reference sequence names in the SAM file (@SQ SN:$ID) in the SAM header.
	 * @param samFile the SAM file to parse and transform; can not be null
	 * and must exist.
	 * @param referenceFasta the reference fasta file; can not be null and must exist.
	 * @throws IOException if there is a problem parsing the input files.
	 * @throws NullPointerException if either parameter is null.
	 */
<span class="fc" id="L88">	public SamTransformationService(File samFile, File referenceFasta) throws IOException {</span>
		
<span class="fc" id="L90">		parser = SamParserFactory.create(samFile);</span>
<span class="fc" id="L91">		NucleotideFastaDataStore ungappedReferenceDataStore = new NucleotideFastaFileDataStoreBuilder(referenceFasta)</span>
<span class="fc" id="L92">																	.build();</span>
		
<span class="fc" id="L94">		referenceDataStore = SamGappedReferenceBuilderVisitor.createGappedReferencesFrom(parser, ungappedReferenceDataStore);</span>
<span class="fc" id="L95">	}</span>
	/**
	 * Parse the SAM file and call the appropriate methods on the given
	 * {@link AssemblyTransformer}.
	 * @param transformer the {@link AssemblyTransformer} instance to call
	 * the methods on; can not be null.
	 * @throws NullPointerException if transformer is null.
	 */
	@Override
	public void transform(final AssemblyTransformer transformer){
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">		if(transformer ==null){</span>
<span class="nc" id="L106">			throw new NullPointerException(&quot;transformer can not be null&quot;);</span>
		}
		try {
<span class="fc" id="L109">			SamTransformerVisitor visitor = new SamTransformerVisitor(referenceDataStore, transformer);</span>
<span class="fc" id="L110">			parser.parse(visitor);</span>
<span class="nc" id="L111">		} catch (Exception e) {</span>
<span class="nc" id="L112">			throw new IllegalStateException(&quot;error parsing sam file&quot;, e);</span>
<span class="fc" id="L113">		}</span>
<span class="fc" id="L114">	}</span>
	
	
	private static final class SamTransformerVisitor implements SamVisitor{

		private final AssemblyTransformer transformer;
		private final NucleotideSequenceDataStore referenceDataStore;
		private final Map&lt;String,GrowableIntArray&gt; gapOffsetMap;
		
<span class="fc" id="L123">		public SamTransformerVisitor(NucleotideSequenceDataStore referenceDataStore, AssemblyTransformer transformer) throws DataStoreException {</span>
<span class="fc" id="L124">			this.referenceDataStore = referenceDataStore;</span>
<span class="fc" id="L125">			this.transformer = transformer;</span>
<span class="fc" id="L126">			gapOffsetMap = new HashMap&lt;String, GrowableIntArray&gt;(MapUtil.computeMinHashMapSizeWithoutRehashing(referenceDataStore.getNumberOfRecords()));</span>
			
<span class="fc" id="L128">		}</span>

		@Override
		public void visitHeader(SamVisitorCallback callback, SamHeader header) {
			
<span class="fc bfc" id="L133" title="All 2 branches covered.">			for(SamReferenceSequence refSeq : header.getReferenceSequences()){</span>
<span class="fc" id="L134">				String id = refSeq.getName();</span>
				try {
<span class="fc" id="L136">					NucleotideSequence ref = referenceDataStore.get(id);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">					if(ref ==null){</span>
<span class="nc" id="L138">						throw new IllegalStateException(&quot;error could not find reference sequence in fasta file with id &quot; + id);</span>
					}
<span class="fc" id="L140">					gapOffsetMap.put(id,  new GrowableIntArray(ref.getGapOffsets()));</span>
					
<span class="fc" id="L142">					transformer.referenceOrConsensus(id, ref);</span>
<span class="nc" id="L143">				} catch (DataStoreException e) {</span>
<span class="nc" id="L144">					throw new IllegalStateException(&quot;error getting reference sequence from fasta file&quot;, e);</span>
<span class="fc" id="L145">				}</span>
				
<span class="fc" id="L147">			}</span>
<span class="fc" id="L148">		}</span>
	

		@Override
		public void visitRecord(SamVisitorCallback callback, SamRecord record, VirtualFileOffset start,
				VirtualFileOffset end) {
<span class="fc bfc" id="L154" title="All 2 branches covered.">			if(record.isPrimary()){</span>
				
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">				if(record.mapped()){</span>
<span class="fc" id="L157">					String refName = record.getReferenceName();</span>
					try {
<span class="fc" id="L159">						NucleotideSequence referenceSeq = referenceDataStore.get(refName);</span>
					
<span class="fc" id="L161">					Direction dir = record.getDirection();</span>
<span class="fc" id="L162">					Cigar cigar = record.getCigar();</span>
<span class="fc" id="L163">					int rawLength = cigar.getUnpaddedReadLength(ClipType.RAW);</span>
					Range validRange;
<span class="fc" id="L165">					int gappedStartOffset = referenceSeq.getGappedOffsetFor(record.getStartPosition()-1);</span>
					
					
					//extra insertions have been added to the reference
					//from other reads that we don't know about
					//modify the cigar accordingly
					NucleotideSequence rawSequence;
					QualitySequence quals;
<span class="fc bfc" id="L173" title="All 2 branches covered.">					if(dir == Direction.FORWARD){</span>
<span class="fc" id="L174">						rawSequence = record.getSequence();</span>
<span class="fc" id="L175">						quals = record.getQualities();</span>
<span class="fc" id="L176">						validRange = cigar.getValidRange();</span>
					}else{
<span class="fc" id="L178">						rawSequence = new NucleotideSequenceBuilder(record.getSequence())</span>
<span class="fc" id="L179">											.reverseComplement()</span>
<span class="fc" id="L180">											.build();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">						if(record.getQualities() ==null){</span>
<span class="fc" id="L182">							quals = null;</span>
						}else{
<span class="nc" id="L184">							quals = new QualitySequenceBuilder(record.getQualities())</span>
<span class="nc" id="L185">											.reverse()</span>
<span class="nc" id="L186">											.build();</span>
						}
<span class="fc" id="L188">						validRange = AssemblyUtil.reverseComplementValidRange(cigar.getValidRange(), rawLength);</span>
					}
					
<span class="fc" id="L191">					NucleotideSequence gappedReadSequence =toGappedTrimmedSequenceBuilder(cigar, rawSequence, gapOffsetMap.get(refName), gappedStartOffset, dir)</span>
<span class="fc" id="L192">															.build();</span>
					
				
					//if the read is mated SAM doesn't put the /1 or /2 ?
					//what happens in CASAVA 1.8 reads?
<span class="fc" id="L197">					String readName = record.getQueryName();</span>
<span class="fc" id="L198">					SamRecordFlags flags = record.getFlags();</span>
					//from the SAMv1 spec
					//The leftmost segment has a plus sign and the rightmost has a
					//minus sign. The sign of segments in the middle is undefined. 
					//It is set as 0 for single-segment
					//template or when the information is unavailable.
<span class="fc bfc" id="L204" title="All 2 branches covered.">					if(flags.contains(SamRecordFlag.HAS_MATE_PAIR)){</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">						if(record.getObservedTemplateLength() &gt;=0){</span>
							//first read
<span class="fc" id="L207">							readName +=&quot;/1&quot;;</span>
						}else{
<span class="fc" id="L209">							readName +=&quot;/2&quot;;</span>
						}
						
					}
					//update valid range?
<span class="fc" id="L214">					transformer.aligned(readName, rawSequence, quals, null, null, </span>
							refName, 
							gappedStartOffset, 
							dir, 
							gappedReadSequence, 
							
							new ReadInfo(validRange, rawLength));
<span class="nc" id="L221">					} catch (DataStoreException e) {</span>
<span class="nc" id="L222">						throw new IllegalStateException(&quot;unknown reference &quot; + refName, e);</span>
<span class="fc" id="L223">					}</span>
<span class="fc" id="L224">				}else{</span>
<span class="nc" id="L225">					transformer.notAligned(record.getQueryName(), record.getSequence(), record.getQualities(), null, null);</span>
					
				}
			}
				
<span class="fc" id="L230">		}</span>

		@Override
		public void visitEnd() {
<span class="fc" id="L234">			transformer.endAssembly();			</span>
<span class="fc" id="L235">		}</span>
		
		@Override
		public void halted() {
<span class="nc" id="L239">			transformer.endAssembly();		</span>
<span class="nc" id="L240">		}</span>

	private NucleotideSequenceBuilder toGappedTrimmedSequenceBuilder(Cigar cigar, NucleotideSequence rawUngappedSequence, GrowableIntArray refGaps, int gappedStartOffset, Direction dir) {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">		if(rawUngappedSequence.getNumberOfGaps() !=0){</span>
<span class="nc" id="L244">			throw new IllegalArgumentException(&quot;rawUngapped Sequence can not have gaps&quot;);</span>
		}
		
<span class="fc" id="L247">		NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder((int)rawUngappedSequence.getLength());</span>
<span class="fc" id="L248">		int referenceOffset = gappedStartOffset;</span>
		
		Iterator&lt;Nucleotide&gt; ungappedBasesIter;
<span class="fc bfc" id="L251" title="All 2 branches covered.">		if(dir == Direction.FORWARD){</span>
<span class="fc" id="L252">			ungappedBasesIter= rawUngappedSequence.iterator();</span>
		}else{
<span class="fc" id="L254">			ungappedBasesIter= new NucleotideSequenceBuilder(rawUngappedSequence)</span>
<span class="fc" id="L255">									.reverseComplement()</span>
<span class="fc" id="L256">									.iterator();</span>
		}
<span class="fc bfc" id="L258" title="All 2 branches covered.">		for(CigarElement e : cigar){</span>
<span class="pc bpc" id="L259" title="1 of 4 branches missed.">			if(e.getOp() == CigarOperation.HARD_CLIP ||e.getOp() == CigarOperation.SOFT_CLIP ){</span>
				//skip over clipped bases
<span class="fc bfc" id="L261" title="All 2 branches covered.">				for(int i=0; i&lt;e.getLength(); i++){</span>
<span class="fc" id="L262">					ungappedBasesIter.next();</span>
				}
<span class="fc" id="L264">				continue;</span>
			}
<span class="fc" id="L266">			referenceOffset = appendBases(builder, ungappedBasesIter, refGaps, referenceOffset, e);</span>
			
<span class="fc" id="L268">		}</span>
		
<span class="fc" id="L270">		return builder;</span>
	}
	
	private int appendBases(NucleotideSequenceBuilder builder, Iterator&lt;Nucleotide&gt; ungappedReadBaseIterator, GrowableIntArray refGaps, int refOffset, CigarElement e){
		
<span class="fc" id="L275">		int ret = refOffset;</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">		for(int i=0; i&lt;e.getLength(); i++){</span>
			
<span class="fc bfc" id="L278" title="All 2 branches covered.">			if(e.getOp() != CigarOperation.INSERTION){</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">				while(refGaps.binarySearch(ret) &gt;=0){</span>
					//insert gap
<span class="fc" id="L281">					builder.append(Nucleotide.Gap);</span>
<span class="fc" id="L282">					ret++;</span>
				}
			}
<span class="fc bfc" id="L285" title="All 2 branches covered.">			if(e.getOp() == CigarOperation.PADDING){</span>
				//remove this many gaps
<span class="fc" id="L287">				builder.delete(new Range.Builder(1)</span>
<span class="fc" id="L288">										.shift(builder.getLength()-1)</span>
<span class="fc" id="L289">										.build());</span>
			}
<span class="fc bfc" id="L291" title="All 4 branches covered.">			else if(e.getOp() ==CigarOperation.DELETION ||e.getOp() == CigarOperation.SKIPPED){</span>
				//insert gap
<span class="fc" id="L293">				builder.append(Nucleotide.Gap);</span>
				
			}else{
<span class="fc" id="L296">				builder.append(ungappedReadBaseIterator.next());			</span>
				
			}
<span class="fc" id="L299">			ret++;</span>
		}
<span class="fc" id="L301">		return ret;</span>
	}
	
}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>