<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AlnFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.experimental.align</a> &gt; <span class="el_source">AlnFileParser.java</span></div><h1>AlnFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.experimental.align;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.experimental.align.AlnGroupVisitor.ConservationInfo;
import org.jcvi.jillion.experimental.align.AlnVisitor.AlnVisitorCallback;
import org.jcvi.jillion.experimental.align.AlnVisitor.AlnVisitorCallback.AlnVisitorMemento;
import org.jcvi.jillion.internal.core.io.LineParser;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
import org.jcvi.jillion.internal.core.io.TextLineParser;

/**
 * {@code AlnFileParser} is a utility class that can 
 * parse .aln alignment files like those
 * created by clustal.
 * 
 * @author dkatzel
 *
 *
 */
public abstract class AlnFileParser implements AlnParser{

	
    /**
     * Regular expression of string that contains
     * valid nucleotide or amino acids.
     */
	//MAFFT uses lowercase bases in aln output
    private static final String REGEX = &quot;^([^*\\s]+)\\s+([\\-ACGTNVHDBWMRSYKILFQPEXacgtnvhdbwmrsykilfqpex]+)(\\s+\\d+)?$&quot;;
<span class="fc" id="L65">    private static final Pattern ALIGNMENT_PATTERN = Pattern.compile(REGEX);</span>
<span class="fc" id="L66">    private static final Pattern CONSERVATION_PATTERN = Pattern.compile(&quot;\\s+([-:\\. \\*]+)$&quot;);</span>
    
    
    public static AlnParser create(File alnFile) throws IOException{
<span class="fc" id="L70">    	return new FileBasedAlnParser(alnFile);</span>
    }
    public static AlnParser create(InputStream alnStream) throws IOException{
<span class="fc" id="L73">    	return new InputStreamBasedAlnParser(alnStream);</span>
    }
    
<span class="fc" id="L76">    private AlnFileParser(){</span>
		//private constructor.
<span class="fc" id="L78">	}</span>
    
    
    /**
     * @param conservationString
     * @param numberOfBasesPerGroup
     * @return
     */
    private static List&lt;ConservationInfo&gt; parseConservationInfo(
            String conservationString, int numberOfBasesPerGroup) {
<span class="fc" id="L88">        final String paddedString = createPaddedConservationString(conservationString, numberOfBasesPerGroup);</span>
<span class="fc" id="L89">        List&lt;ConservationInfo&gt; result = new ArrayList&lt;ConservationInfo&gt;(numberOfBasesPerGroup);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        for(int i=0; i&lt; paddedString.length(); i++){</span>
<span class="fc" id="L91">        	result.add(ConservationInfo.parse(paddedString.charAt(i)));            </span>
        }
<span class="fc" id="L93">        return result;</span>
    }
    
    void parse(AlnVisitor visitor, InputStream in) throws IOException{
<span class="fc" id="L97">    	parse(visitor, in, true);</span>
<span class="fc" id="L98">    }</span>
    void parse(AlnVisitor visitor, InputStream in, boolean validateHeader) throws IOException{
<span class="fc" id="L100">		TextLineParser parser = new TextLineParser(in);</span>
<span class="fc" id="L101">		AtomicBoolean keepParsing=new AtomicBoolean(true);</span>
<span class="fc" id="L102">		boolean eofReached=false;</span>
		try{
			
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">			if(!parser.hasNextLine()){</span>
				//header required
<span class="nc" id="L107">				throw new IOException(&quot;no aln data&quot;);</span>
			}
<span class="fc bfc" id="L109" title="All 2 branches covered.">			if(validateHeader){</span>
<span class="fc" id="L110">				String header = parser.nextLine();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">				if(!AlnUtil.validHeader(header)){</span>
<span class="fc" id="L112">					throw new IOException(&quot;invalid aln header : &quot; + header);</span>
				}
<span class="fc" id="L114">				visitor.visitHeader(header);</span>
			}
			
			//then one or more empty lines
<span class="fc bfc" id="L118" title="All 4 branches covered.">			 while(keepParsing.get() &amp;&amp; parser.hasNextLine()){</span>
<span class="fc" id="L119">				 AlnVisitorCallback callback = createCallBack(parser, keepParsing);</span>
<span class="fc" id="L120">				 	Group group = Group.getNextGroup(parser);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">				 	if(group !=null){				 		</span>
<span class="fc" id="L122">				 		group.accept(visitor,callback, keepParsing);				 		</span>
				 	}
<span class="fc" id="L124">			 }</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">			 eofReached=!parser.hasNextLine();</span>
		}finally{
<span class="pc bpc" id="L127" title="3 of 8 branches missed.">			if(eofReached &amp;&amp; keepParsing.get()){</span>
<span class="pc" id="L128">				 visitor.visitEnd();</span>
			 }else{
<span class="fc" id="L130">				 visitor.halted();</span>
			 }
<span class="fc" id="L132">			IOUtil.closeAndIgnoreErrors(parser);</span>
<span class="fc" id="L133">		}</span>
<span class="fc" id="L134">	}</span>
   
	abstract AlnVisitorCallback createCallBack(TextLineParser parser, AtomicBoolean keepParsing);
    
    
	/**
     * Aln format uses spaces to denote not conserved regions,
     * this is hard to parse out using regular expressions if 
     * the conservation string is supposed to START with spaces.
     * By using the expected number of basecalls in this group,
     * we can create a padded string with the correct number of leading
     * spaces.
     * @param conservationString
     * @param numberOfBasesPerGroup
     * @return
     */
    private static String createPaddedConservationString(
            String conservationString, int numberOfBasesPerGroup) {
<span class="fc" id="L152">        int length = conservationString.length();</span>
<span class="fc" id="L153">        int padding = numberOfBasesPerGroup-length;</span>
        
        final String paddedString;
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if(padding&gt;0){</span>
<span class="fc" id="L157">            String format = &quot;%&quot;+padding+&quot;s%s&quot;;</span>
<span class="fc" id="L158">            paddedString= String.format(format, &quot;&quot;,conservationString);</span>
<span class="fc" id="L159">        }else{</span>
<span class="fc" id="L160">            paddedString = conservationString;</span>
        }
<span class="fc" id="L162">        return paddedString;</span>
    }
    
    private static final class Group{
    	private final Map&lt;String,String&gt; lines;
    	private final List&lt;ConservationInfo&gt; info;
    	
<span class="fc" id="L169">    	public Group(Map&lt;String, String&gt; lines, List&lt;ConservationInfo&gt; info) {</span>
<span class="fc" id="L170">			this.lines = lines;</span>
<span class="fc" id="L171">			this.info = info;</span>
<span class="fc" id="L172">		}</span>



		public void accept(AlnVisitor visitor, AlnVisitorCallback callback, AtomicBoolean keepParsing) {
<span class="fc" id="L177">			AlnGroupVisitor groupVisitor = visitor.visitGroup(lines.keySet(), callback);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">			if(groupVisitor !=null){</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">				for(Entry&lt;String,String&gt; entry : lines.entrySet()){</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">					if(keepParsing.get()){</span>
<span class="fc" id="L181">						groupVisitor.visitAlignedSegment(entry.getKey(), entry.getValue());</span>
					}
<span class="fc" id="L183">				}</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">				if(keepParsing.get()){</span>
<span class="fc" id="L185">					groupVisitor.visitConservationInfo(info);</span>
				}
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">				if(keepParsing.get()){</span>
<span class="fc" id="L188">					groupVisitor.visitEndGroup();</span>
				}
			}
<span class="fc" id="L191">		}</span>



		static Group getNextGroup(LineParser parser) throws IOException{
<span class="fc" id="L196">    		Map&lt;String,String&gt; lines = new LinkedHashMap&lt;String, String&gt;();</span>
<span class="fc" id="L197">    		boolean done=false;</span>
<span class="fc" id="L198">    		boolean foundGroup=false;</span>
<span class="fc" id="L199">    		List&lt;ConservationInfo&gt; info = null;</span>
<span class="fc" id="L200">    		int numberOfBasesPerGroup=0;</span>
    		
<span class="fc bfc" id="L202" title="All 4 branches covered.">    		while(parser.hasNextLine() &amp;&amp; !done){</span>
<span class="fc" id="L203">    			String untrimmedLine = parser.nextLine();</span>
<span class="fc" id="L204">    			String trimmedLine = untrimmedLine.trim();</span>
<span class="fc bfc" id="L205" title="All 4 branches covered.">    			if(foundGroup &amp;&amp; trimmedLine.isEmpty()){</span>
    				//we found the end of the group
<span class="fc" id="L207">    				done=true;</span>
    			}
<span class="fc" id="L209">	            Matcher alignmentMatcher =  ALIGNMENT_PATTERN.matcher(trimmedLine);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">	            if(alignmentMatcher.matches()){</span>
<span class="fc" id="L211">	            	foundGroup=true;</span>
<span class="fc" id="L212">	            	numberOfBasesPerGroup = alignmentMatcher.group(2).length();</span>
<span class="fc" id="L213">	            	lines.put(alignmentMatcher.group(1), alignmentMatcher.group(2));</span>
	            }else{
	            	//need to use untrimmed line because there could be leading or trailing
	            	//spaces which mean &quot;no match&quot;, we don't want to lose those.
<span class="fc" id="L217">	            	Matcher conservationMatcher = CONSERVATION_PATTERN.matcher(untrimmedLine);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">	                if(conservationMatcher.find()){</span>
<span class="fc" id="L219">	                    String conservationString = conservationMatcher.group(1);</span>
<span class="fc" id="L220">	                    info = parseConservationInfo(conservationString,numberOfBasesPerGroup);</span>
<span class="fc" id="L221">	                    done=true;</span>
	                }
	            }
<span class="fc" id="L224">    		}</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">    		if(lines.isEmpty()){</span>
    			//didn't find anything
<span class="fc" id="L227">    			return null;</span>
    		}
<span class="fc bfc" id="L229" title="All 2 branches covered.">    		if(info ==null){</span>
    			//no conservation line means not conserved?
    			
<span class="fc" id="L232">    			info = new ArrayList&lt;AlnGroupVisitor.ConservationInfo&gt;(numberOfBasesPerGroup);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    			for(int i=0; i&lt;info.size(); i++){</span>
<span class="nc" id="L234">    				info.add(ConservationInfo.NOT_CONSERVED);</span>
    			}
    		}
<span class="fc" id="L237">    		return new Group(lines,info);</span>
    	}
    }
    
    
    private static final class InputStreamBasedAlnParser extends AlnFileParser{
    	private final OpenAwareInputStream in;
    	
<span class="fc" id="L245">    	public InputStreamBasedAlnParser(InputStream in){</span>
<span class="fc" id="L246">    		this.in = new OpenAwareInputStream(in);</span>
<span class="fc" id="L247">    	}</span>
		@Override
		public boolean canParse() {
<span class="fc" id="L250">			return in.isOpen();</span>
		}

		@Override
		public void parse(AlnVisitor visitor) throws IOException {
			try{
<span class="fc" id="L256">				parse(visitor,in);</span>
			}finally{
<span class="fc" id="L258">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L259">			}</span>
			
<span class="fc" id="L261">		}</span>

		@Override
		public void parse(AlnVisitor visitor, AlnVisitorMemento memento)
				throws IOException {
<span class="nc" id="L266">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
			
		}

		@Override
		protected AlnVisitorCallback createCallBack(TextLineParser parser,
				AtomicBoolean keepParsing) {
<span class="fc" id="L273">			return new NoMementoCallback(keepParsing);</span>
		}
    	
    }
    
    private static final class NoMementoCallback implements AlnVisitorCallback{
    	private final AtomicBoolean keepParsing;
    	
    	
<span class="fc" id="L282">		public NoMementoCallback(AtomicBoolean keepParsing) {</span>
<span class="fc" id="L283">			this.keepParsing = keepParsing;</span>
<span class="fc" id="L284">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="fc" id="L288">			return false;</span>
		}

		@Override
		public AlnVisitorMemento createMemento() {
<span class="fc" id="L293">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
		}

		@Override
		public void haltParsing() {
<span class="fc" id="L298">			keepParsing.set(false);</span>
			
<span class="fc" id="L300">		}</span>
    	
    }
    
    private static final class FileBasedAlnParser extends AlnFileParser{

    	private final File alnFile;
    	
<span class="fc" id="L308">		public FileBasedAlnParser(File alnFile) throws IOException {</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">			if(!alnFile.exists()){</span>
<span class="nc" id="L310">				throw new FileNotFoundException(alnFile.getAbsolutePath());</span>
			}
<span class="fc" id="L312">			this.alnFile = alnFile;</span>
<span class="fc" id="L313">		}</span>

		@Override
		public boolean canParse() {
<span class="fc" id="L317">			return true;</span>
		}

		@Override
		protected AlnVisitorCallback createCallBack(TextLineParser parser,
				AtomicBoolean keepParsing) {
<span class="fc" id="L323">			return new AlnFileVisitorCallback(parser.getPosition(), keepParsing);</span>
		}

		@Override
		public void parse(AlnVisitor visitor) throws IOException {
<span class="fc" id="L328">			InputStream in =null;</span>
			try{
<span class="fc" id="L330">				in = new BufferedInputStream(new FileInputStream(alnFile));</span>
<span class="fc" id="L331">				parse(visitor,in);</span>
			}finally{
<span class="fc" id="L333">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L334">			}</span>
			
<span class="fc" id="L336">		}</span>
		
		

		@Override
		public void parse(AlnVisitor visitor, AlnVisitorMemento memento)
				throws IOException {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">			if(!(memento instanceof AlnFileMemento)){</span>
<span class="nc" id="L344">				throw new IllegalStateException(&quot;unknown memento type&quot; + memento);</span>
			}
<span class="fc" id="L346">			AlnFileMemento alnFileMemento = (AlnFileMemento)memento;</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">			if(alnFileMemento.getOuterType()!=this){</span>
<span class="nc" id="L348">				throw new IllegalStateException(&quot;invalid memento: was not created by this parser&quot;);</span>
			}
			
			
<span class="fc" id="L352">			InputStream in =null;</span>
			try{
<span class="fc" id="L354">				in = new BufferedInputStream(new RandomAccessFileInputStream(alnFile, alnFileMemento.offset));</span>
<span class="fc" id="L355">				parse(visitor,in, false);</span>
			}finally{
<span class="pc" id="L357">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L358">			}</span>
			
<span class="fc" id="L360">		}</span>
    	
		private class AlnFileVisitorCallback implements AlnVisitorCallback{
			private final AtomicBoolean keepParsing;
			private final long offset;
			
<span class="fc" id="L366">			public AlnFileVisitorCallback(long offset, AtomicBoolean keepParsing) {</span>
<span class="fc" id="L367">				this.keepParsing = keepParsing;</span>
<span class="fc" id="L368">				this.offset = offset;</span>
<span class="fc" id="L369">			}</span>

			@Override
			public boolean canCreateMemento() {
<span class="nc" id="L373">				return true;</span>
			}

			@Override
			public AlnVisitorMemento createMemento() {
<span class="fc" id="L378">				return new AlnFileMemento(offset);</span>
			}

			@Override
			public void haltParsing() {
<span class="fc" id="L383">				keepParsing.set(false);</span>
				
<span class="fc" id="L385">			}</span>
			
		}
		private class AlnFileMemento implements AlnVisitorMemento{
			private long offset;

<span class="fc" id="L391">			public AlnFileMemento(long offset) {</span>
<span class="fc" id="L392">				this.offset = offset;</span>
<span class="fc" id="L393">			}</span>

			@Override
			public int hashCode() {
<span class="nc" id="L397">				final int prime = 31;</span>
<span class="nc" id="L398">				int result = 1;</span>
<span class="nc" id="L399">				result = prime * result + getOuterType().hashCode();</span>
<span class="nc" id="L400">				result = prime * result + (int) (offset ^ (offset &gt;&gt;&gt; 32));</span>
<span class="nc" id="L401">				return result;</span>
			}

			@Override
			public boolean equals(Object obj) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">				if (this == obj) {</span>
<span class="nc" id="L407">					return true;</span>
				}
<span class="nc bnc" id="L409" title="All 2 branches missed.">				if (obj == null) {</span>
<span class="nc" id="L410">					return false;</span>
				}
<span class="nc bnc" id="L412" title="All 2 branches missed.">				if (!(obj instanceof AlnFileMemento)) {</span>
<span class="nc" id="L413">					return false;</span>
				}
<span class="nc" id="L415">				AlnFileMemento other = (AlnFileMemento) obj;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">				if (!getOuterType().equals(other.getOuterType())) {</span>
<span class="nc" id="L417">					return false;</span>
				}
<span class="nc bnc" id="L419" title="All 2 branches missed.">				if (offset != other.offset) {</span>
<span class="nc" id="L420">					return false;</span>
				}
<span class="nc" id="L422">				return true;</span>
			}

			private FileBasedAlnParser getOuterType() {
<span class="fc" id="L426">				return FileBasedAlnParser.this;</span>
			}
			
		}
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>