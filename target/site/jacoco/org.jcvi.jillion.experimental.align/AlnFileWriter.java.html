<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AlnFileWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.experimental.align</a> &gt; <span class="el_source">AlnFileWriter.java</span></div><h1>AlnFileWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.experimental.align;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.Builder;
import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.Residue;
import org.jcvi.jillion.core.residue.aa.AminoAcid;
import org.jcvi.jillion.core.residue.aa.ProteinSequence;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.experimental.align.AlnGroupVisitor.ConservationInfo;
/**
 * {@code AlnFileWriter} can write aln encoded
 * alignment files like those produced by Clustal.
 * @author dkatzel
 *
 * @param &lt;R&gt; the type of {@link Residue} to be written.
 * @param &lt;S&gt; type of {@link Sequence} to be written.
 */
public abstract class AlnFileWriter&lt;R extends Residue, S extends Sequence&lt;R&gt;&gt; implements AlnWriter&lt;R,S&gt;{
	private static final String DEFAULT_CLUSTAL_HEADER = &quot;CLUSTAL W&quot;;
	private static final int DEFAULT_RESIDUES_PER_GROUP = 60;
	private static final int USE_ONE_GROUP = -1;
	
	private final PrintWriter out;
	private final int residuesPerGroup;
<span class="fc" id="L60">	private final Map&lt;String,S&gt; sequences = new LinkedHashMap&lt;String, S&gt;();</span>
<span class="fc" id="L61">	private long seqLength=0;</span>
	private final String eol;
	private long cumulativeLength;
	
	private final boolean includeCumulativeCounts;
	/**
	 * Flag that sets if data
	 * has been written yet.
	 * this is used to check
	 * if we can write a header or not
	 * (since header must come first).
	 */
<span class="fc" id="L73">	private boolean headerWritten=false;</span>
	
	/**
	 * Create a new {@link AlnFileWriterBuilder}
	 * that will build a {@link AlnFileWriter}
	 * to write out
	 * {@link NucleotideSequence} alignments in aln format to the given output file.
	 * @param outputFile the output file to write to; can not be null.
	 * If this file already exists, then the writer will overwrite
	 * the old data.  If this file does not exist, then it will be
	 * created.
	 * @return a new {@link AlnFileWriterBuilder} instance; will never be null.
	 */
	public static AlnFileWriterBuilder&lt;Nucleotide, NucleotideSequence&gt; createNucleotideWriterBuilder(File outputFile){
<span class="fc" id="L87">		return new NucleotideAlnFileWriterBuilder(outputFile);</span>
	}
	/**
	 * Create a new {@link AlnFileWriterBuilder}
	 * that will build a {@link AlnFileWriter}
	 * to write out
	 * {@link ProteinSequence} alignments in aln format to the given output file.
	 * @param outputFile the output file to write to; can not be null.
	 * If this file already exists, then the writer will overwrite
	 * the old data.  If this file does not exist, then it will be
	 * created.
	 * @return a new {@link AlnFileWriterBuilder} instance; will never be null.
	 */
	public static AlnFileWriterBuilder&lt;AminoAcid, ProteinSequence&gt; createAminoAcidWriterBuilder(File outputFile){
<span class="nc" id="L101">		return new AminoAcidAlnFileWriterBuilder(outputFile);</span>
	}
	
	
	
<span class="fc" id="L106">	private AlnFileWriter(File outputFile, int residuesPerGroup, String eol, boolean includeCounts) throws IOException {</span>
<span class="fc" id="L107">		IOUtil.mkdirs(outputFile.getParentFile());</span>
		
<span class="fc" id="L109">		this.out = new PrintWriter(IOUtil.createNewBufferedWriter(outputFile, IOUtil.UTF_8_NAME));</span>
<span class="fc" id="L110">		this.residuesPerGroup = residuesPerGroup;</span>
<span class="fc" id="L111">		this.eol = eol;</span>
<span class="fc" id="L112">		this.includeCumulativeCounts = includeCounts;</span>
<span class="fc" id="L113">	}</span>

	@Override
	public void close() throws IOException {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">		if(!headerWritten){</span>
<span class="fc" id="L118">			writeHeader(DEFAULT_CLUSTAL_HEADER);</span>
		}
<span class="fc bfc" id="L120" title="All 2 branches covered.">		if(!sequences.isEmpty()){</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if(residuesPerGroup == USE_ONE_GROUP){</span>
<span class="fc" id="L122">				handleGroup(Range.ofLength(seqLength));</span>
			}else{
<span class="fc bfc" id="L124" title="All 2 branches covered.">				for(long i=0; i&lt;seqLength; i+=residuesPerGroup){</span>
<span class="fc" id="L125">					Builder builder = new Range.Builder(residuesPerGroup)</span>
<span class="fc" id="L126">											.shift(i);</span>
					//iterator(Range) doesn't like
					//ranges out of bounds
					//so trim the range down
<span class="fc" id="L130">					long newEnd = Math.min(seqLength-1,builder.getEnd());</span>
<span class="fc" id="L131">					Range r = builder.setEnd(newEnd).build();</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">					if(!r.isEmpty()){</span>
<span class="fc" id="L133">						handleGroup(r);</span>
					}
					
				}
				
				
			}
		}
<span class="fc" id="L141">		out.close();</span>
		
<span class="fc" id="L143">	}</span>
	private void handleGroup(Range r){
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">		if(sequences.isEmpty()){</span>
			//no-op 
<span class="nc" id="L147">			return;</span>
		}
<span class="fc" id="L149">		int rangeLength = (int)r.getLength();</span>
<span class="fc" id="L150">		List&lt;Iterator&lt;R&gt;&gt; iterators = new ArrayList&lt;Iterator&lt;R&gt;&gt;(sequences.size());</span>
<span class="fc" id="L151">		List&lt;StringBuilder&gt; builders = new ArrayList&lt;StringBuilder&gt;(sequences.size());</span>
<span class="fc" id="L152">		int maxIdLength=0;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">		for(String id : sequences.keySet()){</span>
<span class="fc" id="L154">			int length = id.length();</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">			if(length &gt; maxIdLength){</span>
<span class="fc" id="L156">				maxIdLength = length;</span>
			}
<span class="fc" id="L158">		}</span>
		final String lineCount;
<span class="fc bfc" id="L160" title="All 2 branches covered.">		if(includeCumulativeCounts){</span>
<span class="fc" id="L161">			cumulativeLength +=  rangeLength;</span>
<span class="fc" id="L162">			lineCount = String.format(&quot; %d&quot;, cumulativeLength);</span>
		}else{
<span class="fc" id="L164">			lineCount=&quot;&quot;;</span>
		}
<span class="fc" id="L166">		int lineLength = maxIdLength +1 + eol.length() + rangeLength+lineCount.length();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">		for(Entry&lt;String,S&gt; entry: sequences.entrySet()){</span>
<span class="fc" id="L168">			iterators.add(entry.getValue().iterator(r));</span>
<span class="fc" id="L169">			String id = entry.getKey();</span>
			
<span class="fc" id="L171">			StringBuilder builder = new StringBuilder(lineLength);</span>
<span class="fc" id="L172">			builder.append(id);</span>
<span class="fc" id="L173">			int padding = maxIdLength - id.length();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">			for(int i=0; i&lt;padding; i++){</span>
<span class="fc" id="L175">				builder.append(' ');</span>
			}
<span class="fc" id="L177">			builder.append('\t');			</span>
<span class="fc" id="L178">			builders.add(builder);</span>
<span class="fc" id="L179">		}</span>
<span class="fc" id="L180">		StringBuilder conservationBuilder = new StringBuilder(lineLength);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		for(int i=0; i&lt;maxIdLength; i++){</span>
<span class="fc" id="L182">			conservationBuilder.append(' ');</span>
		}
<span class="fc" id="L184">		conservationBuilder.append('\t');</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">		for(int i=0; i&lt;rangeLength; i++){</span>
<span class="fc" id="L186">			Set&lt;R&gt; uniqueValues = createNewResiudeSet();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">			for(int j=0; j&lt;iterators.size(); j++){</span>
<span class="fc" id="L188">				R residue =iterators.get(j).next();</span>
<span class="fc" id="L189">				builders.get(j).append(residue.getCharacter());</span>
<span class="fc" id="L190">				uniqueValues.add(residue);</span>
			}
<span class="fc" id="L192">			ConservationInfo info = computeConservationInfo(uniqueValues);</span>
<span class="fc" id="L193">			conservationBuilder.append(info.asChar());</span>
		}
		
		//now our text for the group is all stored in StringBuilders
		//write them to out
<span class="fc bfc" id="L198" title="All 2 branches covered.">		for(int i=0; i&lt;builders.size(); i++){</span>
<span class="fc" id="L199">			StringBuilder builder = builders.get(i);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">			if(includeCumulativeCounts){</span>
<span class="fc" id="L201">				builder.append(lineCount);</span>
			}
<span class="fc" id="L203">			out.write(builder.append(eol).toString());</span>
		}
		//now write conservation string
<span class="fc" id="L206">		out.write(conservationBuilder.append(eol).toString());</span>
<span class="fc" id="L207">	}</span>
	
	
	protected abstract Set&lt;R&gt; createNewResiudeSet();
	protected abstract ConservationInfo computeConservationInfo(Set&lt;R&gt; values);
	
	@Override
	public void writeHeader(String header) {
<span class="fc" id="L215">		assertHeaderNotWrittenYet();</span>
		
<span class="fc" id="L217">		out.write(header);</span>
<span class="fc" id="L218">		out.write(eol); //end of headerline</span>
<span class="fc" id="L219">		out.write(eol); //blank line</span>
<span class="fc" id="L220">		headerWritten=true;</span>
<span class="fc" id="L221">	}</span>
	private void assertHeaderNotWrittenYet() {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">		if(headerWritten){</span>
<span class="nc" id="L224">			throw new IllegalStateException(&quot;header can only be written once&quot;);</span>
		}
		
<span class="fc" id="L227">	}</span>
	@Override
	public void write(String id, S sequence) throws IOException {
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if(id ==null){</span>
<span class="fc" id="L231">			throw new NullPointerException(&quot;id can not be null&quot;);</span>
		}
<span class="fc bfc" id="L233" title="All 2 branches covered.">		if(sequence ==null){</span>
<span class="fc" id="L234">			throw new NullPointerException(&quot;sequence can not be null&quot;);</span>
		}
<span class="fc" id="L236">		long currentSequenceLength = sequence.getLength();</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">		if(currentSequenceLength ==0){</span>
			//empty sequence should we include it?
			//no for now
<span class="nc" id="L240">			return;</span>
		}
<span class="fc bfc" id="L242" title="All 2 branches covered.">		if(sequences.isEmpty()){</span>
<span class="fc" id="L243">			seqLength = currentSequenceLength;</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">		}else if(seqLength != currentSequenceLength){</span>
<span class="nc" id="L245">			throw new IOException(String.format(&quot;invalid sequence length, all sequences so far have been %d residues but %s is %d&quot;, seqLength,id, currentSequenceLength));</span>
		}
<span class="fc bfc" id="L247" title="All 2 branches covered.">		if(sequences.containsKey(id)){</span>
<span class="fc" id="L248">			throw new IllegalArgumentException(String.format(&quot;id %s already has been written&quot;,id));</span>
		}
<span class="fc" id="L250">		sequences.put(id, sequence);</span>
		
<span class="fc" id="L252">	}</span>
	
	private static final class NucleotideAlnFileWriter extends AlnFileWriter&lt;Nucleotide, NucleotideSequence&gt;{

		
		public NucleotideAlnFileWriter(File outputFile, int residuesPerGroup,
				String eol, boolean includeCounts) throws IOException {
<span class="fc" id="L259">			super(outputFile, residuesPerGroup, eol, includeCounts);</span>
<span class="fc" id="L260">		}</span>

		@Override
		protected Set&lt;Nucleotide&gt; createNewResiudeSet() {
<span class="fc" id="L264">			return EnumSet.noneOf(Nucleotide.class);</span>
		}

		@Override
		protected ConservationInfo computeConservationInfo(
				Set&lt;Nucleotide&gt; values) {
			//nucleotides are either conserved or not
			//we consider conserved if we only have 1 type of nucleotide
<span class="fc bfc" id="L272" title="All 2 branches covered.">			if(values.size() ==1){</span>
				//if the slice is all gaps
				//it's not identical
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">				if(values.contains(Nucleotide.Gap)){</span>
<span class="nc" id="L276">					return ConservationInfo.NOT_CONSERVED;</span>
				}
<span class="fc" id="L278">				return ConservationInfo.IDENTICAL;</span>
			}
<span class="fc" id="L280">			return ConservationInfo.NOT_CONSERVED;</span>
		}
		
	}
	
	private static final class AminoAcidAlnFileWriter extends AlnFileWriter&lt;AminoAcid, ProteinSequence&gt;{
		/*
		 * From Susmita - if a slice contains only the residues of
		 * one of these rows, then it is considered conserved.
		 * 
		 * 
		 	G,A,V,L,I, M        aliphatic (though some would not include G)
			S,T,C                      hydroxyl, sulfhydryl, polar
			N,Q                        amide side chains
			F,W,Y                    aromatic
			H,K,R                     basic
			D,E                         acidic
		 */
<span class="nc" id="L298">		private static Set&lt;AminoAcid&gt; ALIPHATIC = EnumSet.of(AminoAcid.Glycine, AminoAcid.Alanine, AminoAcid.Valine, AminoAcid.Leucine, AminoAcid.Isoleucine, AminoAcid.Methionine);</span>
<span class="nc" id="L299">		private static Set&lt;AminoAcid&gt; HYDROXYL_SULFHYDRYL_POLAR = EnumSet.of(AminoAcid.Serine, AminoAcid.Threonine, AminoAcid.Cysteine);</span>
<span class="nc" id="L300">		private static Set&lt;AminoAcid&gt; AMIDE_SIDE_CHAINS = EnumSet.of(AminoAcid.Asparagine, AminoAcid.Glutamine);</span>
		
<span class="nc" id="L302">		private static Set&lt;AminoAcid&gt; AROMATIC = EnumSet.of(AminoAcid.Phenylalanine, AminoAcid.Tryptophan, AminoAcid.Tyrosine);</span>
		
<span class="nc" id="L304">		private static Set&lt;AminoAcid&gt; BASIC = EnumSet.of(AminoAcid.Histidine, AminoAcid.Lysine, AminoAcid.Arginine);</span>
<span class="nc" id="L305">		private static Set&lt;AminoAcid&gt; ACIDIC = EnumSet.of(AminoAcid.Aspartic_Acid, AminoAcid.Glutamic_Acid);</span>
		
		
		public AminoAcidAlnFileWriter(File outputFile, int residuesPerGroup,
				String eol, boolean includeCounts) throws IOException {
<span class="nc" id="L310">			super(outputFile, residuesPerGroup, eol, includeCounts);</span>
<span class="nc" id="L311">		}</span>

		@Override
		protected Set&lt;AminoAcid&gt; createNewResiudeSet() {
<span class="nc" id="L315">			return EnumSet.noneOf(AminoAcid.class);</span>
		}

		@Override
		protected ConservationInfo computeConservationInfo(
				Set&lt;AminoAcid&gt; values) {
			/**
			 * G,A,V,L,I, M        aliphatic (though some would not include G)
				S,T,C                      hydroxyl, sulfhydryl, polar
				N,Q                        amide side chains
				F,W,Y                    aromatic
				H,K,R                     basic
				D,E                         acidic
			 */
			//nucleotides are either conserved or not
			//we consider conserved if we only have 1 type of nucleotide
<span class="nc bnc" id="L331" title="All 2 branches missed.">			if(values.size() ==1){</span>
<span class="nc" id="L332">				return ConservationInfo.IDENTICAL;</span>
			}
<span class="nc bnc" id="L334" title="All 4 branches missed.">			if(ALIPHATIC.containsAll(values) || HYDROXYL_SULFHYDRYL_POLAR.containsAll(values)</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">					|| AMIDE_SIDE_CHAINS.containsAll(values) || AROMATIC.containsAll(values) </span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">					|| ACIDIC.containsAll(values) || BASIC.containsAll(values)){</span>
<span class="nc" id="L337">				return ConservationInfo.CONSERVED_SUBSITUTION;</span>
			}
<span class="nc" id="L339">			return ConservationInfo.NOT_CONSERVED;</span>
		}
		
	}
	/**
	 * {@code AlnFileWriterBuilder} is a Builder
	 * that can create new {@link AlnFileWriter}
	 * instances. 
	 * @author dkatzel
	 *
	 * @param &lt;R&gt; the type of {@link Residue} to be written.
	 * @param &lt;S&gt; type of {@link Sequence} to be written.
	 */
	public abstract static class AlnFileWriterBuilder&lt;R extends Residue, S extends Sequence&lt;R&gt;&gt;{
		
		private final File outFile;
		
<span class="fc" id="L356">		private int residuesPerGroup = DEFAULT_RESIDUES_PER_GROUP;</span>
<span class="fc" id="L357">		private String eol = &quot;\n&quot;;</span>
		
<span class="fc" id="L359">		private boolean includeCumulativeCounts=false;</span>
		
		
<span class="fc" id="L362">		private AlnFileWriterBuilder(File outFile) {</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">			if(outFile ==null){</span>
<span class="nc" id="L364">				throw new NullPointerException(&quot;output File can not be null&quot;);</span>
			}
<span class="fc" id="L366">			this.outFile = outFile;</span>
<span class="fc" id="L367">		}</span>
		/**
		 * Set the number of residues per &quot;group&quot;. If not set,
		 * then the default number of 60 residues will be used.
		 * If this method is called along with {@link #forceOneGroupOnly()}
		 * then the last one called &quot;wins&quot;.
		 * @param n the number of residues per group;
		 * must be &gt;0.
		 * @return this
		 * @throws IllegalArgumentException if n &lt;1.
		 * @see #forceOneGroupOnly()
		 */
		public AlnFileWriterBuilder&lt;R,S&gt; setNumResiduesPerGroup(int n){
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">			if(n &lt;1){</span>
<span class="nc" id="L381">				throw new IllegalArgumentException(&quot;number of residues per group must be &gt;= 1&quot;);</span>
			}
<span class="fc" id="L383">			this.residuesPerGroup = n;</span>
<span class="fc" id="L384">			return this;</span>
		}
		/**
		 * Set end of line String to use.
		 * If not set, the default is '\n'.
		 * @param eol the end of line string to use;
		 * may not be null.
		 * @return this
		 * @throws NullPointerException if eol is null.
		 */
		public AlnFileWriterBuilder&lt;R,S&gt; eol(String eol){
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">			if(eol ==null){</span>
<span class="nc" id="L396">				throw new NullPointerException(&quot;end of line can not be null&quot;);</span>
			}
<span class="fc" id="L398">			this.eol = eol;</span>
<span class="fc" id="L399">			return this;</span>
		}
		/**
		 * Force all the alignments into one group,
		 * this has the equivalent effect of making the number
		 * of residues per group infinite.
		 * If this method is called along with {@link #setNumResiduesPerGroup(int)}
		 * then the last one called &quot;wins&quot;.
		 * @return this
		 * @see #setNumResiduesPerGroup(int)
		 */
		public AlnFileWriterBuilder&lt;R,S&gt; forceOneGroupOnly(){
<span class="fc" id="L411">			this.residuesPerGroup = USE_ONE_GROUP;</span>
<span class="fc" id="L412">			return this;</span>
		}
		/**
		 * Create a new {@link AlnFileWriter}
		 * instance using the configuration data
		 * provided so far.
		 * @return a new {@link AlnFileWriter};
		 * will never be null.
		 * @throws IOException if there is a problem creating the 
		 * writer.
		 */
		public AlnFileWriter&lt;R, S&gt; build() throws IOException{
<span class="fc" id="L424">			return createNew(outFile, residuesPerGroup, eol, includeCumulativeCounts);</span>
		}
		/**
		 * Include the cumulative count of residues for the seqences
		 * on each sequence line. If this method is not called,
		 * then the writer will default to not writing out the counts
		 * (same as calling this method with {@code false}.
		 * &lt;p&gt;
		 * If set to {@code true}, then the output will look like this:
		 * &lt;pre&gt;
		 *...
		*FOSB_MOUSE      MFQAFPGDYDSGSRCSSSPSAESQYLSSVDSFGSPPTAAASQECAGLGEMPGSFVPTVTA 60
      	*FOSB_HUMAN      MFQAFPGDYDSGSRCSSSPSAESQYLSSVDSFGSPPTAAASQECAGLGEMPGSFVPTVTA 60
      	*                ************************************************************

        *FOSB_MOUSE      ITTSQDLQWLVQPTLISSMAQSQGQPLASQPPAVDPYDMPGTSYSTPGLSAYSTGGASGS 120
        *FOSB_HUMAN      ITTSQDLQWLVQPTLISSMAQSQGQPLASQPPVVDPYDMPGTSYSTPGMSGYSSGGASGS 120
        *                ********************************.***************:*.**:******

		* etc..
		 * &lt;/pre&gt;
		 * @param include flag to include the counts or not.
		 * @return this.
		 */
		public AlnFileWriterBuilder&lt;R, S&gt; includeCumulativeCounts(boolean include) {
<span class="fc" id="L449">			includeCumulativeCounts = include;</span>
<span class="fc" id="L450">			return this;</span>
		}
		
		protected abstract AlnFileWriter&lt;R, S&gt; createNew(File f, int groupLength, String endOfLine, boolean includeCounts) throws IOException;
		
	}
	
	public static final class NucleotideAlnFileWriterBuilder extends AlnFileWriterBuilder&lt;Nucleotide, NucleotideSequence&gt;{

		public NucleotideAlnFileWriterBuilder(File outFile) {
<span class="fc" id="L460">			super(outFile);</span>
<span class="fc" id="L461">		}</span>

		@Override
		protected AlnFileWriter&lt;Nucleotide, NucleotideSequence&gt; createNew(File f, int groupLength, String endOfLine, boolean includeCounts) throws IOException {
<span class="fc" id="L465">			return new NucleotideAlnFileWriter(f, groupLength, endOfLine, includeCounts);</span>
		}

		
	}
	
	public static final class AminoAcidAlnFileWriterBuilder extends AlnFileWriterBuilder&lt;AminoAcid, ProteinSequence&gt;{

		public AminoAcidAlnFileWriterBuilder(File outFile) {
<span class="nc" id="L474">			super(outFile);</span>
<span class="nc" id="L475">		}</span>

		@Override
		protected AlnFileWriter&lt;AminoAcid, ProteinSequence&gt; createNew(File f, int groupLength, String endOfLine, boolean includeCounts) throws IOException {
<span class="nc" id="L479">			return new AminoAcidAlnFileWriter(f, groupLength, endOfLine,includeCounts);</span>
		}

		
	}

	

	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>