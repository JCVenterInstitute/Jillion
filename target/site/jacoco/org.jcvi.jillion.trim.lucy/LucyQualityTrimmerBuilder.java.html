<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LucyQualityTrimmerBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trim.lucy</a> &gt; <span class="el_source">LucyQualityTrimmerBuilder.java</span></div><h1>LucyQualityTrimmerBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trim.lucy;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Ranges;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.internal.core.util.JillionUtil;
import org.jcvi.jillion.trim.QualityTrimmer;



/**
 * {@code LucyLikeQualityTrimmerBuilder} 
 * is a {@link org.jcvi.jillion.core.util.Builder}
 * that can create a {@link QualityTrimmer}
 * that  trims {@link QualitySequence}s
 * using the same algorithm as the TIGR program
 *  Lucy.  The algorithm 
 * this class uses is the algorithm from the 2001 Lucy paper in
 * Bioinformatics (link is below).
 * &lt;p&gt;
 * The Trimming algorithm performs 3 separate trimming phases:
 * &lt;ol&gt;
 * &lt;li&gt; 
 * The beginning and end of each sequence is trimmed to remove the low
 * quality data from each end.  The resulting region is called the &lt;code&gt;bracket&lt;/code&gt;.
 * &lt;/li&gt;
 * &lt;li&gt;
 * The &lt;code&gt;bracket&lt;/code&gt; is then trimmed against a series of sliding &lt;code&gt;Window&lt;/code&gt;s.
 * A Window of a certain size is slid across the &lt;code&gt;bracket&lt;/code&gt;, if the average error probability
 * of the data inside the window meets the given threshold, then that window is considered good quality.
 * If more than one window is given,then
 * the next Window is applied to the good quality range found by the previous window.
 * The order of the Windows applied to trimming is largest window size
 * to smallest window size.  The resulting ranges from this step will be referred
 * to as &lt;code&gt;candidate regions&lt;/code&gt;
 * &lt;/li&gt;
 * &lt;li&gt; 
 * Finally, the candidate good quality regions are further trimmed to meet overall
 * error rates and the ends of the region (currently first and last 2 bases)
 * must also meet a specific error rate threshold.  Each candidate region is trimmed
 * until each end and the total overall error rate meet these thresholds at the same time. 
 * &lt;/li&gt;
 * 
 * The largest of the ranges after all these steps is the final trim range.
 * &lt;/ol&gt;
 * @author dkatzel
 *
 * @see &lt;a href =&quot;http://www.ncbi.nlm.nih.gov/pubmed/11751217&quot;&gt;
 Chou HH, Holmes MH. DNA sequence quality trimming and vector removal. Bioinformatics. 2001;17:1093-1104. doi: 10.1093/bioinformatics/17.12.1093.&lt;/a&gt;
 */
public final class LucyQualityTrimmerBuilder implements org.jcvi.jillion.core.util.Builder&lt;QualityTrimmer&gt;{

<span class="fc" id="L82">        public static final Window DEFAULT_BRACKET_WINDOW = new Window(10, 0.02D);</span>
<span class="fc" id="L83">        private static final List&lt;Window&gt; DEFAULT_TRIM_WINDOWS = Arrays.asList(</span>
                                                        new Window(50,0.08D),
                                                        new Window(10,0.3D));
        public static final double DEFAULT_MAX_AVG_ERROR = 0.025D;
        public static final double DEFAULT_ERROR_AT_ENDS = 0.02D;
        
        private final int minGoodLength;
        private final Window bracketWindow;
        private double maxAvgError;
        private double maxErrorAtEnds;
        
<span class="fc" id="L94">        private final Set&lt;Window&gt; trimWindows = new TreeSet&lt;Window&gt;();</span>
        /**
         * Create a new instance of {@code LucyLikeQualityTrimmerBuilder}
         * which is initialized to default max average error {@value #DEFAULT_MAX_AVG_ERROR}
         * @param minGoodLength the minimum good quality length of the sequences
         * to be trimmed. If after trimming by 
         * {@link QualityTrimmer#trim(QualitySequence)},
         *  the trimmed length is less than this specified
         * value, then an empty Range will be returned instead.
         */
<span class="fc" id="L104">        public LucyQualityTrimmerBuilder(int minGoodLength){</span>
<span class="fc" id="L105">            this.minGoodLength = minGoodLength;</span>
<span class="fc" id="L106">            this.bracketWindow = DEFAULT_BRACKET_WINDOW;</span>
<span class="fc" id="L107">            this.maxAvgError = DEFAULT_MAX_AVG_ERROR;</span>
<span class="fc" id="L108">            this.maxErrorAtEnds = DEFAULT_ERROR_AT_ENDS;</span>
<span class="fc" id="L109">        }</span>
        /**
         * Set the max average error of the entire trimmed sequence.
         * The sequence will be trimmed until the remaining portion
         * has a total average error rate &lt;= this value.
         * @param maxAvgError the max average error to set; must be
         * between 0 and 1 inclusive.
         * @return this.
         * @throws IllegalArgumentException if the given value
         * is not between 0 and 1 inclusive.
         */
        public LucyQualityTrimmerBuilder maxAvgError(double maxAvgError){
<span class="nc" id="L121">        	isValidErrorRate(maxAvgError);</span>
<span class="nc" id="L122">            this.maxAvgError = maxAvgError;</span>
<span class="nc" id="L123">            return this;</span>
        }
		private void isValidErrorRate(double maxAvgError) {
<span class="pc bpc" id="L126" title="2 of 4 branches missed.">			if(maxAvgError &lt;0D || maxAvgError &gt;1D){</span>
<span class="nc" id="L127">        		throw new IllegalArgumentException(&quot;max avg error must be between 0.0 and 1.0&quot;);</span>
        	}
<span class="fc" id="L129">		}</span>
		/**
         * Set the max error at each end of the 
         * trimmed sequence.  
         * The sequence will be trimmed until the first few
         * qualities on each end of the trimmed range
         * have an error rate &lt;= this value.
         * @param maxErrorAtEdges the max error and end of the trimmed
         * sequence can have; error to set; must be
         * between 0 and 1 inclusive.
         * @return this.
         * @throws IllegalArgumentException if the given value
         * is not between 0 and 1 inclusive.
         */
        public LucyQualityTrimmerBuilder maxErrorAtEdges(double maxErrorAtEdges){
<span class="nc" id="L144">        	isValidErrorRate(maxErrorAtEdges);</span>
<span class="nc" id="L145">            this.maxErrorAtEnds = maxErrorAtEdges;</span>
<span class="nc" id="L146">            return this;</span>
        }
        /**
         * Add an additional sliding trim window to this trimmer.
         * The final trimmed sequence must meet the requirements of ALL
         * given trim windows.  This Builder will correctly sort the trim windows
         * by size for the algorithm to work so users can add trim windows
         * in any order without affecting the output of this trimmer.
         * @param windowSize the size of this trimming window.
         * @param maxErrorRate the max error rate for all the qualities in this window size.
         * @return this.
         * @throws IllegalArgumentException if the maxErrorRate
         * is not between 0 and 1 inclusive.
         * @throws IllegalArgumentException if the windowSize
         * is &lt;1.
         */
        public LucyQualityTrimmerBuilder addTrimWindow(int windowSize, double maxErrorRate){
<span class="fc" id="L163">        	isValidErrorRate(maxErrorRate);</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        	if(windowSize &lt;1){</span>
<span class="nc" id="L165">        		throw new IllegalArgumentException(&quot;window size must be &gt;= 1&quot;);</span>
        	}
<span class="fc" id="L167">            trimWindows.add(new Window(windowSize, maxErrorRate));</span>
<span class="fc" id="L168">            return this;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public QualityTrimmer build() {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if(trimWindows.isEmpty()){</span>
<span class="nc" id="L176">                trimWindows.addAll(DEFAULT_TRIM_WINDOWS);</span>
            }
<span class="fc" id="L178">            return new LucyLikeQualityTrimmerImpl(minGoodLength, </span>
                                            bracketWindow, 
                                            trimWindows, 
                                            maxAvgError, 
                                            maxErrorAtEnds);
        }
        /**
         * Actual {@link QualityTrimmer} implementation that
         * trims according to the lucy algorithms.
         * @author dkatzel
         *
         */
        private static final class LucyLikeQualityTrimmerImpl  implements QualityTrimmer{
            private static final int SIZE_OF_ENDS =2;
            private final int minGoodLength;
            private final Window bracketWindow;
            private final double maxTotalAvgError;
            private final double maxErrorAtEnds;
            
            private final Set&lt;Window&gt; trimWindows;
            
            
            
            /**
             * @param minGoodLength
             * @param bracketWindow
             * @param trimWindows
             * @param maxAvgError
             * @param maxErrorAtEnds
             */
            private LucyLikeQualityTrimmerImpl(int minGoodLength, Window bracketWindow,
<span class="fc" id="L209">                    Set&lt;Window&gt; trimWindows, double maxAvgError, double maxErrorAtEnds) {</span>
<span class="fc" id="L210">                this.minGoodLength = minGoodLength;</span>
<span class="fc" id="L211">                this.bracketWindow = bracketWindow;</span>
<span class="fc" id="L212">                this.trimWindows = trimWindows;</span>
<span class="fc" id="L213">                this.maxTotalAvgError = maxAvgError;</span>
<span class="fc" id="L214">                this.maxErrorAtEnds = maxErrorAtEnds;</span>
<span class="fc" id="L215">            }</span>
            
            @Override
            public Range trim(QualitySequence qualities){
<span class="fc" id="L219">                List&lt;Double&gt; errorRates = convertToErrorRates(qualities);</span>
<span class="fc" id="L220">                Range bracketedRegion = findBracketedRegion(errorRates);</span>
<span class="fc" id="L221">                Range largestRange = findLargestCleanRangeFrom(bracketedRegion, errorRates);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">                if(largestRange.getLength() &lt; minGoodLength){</span>
<span class="fc" id="L223">                    return new Range.Builder().build();</span>
                }
<span class="fc" id="L225">                return new Range.Builder(largestRange)</span>
<span class="fc" id="L226">                			.shift(bracketedRegion.getBegin())</span>
<span class="fc" id="L227">                			.build();</span>
            }


            private Range findLargestCleanRangeFrom(Range bracketedRegion,
                    List&lt;Double&gt; errorRates) {
<span class="fc" id="L233">                List&lt;Double&gt; bracketedErrorRates = getSubList(errorRates, bracketedRegion);</span>
<span class="fc" id="L234">                List&lt;Range&gt; largestRanges = new ArrayList&lt;Range&gt;();</span>
<span class="fc" id="L235">                List&lt;Range&gt; candidateCleanRanges = findCandidateCleanRangesFrom(bracketedErrorRates,trimWindows);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">				for(Range candidateCleanRange : candidateCleanRanges){</span>
<span class="fc" id="L237">                    List&lt;Double&gt; candidateErrorRates = getSubList(bracketedErrorRates, candidateCleanRange);</span>
<span class="fc" id="L238">                    largestRanges.add(findLargestRangeThatPassesTotalAvgErrorRate(candidateErrorRates, candidateCleanRange));</span>
<span class="fc" id="L239">                }</span>
                
<span class="fc" id="L241">                return getLargestRangeFrom(largestRanges);</span>
            }


            private List&lt;Double&gt; getSubList(List&lt;Double&gt; errorRates,
                    Range region) {
<span class="fc" id="L247">                return errorRates.subList((int)region.getBegin(), (int)region.getEnd()+1);</span>
            }


            private List&lt;Double&gt; convertToErrorRates(QualitySequence qualities){
<span class="fc" id="L252">                List&lt;Double&gt; errorRates = new ArrayList&lt;Double&gt;((int)qualities.getLength());</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                for(PhredQuality quality : qualities){</span>
<span class="fc" id="L254">                    errorRates.add(quality.getErrorProbability());</span>
<span class="fc" id="L255">                }</span>
<span class="fc" id="L256">                return errorRates;</span>
            }

            private Range findLargestRangeThatPassesTotalAvgErrorRate(List&lt;Double&gt; encodedCandidateErrorRates,
                    Range candidateCleanRange) {
<span class="fc" id="L261">                long currentWindowSize = candidateCleanRange.getLength();</span>
<span class="fc" id="L262">                boolean done=false;</span>
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">                while(!done &amp;&amp; currentWindowSize &gt;=SIZE_OF_ENDS){</span>
                   
<span class="pc bpc" id="L265" title="1 of 4 branches missed.">                    for(int i=0; i&lt; (encodedCandidateErrorRates.size() - currentWindowSize) &amp;&amp; i&lt;=currentWindowSize; i++){</span>
<span class="fc" id="L266">                        Range currentWindowRange = new Range.Builder(currentWindowSize).shift(i).build();</span>
<span class="fc" id="L267">                        double avgErrorRate = this.computeAvgErrorRateOf(encodedCandidateErrorRates, currentWindowRange);</span>
<span class="fc" id="L268">                        Range leftRange = new Range.Builder(SIZE_OF_ENDS)</span>
<span class="fc" id="L269">                        					.shift(currentWindowRange.getBegin())</span>
<span class="fc" id="L270">                        					.build();</span>
<span class="fc" id="L271">						double leftEndErrorRate = this.computeAvgErrorRateOf(encodedCandidateErrorRates, leftRange);</span>
<span class="fc" id="L272">                        double rightEndErrorRate = this.computeAvgErrorRateOf(encodedCandidateErrorRates, new Range.Builder(SIZE_OF_ENDS).shift(currentWindowRange.getEnd()-SIZE_OF_ENDS).build());</span>
<span class="pc bpc" id="L273" title="1 of 6 branches missed.">                        if(avgErrorRate &lt;= this.maxTotalAvgError </span>
                                &amp;&amp; leftEndErrorRate &lt;= this.maxErrorAtEnds 
                                &amp;&amp; rightEndErrorRate &lt;= this.maxErrorAtEnds){
                            //found a good range!
<span class="fc" id="L277">                            return new Range.Builder(currentWindowRange)</span>
<span class="fc" id="L278">                            		.shift(candidateCleanRange.getBegin())</span>
<span class="fc" id="L279">                            		.build();</span>
                        }
                    }
<span class="fc" id="L282">                    currentWindowSize--;</span>
                }
<span class="nc" id="L284">                return new Range.Builder()</span>
<span class="nc" id="L285">        					.shift(candidateCleanRange.getBegin())</span>
<span class="nc" id="L286">        					.build();</span>
            }


            /**
             * @param decode
             * @return
             */
            private List&lt;Range&gt; findCandidateCleanRangesFrom(List&lt;Double&gt; bracketedErrorRates, Set&lt;Window&gt; slidingWindows) {
<span class="fc" id="L295">                Iterator&lt;Window&gt; iterator = slidingWindows.iterator();</span>
                
<span class="fc" id="L297">                Window firstTrimWindow = iterator.next();</span>
<span class="fc" id="L298">                List&lt;Range&gt; candidateCleanRanges = trim(bracketedErrorRates, firstTrimWindow);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                while(iterator.hasNext()){</span>
<span class="fc" id="L300">                    Window subsequentTrimWindow = iterator.next();</span>
<span class="fc" id="L301">                    List&lt;Range&gt; trimmedCandidateCleanRanges = new ArrayList&lt;Range&gt;();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                    for(Range range : candidateCleanRanges){</span>
<span class="fc" id="L303">                        List&lt;Range&gt; trim = trim(getSubList(bracketedErrorRates,range), subsequentTrimWindow);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">						for(Range newCandidateRange : trim){</span>
<span class="fc" id="L305">                            trimmedCandidateCleanRanges.add(new Range.Builder(newCandidateRange)</span>
<span class="fc" id="L306">                            								.shift(range.getBegin())</span>
<span class="fc" id="L307">                            								.build());</span>
<span class="fc" id="L308">                        }</span>
<span class="fc" id="L309">                    }</span>
<span class="fc" id="L310">                    candidateCleanRanges = trimmedCandidateCleanRanges;</span>
<span class="fc" id="L311">                }</span>
<span class="fc" id="L312">                return candidateCleanRanges;</span>
            }


            /**
             * @param bracketedQualities
             * @param trimWindow
             * @return
             */
            private List&lt;Range&gt; trim(List&lt;Double&gt; errorRates, Window trimWindow) {
<span class="fc" id="L322">                List&lt;Range&gt; candidateCleanRanges = new ArrayList&lt;Range&gt;();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                for(long i=0; i&lt;errorRates.size()-trimWindow.getSize(); i++){</span>
<span class="fc" id="L324">                    Range windowRange = new Range.Builder(trimWindow.getSize()).shift(i).build();</span>
                    
<span class="fc" id="L326">                    double avgErrorRate = computeAvgErrorRateOf(errorRates,windowRange);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                    if(avgErrorRate &lt;= trimWindow.getMaxErrorRate()){</span>
<span class="fc" id="L328">                        candidateCleanRanges.add(windowRange);</span>
                    }
                }
<span class="fc" id="L331">                return Ranges.merge(candidateCleanRanges);</span>
            }


            /**
             * The {@code bracket} is the resulting
             * region of qualities once it is trimmed to remove the low
             * quality data from each end.
             * @param qualities
             * @return
             */
            private Range findBracketedRegion(List&lt;Double&gt; errorRates) {
<span class="fc" id="L343">                long leftCoordinate = findLeftBracketCoordinate(errorRates);</span>
<span class="fc" id="L344">                long rightCoordinate = findRightBracketCoordinate(errorRates);</span>
                //right could be several hundred bases smaller
                //so we must check before we pass to build range
                //buildRange will throw an exception if left &gt;= right-1
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if(leftCoordinate &gt; rightCoordinate-2){</span>
<span class="fc" id="L349">                    return new Range.Builder().build();</span>
                }
<span class="fc" id="L351">                return Range.of(leftCoordinate, rightCoordinate);</span>
            }
            /**
             * @param qualities
             * @return
             */
            private long findRightBracketCoordinate(List&lt;Double&gt; errorRates) {
<span class="fc" id="L358">                long coordinate=errorRates.size()-1;</span>
<span class="fc" id="L359">                final int bracketSize = bracketWindow.getSize();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                while(coordinate &gt;= bracketSize){</span>
<span class="fc" id="L361">                    Range windowRange = new Range.Builder(bracketSize).shift(coordinate-bracketSize).build();</span>
<span class="fc" id="L362">                    double avgErrorRate = computeAvgErrorRateOf(errorRates,windowRange);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                    if(avgErrorRate &lt;= bracketWindow.getMaxErrorRate()){</span>
<span class="fc" id="L364">                        return coordinate;</span>
                    }
<span class="fc" id="L366">                    coordinate--;</span>
<span class="fc" id="L367">                }</span>
<span class="fc" id="L368">                return coordinate;</span>
            }


            /**
             * @param qualities
             * @return
             */
            private int findLeftBracketCoordinate(List&lt;Double&gt; errorRates) {
<span class="fc" id="L377">                int coordinate=0;</span>
<span class="fc" id="L378">                final int bracketSize = bracketWindow.getSize();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                while(coordinate &lt; errorRates.size()- bracketSize){</span>
<span class="fc" id="L380">                    Range windowRange = new Range.Builder(bracketSize).shift(coordinate).build();</span>
<span class="fc" id="L381">                    double avgErrorRate = computeAvgErrorRateOf(errorRates,windowRange);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                    if(avgErrorRate &lt;= bracketWindow.getMaxErrorRate()){</span>
<span class="fc" id="L383">                        return coordinate;</span>
                    }
<span class="fc" id="L385">                    coordinate++;</span>
<span class="fc" id="L386">                }</span>
<span class="fc" id="L387">                return coordinate;</span>
            }


            private double computeAvgErrorRateOf(List&lt;Double&gt; errorRates,
                    Range windowRange) {
<span class="fc" id="L393">                 double totalErrorRate = 0;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                 for(double errorRate : getSubList(errorRates, windowRange)){</span>
<span class="fc" id="L395">                     totalErrorRate+= errorRate;</span>
<span class="fc" id="L396">                 }</span>
                 
<span class="fc" id="L398">                 return totalErrorRate/windowRange.getLength();</span>
             }
            
            private Range getLargestRangeFrom(List&lt;Range&gt; goodQualityRanges) {
<span class="fc bfc" id="L402" title="All 2 branches covered.">                if(goodQualityRanges.isEmpty()){</span>
<span class="fc" id="L403">                    return new Range.Builder().build();</span>
                }
<span class="fc" id="L405">                List&lt;Range&gt; sorted = new ArrayList&lt;Range&gt;(goodQualityRanges);</span>
<span class="fc" id="L406">                Collections.sort(sorted, Range.Comparators.LONGEST_TO_SHORTEST);</span>
<span class="fc" id="L407">                return sorted.get(0);</span>
                
            }
    }
        /**
         * 
         * @author dkatzel
         *
         */
        private static final class Window implements Comparable&lt;Window&gt;{
            private final int size;
            private final double maxErrorRate;
            /**
             * @param size
             * @param maxErrorRate
             */
<span class="fc" id="L423">            public Window(int size, double maxErrorRate) {</span>
<span class="fc" id="L424">                this.size = size;</span>
<span class="fc" id="L425">                this.maxErrorRate = maxErrorRate;</span>
<span class="fc" id="L426">            }</span>
            public int getSize() {
<span class="fc" id="L428">                return size;</span>
            }
            public double getMaxErrorRate() {
<span class="fc" id="L431">                return maxErrorRate;</span>
            }
            
            @Override
            public int hashCode() {
<span class="nc" id="L436">                final int prime = 31;</span>
<span class="nc" id="L437">                int result = 1;</span>
                long temp;
<span class="nc" id="L439">                temp = Double.doubleToLongBits(maxErrorRate);</span>
<span class="nc" id="L440">                result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc" id="L441">                result = prime * result + size;</span>
<span class="nc" id="L442">                return result;</span>
            }
            @Override
            public boolean equals(Object obj) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (this == obj) {</span>
<span class="nc" id="L447">                    return true;</span>
                }
<span class="nc bnc" id="L449" title="All 2 branches missed.">                if (obj == null) {</span>
<span class="nc" id="L450">                    return false;</span>
                }
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (!(obj instanceof Window)) {</span>
<span class="nc" id="L453">                    return false;</span>
                }
<span class="nc" id="L455">                Window other = (Window) obj;</span>
<span class="nc" id="L456">                if (Double.doubleToLongBits(maxErrorRate) != Double</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                        .doubleToLongBits(other.maxErrorRate)) {</span>
<span class="nc" id="L458">                    return false;</span>
                }
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (size != other.size) {</span>
<span class="nc" id="L461">                    return false;</span>
                }
<span class="nc" id="L463">                return true;</span>
            }
            
            
            @Override
            public String toString() {
<span class="nc" id="L469">                return &quot;Window [size=&quot; + size + &quot;, maxErrorRate=&quot; + maxErrorRate</span>
                        + &quot;]&quot;;
            }
            /**
            * Compares 2 {@link Window}s sorted largest window size first,
            * then by largest maxErrorRate.
            */
            @Override
            public int compareTo(Window o) {
            	
<span class="fc" id="L479">                int sizeCmp= JillionUtil.compare(o.getSize(),size);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                if(sizeCmp !=0){</span>
<span class="fc" id="L481">                    return sizeCmp;</span>
                }
<span class="fc" id="L483">                return Double.compare(o.getMaxErrorRate(), maxErrorRate);</span>
            }
            
        }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>