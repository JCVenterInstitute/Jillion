<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CasFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.clc.cas</a> &gt; <span class="el_source">CasFileParser.java</span></div><h1>CasFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Oct 27, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.clc.cas;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.jcvi.jillion.assembly.clc.cas.CasFileVisitor.CasVisitorCallback;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
/**
 * {@code CasFileParser} is a {@link CasParser}
 * that can parse CLC .cas formated files
 * that were created using either the 
 * legacy clc_ref_assemble_X programs or the newer
 * clc_mapper program.  Both programs make slightly different
 * versions of cas files that are not backwards compatible.
 * 
 * @author dkatzel
 *
 */
public final class CasFileParser implements CasParser{
	
	/**
	 * The first 7 bytes of the cas file magic number
	 * should be the same for all the different versions
	 * of cas.
	 */
<span class="fc" id="L62">	private static final byte[] CAS_MAGIC_NUMBER_PREFIX = new byte[]{</span>
        (byte)0x43,
        (byte)0x4c,
        (byte)0x43,
        (byte)0x80,
        (byte)0x00,
        (byte)0x00,
        (byte)0x00,
    };
	
    private  int numberOfBytesForContigPosition,numberOfBytesForContigNumber;
    private  long numberOfReads;
    private CasScoringScheme scoringScheme;
    private final File casFile;
    
    /**
     * Create a new {@link CasParser} instance to parse the given
     * cas formatted file without first validating it.  Please note, that the file won't
     * actually be parsed until {@link CasParser#parse(CasFileVisitor)}
     * is called.
     * This is the same as calling 
     * {@link #create(File, boolean) create(casFile, false)} (no validation).
     * @param casFile the cas formatted file to parse;
     * can not be null and must exist.
     * @return a new {@link CasParser} instance; 
     * will never be null.
     * @throws IOException if the casFile does not exist.
     * @throws NullPointerException if casFile is null.
     * @see #create(File, boolean)
     */
    public static CasParser create(File casFile) throws IOException{
<span class="fc" id="L93">    	return new CasFileParser(casFile, false);</span>
    }
    /**
     * Create a new {@link CasParser} instance to parse the given
     * cas formatted file.
     * @param casFile the cas formatted file to parse;
     * can not be null and must exist.
     * @param validate validate the cas input data at construction time.
     * If set to {@code true}, then this constructor will fail fast if there are discrepancies between what the cas file
     * was assembled with and what the data files currently look like.
     * For example: if an input file no longer has the same number of records
     * or a different number of bases etc.  If validation fails,
     * then an {@link IllegalStateException} is thrown by this
     * constructor.  Validation is very time consuming since
     * all input files must be completely parsed so use validation 
     * with care.
     * @return a new {@link CasParser} instance; 
     * will never be null.
     * @throws IOException if the casFile does not exist.
     * @throws NullPointerException if casFile is null.
     * @throws IllegalStateException if validate is set to {@code true}
     * and validation fails.
     */
    public static CasParser create(File casFile, boolean validate) throws IOException{
<span class="fc" id="L117">    	return new CasFileParser(casFile, validate);</span>
    }
    /**
     * Get the cas file's working directory where all relative paths
     * in the cas are referenced from.
     * @return a File; may be null if working dir is the root
     * or local directory. (Similar to File#getParentFile())
     */
    @Override
    public File getWorkingDir(){
<span class="fc" id="L127">    	return casFile.getParentFile();</span>
    }
    
<span class="fc" id="L130">    private CasFileParser(File file, boolean validate) throws IOException{</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">    	if(file ==null){</span>
<span class="nc" id="L132">    		throw new NullPointerException(&quot;cas file can not be null&quot;);</span>
    	}
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    	if(!file.exists()){</span>
<span class="nc" id="L135">    		throw new FileNotFoundException(file.getAbsolutePath());</span>
    	}
<span class="fc" id="L137">    	this.casFile = file;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">    	if(validate){</span>
<span class="fc" id="L139">    		CasValidator validator = new CasValidator(getWorkingDir());</span>
<span class="fc" id="L140">    		parse(validator);</span>
    	}
<span class="fc" id="L142">    }</span>
    @Override
    public void parse(CasFileVisitor visitor) throws IOException{
<span class="fc" id="L145">    	parseMetaData(visitor);</span>
<span class="fc" id="L146">    	CasVisitorCallbackImpl callback = new CasVisitorCallbackImpl();</span>
<span class="fc" id="L147">    	CasMatchVisitor matchVisitor = visitor.visitMatches(callback);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">    	if(matchVisitor!=null){</span>
    		//need to visit matches
<span class="fc" id="L150">        	visitMatches(callback, matchVisitor);</span>

    	}
    	//done the file
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">		if(callback.keepParsing()){</span>
<span class="fc" id="L155">			visitor.visitEnd();</span>
		}else{
<span class="nc" id="L157">			visitor.halted();</span>
		}
<span class="fc" id="L159">	}</span>
    	
    @Override
	public boolean canParse() {
<span class="nc" id="L163">		return true;</span>
	}

	private void visitMatches(CasVisitorCallbackImpl callback,
    		CasMatchVisitor visitor) throws IOException {
<span class="fc" id="L168">        DataInputStream dataIn = new DataInputStream(new BufferedInputStream(new FileInputStream(casFile)));</span>
        try{
<span class="fc" id="L170">        IOUtil.blockingSkip(dataIn, 16);</span>
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">        for(int i=0; callback.keepParsing() &amp;&amp; i&lt;numberOfReads; i++){</span>
<span class="fc" id="L172">            byte info = dataIn.readByte();</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            boolean hasMatch= (info &amp; 0x01)!=0;</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            boolean hasMultipleMatches= (info &amp; 0x02)!=0;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            boolean hasMultipleAlignments= (info &amp; 0x04)!=0;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            boolean isPartOfPair= (info &amp; 0x08)!=0;</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">            long totalNumberOfMatches=hasMatch?1:0, numberOfReportedAlignments=hasMatch?1:0;</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            if(hasMultipleMatches){                </span>
<span class="nc" id="L179">                totalNumberOfMatches = CasUtil.parseByteCountFrom(dataIn) +2;</span>
            }
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if(hasMultipleAlignments){</span>
<span class="nc" id="L182">                numberOfReportedAlignments = CasUtil.parseByteCountFrom(dataIn) +2;</span>
            }
            
<span class="fc" id="L185">            int score=0;</span>
<span class="fc" id="L186">            CasAlignment chosenAlignment=null;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if(hasMatch){</span>
           
<span class="fc" id="L189">                long numberOfBytesInForThisMatch =CasUtil.parseByteCountFrom(dataIn);</span>
<span class="fc" id="L190">                long contigSequenceId = CasUtil.readCasUnsignedInt(dataIn, this.numberOfBytesForContigNumber);</span>
<span class="fc" id="L191">                long startPosition = CasUtil.readCasUnsignedInt(dataIn, this.numberOfBytesForContigPosition);</span>
<span class="fc" id="L192">                boolean isreverse = dataIn.readBoolean();</span>
<span class="fc" id="L193">                DefaultCasAlignment.Builder builder = new DefaultCasAlignment.Builder(</span>
                                                    contigSequenceId, startPosition, 
                                                    isreverse);
<span class="fc" id="L196">                long count=0;</span>
                
<span class="fc bfc" id="L198" title="All 2 branches covered.">                while(count &lt;numberOfBytesInForThisMatch){</span>
<span class="fc" id="L199">                    short matchValue = CasUtil.readCasUnsignedByte(dataIn);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">                    if(matchValue == 255){</span>
<span class="nc" id="L201">                        builder.addPhaseChange(dataIn.readByte());                        </span>
<span class="nc" id="L202">                        count++;</span>
                    }
<span class="fc bfc" id="L204" title="All 2 branches covered.">                    else if(matchValue&lt;128){</span>
<span class="fc" id="L205">                        builder.addRegion(CasAlignmentRegionType.MATCH_MISMATCH, matchValue +1);                        </span>
                    }
<span class="fc bfc" id="L207" title="All 2 branches covered.">                    else if(matchValue&lt;192){</span>
<span class="fc" id="L208">                        builder.addRegion(CasAlignmentRegionType.INSERT, matchValue -127);</span>
                    }
                    else{
<span class="fc" id="L211">                        builder.addRegion(CasAlignmentRegionType.DELETION, matchValue -191);</span>
                    }
<span class="fc" id="L213">                    count++;</span>
<span class="fc" id="L214">                }</span>
<span class="fc" id="L215">                chosenAlignment =builder.build();</span>
            }
<span class="fc" id="L217">            visitor.visitMatch(new DefaultCasMatch(hasMatch, totalNumberOfMatches, numberOfReportedAlignments,</span>
                    isPartOfPair, chosenAlignment,score));
        }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if(callback.keepParsing()){</span>
<span class="fc" id="L221">        	visitor.visitEnd();</span>
        }else{
<span class="nc" id="L223">        	visitor.halted();</span>
        }
        }finally{
<span class="pc" id="L226">            IOUtil.closeAndIgnoreErrors(dataIn);</span>
<span class="fc" id="L227">        }</span>
        
<span class="fc" id="L229">    }</span>
   
    private void parseMetaData(CasFileVisitor visitor) throws IOException {
<span class="fc" id="L232">    	RandomAccessFile randomAccessFile = new RandomAccessFile(casFile,&quot;r&quot;);</span>
<span class="fc" id="L233">    	RandomAccessFileInputStream in=null;</span>
    	try{
<span class="fc" id="L235">			in = new RandomAccessFileInputStream(randomAccessFile);</span>
<span class="fc" id="L236">			byte[] magicNumber = IOUtil.toByteArray(in, 8);</span>
<span class="fc" id="L237">			CasNumberParserStrategy strategy = CasNumberParserStrategy.valueOf(magicNumber);</span>
			// the cas file puts the header at the end of the file
			// perhaps to make it easier to modify later?
			// so we have to skip over all the matches (possibly gigabytes of
			// data)
<span class="fc" id="L242">			BigInteger headerOffset = CasUtil.readCasUnsignedLong(in);</span>
<span class="fc" id="L243">			randomAccessFile.seek(headerOffset.longValue());</span>

<span class="fc" id="L245">			long numberOfContigSequences = parseMetadata(visitor, in, strategy);</span>
<span class="fc" id="L246">			parseProgramInfo(visitor, in);</span>

<span class="fc" id="L248">			parseReferenceFiles(visitor, in, strategy);</span>

<span class="fc" id="L250">			parseReadFiles(visitor, in, strategy);</span>

<span class="fc" id="L252">			parseScore(visitor, in, numberOfContigSequences);</span>
    	 
    	}finally{
<span class="pc" id="L255">    		IOUtil.closeAndIgnoreErrors(in, randomAccessFile);</span>
<span class="fc" id="L256">    	}</span>
        
        
<span class="fc" id="L259">    }</span>

	private void parseScore(CasFileVisitor visitor,
			RandomAccessFileInputStream in, long numberOfContigSequences)
			throws IOException {
<span class="fc" id="L264">		CasScoreType scoreType = CasScoreType.valueOf((byte) in.read());</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">		if (scoreType != CasScoreType.NO_SCORE) {</span>
<span class="fc" id="L266">			CasAlignmentScoreBuilder alignmentScoreBuilder = new CasAlignmentScoreBuilder()</span>
<span class="fc" id="L267">					.firstInsertion(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L268">					.insertionExtension(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L269">					.firstDeletion(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L270">					.deletionExtension(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L271">					.match(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L272">					.transition(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L273">					.transversion(CasUtil.readCasUnsignedShort(in))</span>
<span class="fc" id="L274">					.unknown(CasUtil.readCasUnsignedShort(in));</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">			if (scoreType == CasScoreType.COLOR_SPACE_SCORE) {</span>
<span class="fc" id="L276">				alignmentScoreBuilder.colorSpaceError(IOUtil</span>
<span class="fc" id="L277">						.readUnsignedShort(in));</span>
			}
<span class="fc" id="L279">			CasAlignmentScore score = alignmentScoreBuilder.build();</span>
<span class="fc" id="L280">			CasAlignmentType alignmentType = CasAlignmentType</span>
<span class="fc" id="L281">					.valueOf((byte) in.read());</span>
<span class="fc" id="L282">			scoringScheme = new DefaultCasScoringScheme(scoreType, score,</span>
					alignmentType);
<span class="fc" id="L284">			visitor.visitScoringScheme(scoringScheme);</span>
<span class="fc" id="L285">			long maxContigLength = 0;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">			for (long i = 0; i &lt; numberOfContigSequences; i++) {</span>
<span class="fc" id="L287">				long contigLength = CasUtil.readCasUnsignedInt(in);</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">				boolean isCircular = (IOUtil.readUnsignedShort(in) &amp; 0x01) == 1;</span>
<span class="fc" id="L289">				visitor.visitReferenceDescription(new DefaultCasReferenceDescription(</span>
						contigLength, isCircular));
<span class="fc" id="L291">				maxContigLength = Math.max(maxContigLength, contigLength);</span>
			}
<span class="fc" id="L293">			numberOfBytesForContigNumber = CasUtil</span>
<span class="fc" id="L294">					.numberOfBytesRequiredFor(numberOfContigSequences);</span>

<span class="fc" id="L296">			numberOfBytesForContigPosition = CasUtil</span>
<span class="fc" id="L297">					.numberOfBytesRequiredFor(maxContigLength);</span>
			// contig pairs not currently used so ignore them

		}
<span class="fc" id="L301">	}</span>

	private void parseReadFiles(CasFileVisitor visitor,
			RandomAccessFileInputStream in, CasNumberParserStrategy strategy) throws IOException {
<span class="fc" id="L305">		long numberOfReadFiles = CasUtil.parseByteCountFrom(in);</span>
<span class="fc" id="L306">		visitor.visitNumberOfReadFiles(numberOfReadFiles);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">		for (long i = 0; i &lt; numberOfReadFiles; i++) {</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">			boolean twoFiles = (in.read() &amp; 0x01) == 1;</span>
<span class="fc" id="L309">			long numberOfSequencesInFile = strategy.parseNumber(in);</span>
			
<span class="fc" id="L311">			BigInteger residuesInFile = CasUtil.readCasUnsignedLong(in);</span>
<span class="fc" id="L312">			List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L313">			names.add(CasUtil.parseCasStringFrom(in));</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">			if (twoFiles) {</span>
<span class="nc" id="L315">				names.add(CasUtil.parseCasStringFrom(in));</span>
			}
<span class="fc" id="L317">			visitor.visitReadFileInfo(new DefaultCasFileInfo(names,</span>
					numberOfSequencesInFile, residuesInFile));
		}
<span class="fc" id="L320">	}</span>

	private void parseReferenceFiles(CasFileVisitor visitor,
			RandomAccessFileInputStream in, CasNumberParserStrategy strategy) throws IOException {
<span class="fc" id="L324">		long numberOfContigFiles = CasUtil.parseByteCountFrom(in);</span>
<span class="fc" id="L325">		visitor.visitNumberOfReferenceFiles(numberOfContigFiles);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">		for (long i = 0; i &lt; numberOfContigFiles; i++) {</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">			boolean twoFiles = (in.read() &amp; 0x01) == 1;</span>
<span class="fc" id="L328">			long numberOfSequencesInFile = strategy.parseNumber(in);</span>
<span class="fc" id="L329">			BigInteger residuesInFile = CasUtil.readCasUnsignedLong(in);</span>
<span class="fc" id="L330">			List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L331">			names.add(CasUtil.parseCasStringFrom(in));</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">			if (twoFiles) {</span>
<span class="nc" id="L333">				names.add(CasUtil.parseCasStringFrom(in));</span>
			}
<span class="fc" id="L335">			visitor.visitReferenceFileInfo(new DefaultCasFileInfo(names,</span>
					numberOfSequencesInFile, residuesInFile));
		}
<span class="fc" id="L338">	}</span>

	private long parseMetadata(CasFileVisitor visitor,
			RandomAccessFileInputStream in, CasNumberParserStrategy strategy) throws IOException {
<span class="fc" id="L342">		long numberOfContigSequences = CasUtil.readCasUnsignedInt(in);</span>
<span class="fc" id="L343">		numberOfReads = strategy.parseNumber(in);</span>
		
<span class="fc" id="L345">		visitor.visitMetaData(numberOfContigSequences, numberOfReads);</span>
<span class="fc" id="L346">		return numberOfContigSequences;</span>
	}

	private void parseProgramInfo(CasFileVisitor visitor,
			RandomAccessFileInputStream in) throws IOException {
<span class="fc" id="L351">		String nameOfAssemblyProgram = CasUtil.parseCasStringFrom(in);</span>
<span class="fc" id="L352">		String version = CasUtil.parseCasStringFrom(in);</span>
<span class="fc" id="L353">		String parameters = CasUtil.parseCasStringFrom(in);</span>
<span class="fc" id="L354">		visitor.visitAssemblyProgramInfo(nameOfAssemblyProgram, version,</span>
				parameters);
<span class="fc" id="L356">	}</span>

    
   
    
    
<span class="fc" id="L362">    private static final class CasVisitorCallbackImpl implements CasVisitorCallback{</span>
<span class="fc" id="L363">    	private final AtomicBoolean keepParsing = new AtomicBoolean(true);</span>
		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L366">			return false;</span>
		}

		@Override
		public CasVisitorMemento createMemento() {
<span class="nc" id="L371">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
		}

		@Override
		public void haltParsing() {
<span class="nc" id="L376">			keepParsing.set(false);			</span>
<span class="nc" id="L377">		}</span>
		
		public boolean keepParsing(){
<span class="fc" id="L380">			return keepParsing.get();</span>
		}
    	
    }
    /**
     * {@code CasNumberParserStrategy} is a Strategy
     * object to handle how different versions of cas files
     * need to parse numbers differently.  Over the years,
     * the different CLC programs have created different
     * versions of cas files which store numbers
     * differently.
     * 
     * @author dkatzel
     *
     */
<span class="pc" id="L395">    private enum CasNumberParserStrategy{</span>
    	/**
    	 * The original version of cas files
    	 * created by the clc_ref_assemble_X programs
    	 * used unsigned ints
    	 * to store numbers (max number is 2^32-1).
    	 */
<span class="fc" id="L402">    	REF_ASSEMBLE{</span>

			@Override
			public long parseNumber(RandomAccessFileInputStream in)
					throws IOException {
<span class="fc" id="L407">				return CasUtil.readCasUnsignedInt(in);</span>
			}
    		
    	},
    	/**
    	 * The version of cas files
    	 * created by the clc_mapper program
    	 * uses unsigned longs
    	 * to store numbers (max number is 2^64-1).
    	 */
<span class="fc" id="L417">    	MAPPER{</span>
    		@Override
			public long parseNumber(RandomAccessFileInputStream in)
					throws IOException {
<span class="fc" id="L421">    			return CasUtil.readCasUnsignedLong(in).longValue();</span>
			}
    	};
    	
    	public abstract long parseNumber(RandomAccessFileInputStream in) throws IOException;
    	
    	/**
    	 * Get the {@link CasNumberParserStrategy} instance to use
    	 * based on the cas file's magic number.
    	 * @param magicNumber the first 8 bytes in a cas file.
    	 * @return a {@link CasNumberParserStrategy} instance;
    	 * will never be null.
    	 */
    	public static CasNumberParserStrategy valueOf(byte[] magicNumber){
        	
<span class="fc bfc" id="L436" title="All 2 branches covered.">        	for(int i=0; i&lt;CAS_MAGIC_NUMBER_PREFIX.length; i++){</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        		if(CAS_MAGIC_NUMBER_PREFIX[i] != magicNumber[i]){</span>
<span class="nc" id="L438">        			 throw new IllegalArgumentException(&quot;input stream not a valid cas file wrong magic number expected : &quot; + Arrays.toString(CAS_MAGIC_NUMBER_PREFIX) + &quot; but was &quot;+Arrays.toString(magicNumber));</span>
        		      
        		}
        	}
<span class="pc bpc" id="L442" title="1 of 3 branches missed.">        	switch(magicNumber[7]){</span>
<span class="fc" id="L443">	        	case 1: return REF_ASSEMBLE;</span>
<span class="fc" id="L444">	        	case 3 : return MAPPER;</span>
	        	default :
<span class="nc" id="L446">	        		throw new IllegalArgumentException(&quot;unknown cas file format version magic number = &quot;+ Arrays.toString(magicNumber));</span>
        	}
        	
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>