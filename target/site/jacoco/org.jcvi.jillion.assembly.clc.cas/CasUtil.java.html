<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CasUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.clc.cas</a> &gt; <span class="el_source">CasUtil.java</span></div><h1>CasUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Oct 27, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.clc.cas;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.nio.ByteOrder;
import java.nio.charset.Charset;

import org.jcvi.jillion.core.io.IOUtil;
/**
 * {@code CasUtil} is a utility class for dealing with the binary
 * encodings inside a .cas file.
 * @author dkatzel
 *
 *
 */
public final class CasUtil {

<span class="fc" id="L46">    private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span>
    
<span class="nc" id="L48">    private CasUtil(){}</span>
    /**
     * Get the number of bytes required to store the given number.
     * To save space, .cas files use a varible length field to 
     * store counters.  The length of the field depends on the max number
     * to be stored.
     * @param i the number to store.
     * @return the number of bytes needed to store the given 
     * input number as an int (which may be {@code 0}).
     * @throws IllegalArgumentException if {@code i&lt;1}.
     */
    static int numberOfBytesRequiredFor(long i){
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if(i &lt; 1){</span>
<span class="fc" id="L61">            throw new IllegalArgumentException(&quot;input number must be &gt; 0 : &quot; + i);</span>
        }
       
<span class="fc" id="L64">        return (int)Math.ceil(Math.log(i)/Math.log(256));</span>
    }
    /**
     * Parse a byte count from the given {@link InputStream}.
     * To save space, CAS files have a variable length field for byte counts
     * which range from 1 to 5 bytes long.
     * @param in the inputstream to read.
     * @return a byte count as a long; should always be &gt;=0.
     * @throws IOException if there is a problem reading from the inputstream
     * @throws NullPointerException if {@code in == null}.
     */
    static long parseByteCountFrom(InputStream in) throws IOException{
        
<span class="fc" id="L77">        int firstByte =in.read();</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if(firstByte&lt;254){</span>
<span class="fc" id="L79">            return firstByte;</span>
        }
        
<span class="fc bfc" id="L82" title="All 2 branches covered.">        if(firstByte ==254){</span>
            //read next 2 bytes
<span class="fc" id="L84">           return readCasUnsignedShort(in);</span>
        }
<span class="fc" id="L86">        return readCasUnsignedInt(in);</span>
    }
    /**
     * parse a CAS encoded String from the given {@link InputStream}.
     * CAS files store strings in Pascal like format with 
     * the number of bytes in the string first, followed by the
     * characters in the string, there is no terminating character.
     * @param in the inputstream to parse.
     * @return the next String in the InputStream.
     * @throws IOException if there is a problem reading the String.
     * @throws NullPointerException if {@code in == null}.
     */
    static String parseCasStringFrom(InputStream in) throws IOException{
<span class="fc" id="L99">        int length = (int)parseByteCountFrom(in);</span>
       
<span class="fc" id="L101">        byte bytes[] = IOUtil.toByteArray(in, length);</span>
        
<span class="fc" id="L103">        return new String(bytes, UTF_8);</span>
        
    }
    /**
     * Read the next unsigned byte in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned byte as a short.
     * @throws IOException if there is a problem reading the inputStream.
     */
    static short readCasUnsignedByte(InputStream in) throws IOException{
<span class="fc" id="L114">    	return IOUtil.readUnsignedByte(in, ByteOrder.LITTLE_ENDIAN);</span>
     }
    /**
     * Read the next unsigned short in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned short as an int.
     * @throws IOException if there is a problem reading the inputStream.
     */
    static int readCasUnsignedShort(InputStream in) throws IOException{
<span class="fc" id="L124">    	return IOUtil.readUnsignedShort(in, ByteOrder.LITTLE_ENDIAN);</span>
     }
    /**
     * Read the next unsigned int in the given inputStream.
     * this is the same as {@link #readCasUnsignedInt(InputStream, int)
     * readCasUnsignedInt(in,4)}
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned int as an long.
     * @throws IOException if there is a problem reading the inputStream.
     * @see #readCasUnsignedInt(InputStream, int)
     */
    static long readCasUnsignedInt(InputStream in) throws IOException{
<span class="fc" id="L137">       return readCasUnsignedInt(in, 4);</span>
    }
    /**
     * Read the next X bytes as an unsigned int in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @param numberOfBytesInNumber number of bytes to read from the inputStream.
     * @return an unsigned int as an long.
     * @throws IOException if there is a problem reading the inputStream.
     * @see #readCasUnsignedInt(InputStream, int)
     */
    static long readCasUnsignedInt(InputStream in, int numberOfBytesInNumber) throws IOException{
<span class="fc" id="L149">    	byte[] array =IOUtil.readByteArray(in, numberOfBytesInNumber);</span>
<span class="fc" id="L150">    	array = IOUtil.switchEndian(array);    	</span>
<span class="fc" id="L151">    	return new BigInteger(1,array).longValue();</span>
     }
    /**
     * Read the next unsigned long in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned long as an {@link BigInteger}; never null.
     * @throws IOException if there is a problem reading the inputStream.
     */
    static BigInteger readCasUnsignedLong(InputStream in) throws IOException{
<span class="fc" id="L161">    	return IOUtil.readUnsignedLong(in,ByteOrder.LITTLE_ENDIAN);</span>
     }
    
    
   

    /**
     * Get the java File object for a filepath in a cas file.
     * @param workingDir the working directory this cas file was
     * created in (usually the same location as the cas file itself);
     * If workingDir is {@code null}, then the working dir is the 
     * current directory.
     * @param filePath the path to the file which may or may not
     * be relative.
     * @return a new File object that represents the file.
     * @throws FileNotFoundException if the file does not exist.
     * @throws NullPointerException if filePath is null.
     */
    public static File getFileFor(File workingDir,String filePath) throws FileNotFoundException {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">    	if(filePath ==null){</span>
<span class="nc" id="L181">    		throw new NullPointerException(&quot;filePath can not be null&quot;);</span>
    	}
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        boolean isAbsolutePath = filePath.charAt(0) == File.separatorChar;</span>
        final File dataStoreFile;
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if(isAbsolutePath){</span>
<span class="nc" id="L186">            dataStoreFile = new File(filePath);</span>
        }else{
<span class="fc" id="L188">            dataStoreFile = new File(workingDir, filePath);</span>
        }            
         
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if(!dataStoreFile.exists()){</span>
<span class="nc" id="L192">            throw new FileNotFoundException(dataStoreFile.getAbsolutePath());</span>
        }
<span class="fc" id="L194">        return dataStoreFile;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>