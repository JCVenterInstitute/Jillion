<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BamIndexFileWriterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam.index</a> &gt; <span class="el_source">BamIndexFileWriterBuilder.java</span></div><h1>BamIndexFileWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam.index;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.jcvi.jillion.core.io.FileUtil;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.sam.index.BamIndexer;
import org.jcvi.jillion.internal.sam.index.IndexUtil;
import org.jcvi.jillion.sam.SamParser;
import org.jcvi.jillion.sam.SamParserFactory;
import org.jcvi.jillion.sam.SamRecord;
import org.jcvi.jillion.sam.SamVisitor;
import org.jcvi.jillion.sam.SortOrder;
import org.jcvi.jillion.sam.VirtualFileOffset;
import org.jcvi.jillion.sam.header.SamHeader;
/**
 * {@code BamIndexFileWriterBuilder}
 * is a class that will create a BAM
 * index file from a sorted BAM input file.
 * @author dkatzel
 *
 */
public final class BamIndexFileWriterBuilder {

	
<span class="fc" id="L51">	private boolean includeMetaData=false;</span>
<span class="fc" id="L52">	private boolean assumeSorted=false;</span>
	
	private File outputBaiFile, inputBamFile;
	
	/**
	 * Create a new Builder instance with the given input BAM that
	 * will write a Bam index file to the same directory as the
	 * input bam and name it {@code inputBamFile.getName() +&quot;.bai&quot;}.
	 * 
	 * @apiNote this is the same as
	 * {@link #BamIndexFileWriterBuilder(File, File) new BamIndexFileWriterBuilder(inputBamFile, new File(inputBamFile.getParentFile(), inputBamFile.getName() +&quot;.bai&quot;))}
	 * 
	 * @param inputBamFile the input BAM file to parse and create
	 * 			an index from; can not be null, must exist
	 * 			and end with {@literal &quot;.bam&quot;}.
	 * @throws IOException if there are any problems creating any missing output files or if the
	 * input BAM file does not exist.
	 * 
	 * @throws NullPointerException if inputBamFile is null.
	 * @throws IllegalArgumentException if the file extensions aren't correct.
	 * 
	 * @see #BamIndexFileWriterBuilder(File, File)
	 * 
	 * @since 5.0
	 */
	public BamIndexFileWriterBuilder(File inputBamFile) throws IOException{
<span class="nc" id="L78">		this(inputBamFile, new File(inputBamFile.getParentFile(), inputBamFile.getName() +&quot;.bai&quot;));</span>
<span class="nc" id="L79">	}</span>
	/**
	 * Create a new Builder instance with the given input BAM and 
	 * output index files.
	 * @param inputBamFile the input BAM file to parse and create
	 * 			an index from; can not be null, must exist
	 * 			and end with {@literal &quot;.bam&quot;}.
	 * @param outputBaiFile the output BAM index file to write; can not be null
	 * 			and end with {@literal &quot;.bai&quot;}. If the output path does not exist,
	 * 			then the file and any non-existent parent directories will be created.
	 * @throws IOException if there are any problems creating any missing output files
	 * 			or directories or if the input BAM file does not exist.
	 * @throws NullPointerException if any parameter is null.
	 * @throws IllegalArgumentException if the file extensions aren't correct.
	 */
<span class="fc" id="L94">	public BamIndexFileWriterBuilder(File inputBamFile, File outputBaiFile) throws IOException{</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		if(inputBamFile == null){</span>
<span class="fc" id="L96">			throw new NullPointerException(&quot;input bam file can not be null&quot;);</span>
		}
<span class="fc bfc" id="L98" title="All 2 branches covered.">		if(outputBaiFile == null){</span>
<span class="fc" id="L99">			throw new NullPointerException(&quot;output bai file can not be null&quot;);</span>
		}
		
<span class="fc bfc" id="L102" title="All 2 branches covered.">		if(!&quot;bam&quot;.equalsIgnoreCase(FileUtil.getExtension(inputBamFile))){</span>
<span class="fc" id="L103">			throw new IllegalArgumentException(&quot;input file is not a bam file &quot; + inputBamFile.getAbsolutePath());</span>
		}
<span class="fc bfc" id="L105" title="All 2 branches covered.">		if(!&quot;bai&quot;.equalsIgnoreCase(FileUtil.getExtension(outputBaiFile))){</span>
<span class="fc" id="L106">			throw new IllegalArgumentException(&quot;input file is not a bai file &quot; + outputBaiFile.getAbsolutePath());</span>
		}
<span class="fc bfc" id="L108" title="All 2 branches covered.">		if(!inputBamFile.exists()){</span>
<span class="fc" id="L109">			throw new FileNotFoundException(&quot;input bam file must exist &quot; + inputBamFile.getAbsolutePath());</span>
		}
<span class="fc" id="L111">		IOUtil.mkdirs(outputBaiFile.getParentFile());</span>
<span class="fc" id="L112">		this.inputBamFile = inputBamFile;</span>
<span class="fc" id="L113">		this.outputBaiFile = outputBaiFile;</span>
		
<span class="fc" id="L115">	}</span>
	/**
	 * Assume that the given input BAM file contains {@link SortOrder#COORDINATE} 
	 * sorted data even if the header says otherwise.  If not called,
	 * by default, this value is set to {@code false}.
	 * If this value is set to {@code false}, then during the {@link #build()}, the header
	 * of the input BAM is checked to make sure the sort order is set to 
	 * {@link SortOrder#COORDINATE} and will throw an {@link IllegalStateException}
	 * if it's not.
	 * @param assumeSorted {@code true} if the header should not be checked
	 * and assumed to be {@link SortOrder#COORDINATE}; {@code false} if the header
	 * should be checked and fail if not (the default).
	 * @return this.
	 */
	public BamIndexFileWriterBuilder assumeSorted(boolean assumeSorted){
<span class="nc" id="L130">		this.assumeSorted = assumeSorted;</span>
<span class="nc" id="L131">		return this;</span>
	}
	/**
	 * BAM Index files created by some other SAM libraries add additional
	 * metadata to the index such as the number of unaligned reads. This metadata
	 * is not specified in the BAM Index specification so some SAM parsers might not be able to correctly
	 * handle them.  If this method is not called, then by default, the metadata is not included.
	 *
	 * @param includeMetaData {@code true} if metadata should be included;
	 * {@code false} otherwise (the default).
	 * @return this.
	 */
	public BamIndexFileWriterBuilder includeMetaData(boolean includeMetaData){
<span class="fc" id="L144">		this.includeMetaData = includeMetaData;</span>
<span class="fc" id="L145">		return this;</span>
	}
	/**
	 * Actually parse the input BAM file and write out the corresponding
	 * BAM index file to the given output file.
	 * 
	 * @return the output indexed {@link File}
	 * (this is the same file as was passed into the constructor)
	 * @throws IOException if there are any problems parsing the 
	 * BAM file or writing out the index file.
	 * @throws IllegalStateException if the BAM file is not in {@link SortOrder#COORDINATE}
	 * order and {@link #assumeSorted(boolean)} is set to {@code false}.
	 */
	public File build() throws IOException{
<span class="fc" id="L159">		SamParser parser = SamParserFactory.create(inputBamFile);</span>
<span class="fc" id="L160">		BamIndexSamVisitor visitor = new BamIndexSamVisitor(assumeSorted);</span>
<span class="fc" id="L161">		parser.parse(visitor);</span>
		
<span class="fc" id="L163">		OutputStream out =null;</span>
		try{
<span class="fc" id="L165">			out = new BufferedOutputStream(new FileOutputStream(outputBaiFile));</span>
<span class="fc" id="L166">			IndexUtil.writeIndex(out, visitor.createBamIndex(), includeMetaData);</span>
<span class="fc" id="L167">			return outputBaiFile;</span>
		}finally{
<span class="pc" id="L169">			IOUtil.closeAndIgnoreErrors(out);</span>
		}
	}
	
	
	private static class BamIndexSamVisitor implements SamVisitor {
		private BamIndexer indexer;
		private final boolean assumeSorted;
		
		

<span class="fc" id="L180">		public BamIndexSamVisitor(boolean assumeSorted) {</span>
<span class="fc" id="L181">			this.assumeSorted = assumeSorted;</span>
<span class="fc" id="L182">		}</span>

		@Override
		public void visitRecord(SamVisitorCallback callback, SamRecord record,
				VirtualFileOffset start, VirtualFileOffset end) {
<span class="fc" id="L187">			indexer.addRecord(record, start, end);</span>
			
<span class="fc" id="L189">		}</span>
		
		
		@Override
		public void visitHeader(SamVisitorCallback callback, SamHeader header) {
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">			if(!assumeSorted &amp;&amp; !header.getSortOrder().equals(SortOrder.COORDINATE)){</span>
<span class="fc" id="L195">				throw new IllegalStateException(&quot;bam file not in coordinate sort order : &quot; + header.getSortOrder());</span>
			}
<span class="fc" id="L197">			indexer = new BamIndexer(header);</span>
<span class="fc" id="L198">		}</span>
		
		@Override
		public void visitEnd() {
			//no-op
<span class="fc" id="L203">		}</span>
		
		@Override
		public void halted() {
			//no-op
<span class="nc" id="L208">		}</span>
		
		public BamIndex createBamIndex(){
<span class="fc" id="L211">			return indexer.createBamIndex();</span>
		}
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>