<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BamIndex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam.index</a> &gt; <span class="el_source">BamIndex.java</span></div><h1>BamIndex.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam.index;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.util.MapUtil;
import org.jcvi.jillion.internal.sam.index.IndexUtil;
import org.jcvi.jillion.sam.AbstractSamVisitor;
import org.jcvi.jillion.sam.SamParserFactory;
import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamReferenceSequence;
/**
 * {@code BamIndex} is an object representation 
 * of an entire BAM index ({@literal .bai}) file.
 * @author dkatzel
 *
 */
public final class BamIndex {

	private final Map&lt;String, Integer&gt; indexOfRefNames;
	
	private final List&lt;ReferenceIndex&gt; indexes;
	
	private final Long totalNumberOfUnmappedReads;
	/**
	 * Create a new {@link BamIndex} instance 
	 * using the given sorted BAM file and corresponding
	 * BAM index file.  The sort
	 * order is assumed to be in {@link org.jcvi.jillion.sam.SortOrder#COORDINATE}
	 * even if the header says otherwise.
	 * Only the header is parsed from the BAM file to get header information.
	 * @param bam the BAM file to parse; file must exist.
	 * @param bai the BAM index file to parse; file must exist.  It is 
	 * assumed that the index corresponds to the the data in the BAM file.
	 * @return a new {@link BamIndex} instance; will never be null.
	 * @throws IOException if there is a problem parsing either file.
	 */
	public static BamIndex createFromFiles(File bam, File bai) throws IOException{
<span class="fc" id="L68">		SamHeaderParser headerParser = new SamHeaderParser();</span>
<span class="fc" id="L69">		SamParserFactory.create(bam).parse(headerParser);</span>
<span class="fc" id="L70">		SamHeader header = headerParser.getHeader();</span>
		
<span class="fc" id="L72">		InputStream in=null;</span>
		try{
<span class="fc" id="L74">			in = new BufferedInputStream(new FileInputStream(bai));</span>
<span class="fc" id="L75">			return IndexUtil.parseIndex(in, header);</span>
		}finally{
<span class="pc" id="L77">			IOUtil.closeAndIgnoreErrors(in);;</span>
		}
	}
	/**
	 * {@link SamVisitor} that just gets the {@link SamHeader}
	 * from the BAM file since that's all we need.
	 * @author dkatzel
	 *
	 */
<span class="fc" id="L86">	private static class SamHeaderParser extends AbstractSamVisitor{</span>
		private SamHeader header;
		
		@Override
		public void visitHeader(SamVisitorCallback callback, SamHeader header) {
<span class="fc" id="L91">			this.header = header;</span>
			//since we only need the header we can stop
			//parsing the BAM now before we get 
			//to any SAMRecords.
<span class="fc" id="L95">			callback.haltParsing();</span>
			
<span class="fc" id="L97">		}</span>

		public SamHeader getHeader() {
<span class="fc" id="L100">			return header;</span>
		}
		
	}
	/**
	 * Convenience constructor with null total number of reads.
	 * This is the same as {@link #BamIndex(SamHeader,List,Long) new BamIndex(header, indexes, null)}.
	 * @param header the {@link SamHeader} to use; can not be null.
	 * The order of the {@link ReferenceSequence}s must match the order of the {@link ReferenceIndex}
	 * list.
	 * @param indexes the List of {@link ReferenceIndex} to use; can not be null, but may be empty if
	 * no reads mapped.
	 * @see #BamIndex(SamHeader,List,Long)
	 * @throws NullPointerException if either header or indexes are null.
	 */
	public BamIndex(SamHeader header, List&lt;ReferenceIndex&gt; indexes){
<span class="nc" id="L116">		this(header, indexes, null);</span>
<span class="nc" id="L117">	}</span>
	/**
	 * Create a new {@link BamIndex} instance that uses the given {@link SamHeader},
	 * ordered list of {@link ReferenceIndex}es and optional total number of unmapped
	 * reads.
	 * @param header the {@link SamHeader} to use; can not be null.
	 * The order of the {@link ReferenceSequence}s must match the order of the {@link ReferenceIndex}
	 * list.
	 * @param indexes the List of {@link ReferenceIndex} to use; can not be null, but may be empty if
	 * no reads mapped.
	 * @param totalNumberOfUnmappedReads optional total number of unmapped reads, only used for metadata collection,
	 * this value may be {@code null} if the value is unknown.
	 * @throws NullPointerException if either header or indexes are null.
	 */
<span class="fc" id="L131">	public BamIndex(SamHeader header, List&lt;ReferenceIndex&gt; indexes, Long totalNumberOfUnmappedReads){</span>
<span class="fc" id="L132">		int refIndex=0;</span>
<span class="fc" id="L133">		Collection&lt;SamReferenceSequence&gt; referenceSequences = header.getReferenceSequences();</span>
<span class="fc" id="L134">		indexOfRefNames = new HashMap&lt;String, Integer&gt;(MapUtil.computeMinHashMapSizeWithoutRehashing(referenceSequences.size()));</span>
		
<span class="fc bfc" id="L136" title="All 2 branches covered.">		for(SamReferenceSequence ref :referenceSequences){</span>
<span class="fc" id="L137">			indexOfRefNames.put(ref.getName(), refIndex);</span>
<span class="fc" id="L138">			refIndex++;</span>
<span class="fc" id="L139">		}</span>
		
<span class="fc" id="L141">		this.indexes = new ArrayList&lt;ReferenceIndex&gt;(indexes);</span>
<span class="fc" id="L142">		this.totalNumberOfUnmappedReads = totalNumberOfUnmappedReads;</span>
<span class="fc" id="L143">	}</span>
	
	/**
	 * Get the {@link ReferenceIndex} by the order given in the 
	 * header.
	 * @param i the ith {@link ReferenceIndex} to get;
	 * must be 0 &lt;=i &lt; {@link #getNumberOfReferenceIndexes()}
	 * @return the selected {@link ReferenceIndex} will never be null.
	 * @throws IndexOutOfBoundsException if i is not &lt;0 or &gt;= {@link #getNumberOfReferenceIndexes()}.
	 */
	public ReferenceIndex getReferenceIndex(int i){
<span class="fc" id="L154">		return indexes.get(i);</span>
	}
	/**
	 * Get the Integer offset for this Reference by its name
	 * as determined by {@link ReferenceSequence#getName()}.
	 * This return value can then be used in {@link #getReferenceIndex(int)}.
	 * 
	 * @param refName the refName to get, can not be null;
	 * @return an {@link Integer} or {@code null}
	 * if there is no {@link ReferenceIndex} with that name.
	 * @throws NullPointerException if refName is null.
	 */
	public Integer getReferenceIndexOffset(String refName){
<span class="nc bnc" id="L167" title="All 2 branches missed.">		if(refName ==null){</span>
<span class="nc" id="L168">			throw new NullPointerException(&quot;refName can not be null&quot;);</span>
		}
			
<span class="nc" id="L171">		return indexOfRefNames.get(refName);</span>
	}
	
	/**
	 * Get the number of {@link ReferenceIndex}es 
	 * in this bam index.
	 * @return an int &gt;=0.
	 */
	public int getNumberOfReferenceIndexes(){
<span class="fc" id="L180">		return indexes.size();</span>
	}
	/**
	 * Get the {@link ReferenceIndex} by its name
	 * as determined by {@link ReferenceSequence#getName()}.
	 * @param refName the refName to get, can not be null;
	 * @return a {@link ReferenceIndex} or {@code null}
	 * if there is no {@link ReferenceIndex} with that name.
	 * @throws NullPointerException if refName is null.
	 */
	public ReferenceIndex getReferenceIndex(String refName){
			
<span class="nc" id="L192">		Integer i = getReferenceIndexOffset(refName);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">		if(i==null){</span>
<span class="nc" id="L194">			return null;</span>
		}
<span class="nc" id="L196">		return indexes.get(i);</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L201">		final int prime = 31;</span>
<span class="nc" id="L202">		int result = 1;</span>
<span class="nc" id="L203">		result = prime * result	+  indexOfRefNames.hashCode();</span>
<span class="nc" id="L204">		result = prime * result + indexes.hashCode();</span>
<span class="nc" id="L205">		return result;</span>
	}
	/**
	 * Two {@link BamIndex}es are equal if they have the 
	 * same {@link ReferenceIndex}es in the same order
	 * and the same names to the {@link ReferenceIndex}.
	 * &lt;br/&gt;
	 * &lt;strong&gt;Note:&lt;/strong&gt; Since {@link #getTotalNumberOfUnmappedReads()}
	 * is optional, it is not used in equality comparisons.
	 * {@inheritDoc}
	 */
	@Override
	public boolean equals(Object obj) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">		if (this == obj) {</span>
<span class="nc" id="L219">			return true;</span>
		}
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L222">			return false;</span>
		}
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (!(obj instanceof BamIndex)) {</span>
<span class="nc" id="L225">			return false;</span>
		}
<span class="nc" id="L227">		BamIndex other = (BamIndex) obj;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">		if (!indexOfRefNames.equals(other.indexOfRefNames)) {</span>
<span class="nc" id="L229">			return false;</span>
		}
<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (!indexes.equals(other.indexes)) {</span>
<span class="nc" id="L232">			return false;</span>
		}
<span class="nc" id="L234">		return true;</span>
	}
	/**
	 * Get the optionally provided total number of unmapped reads
	 * which some BamIndexes include as part of
	 * metadata.
	 * @return the number as a Long or {@code null}
	 * if the value is not available.
	 */
	public Long getTotalNumberOfUnmappedReads() {
<span class="fc" id="L244">		return totalNumberOfUnmappedReads;</span>
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>