<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XmlFileBlastParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.experimental.align.blast</a> &gt; <span class="el_source">XmlFileBlastParser.java</span></div><h1>XmlFileBlastParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.experimental.align.blast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.math.BigDecimal;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.jcvi.jillion.core.DirectedRange;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.residue.aa.AminoAcid;
import org.jcvi.jillion.core.residue.aa.ProteinSequence;
import org.jcvi.jillion.core.residue.aa.ProteinSequenceBuilder;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * {@code XmlFileBlastParser} is a {@link BlastParser}
 * implementation that can parse XML formatted 
 * Blast output (-m 7).  This class should work
 * on both nucleotide and protein alignments.
 * 
 * @author dkatzel
 *
 *
 */
public final class XmlFileBlastParser implements BlastParser{

	private final SAXParser parser;
	private OpenAwareInputStream inputStream;
	private File file;
	
	
	public static BlastParser create(File xml) throws IOException{
<span class="fc" id="L68">		 SAXParser parser = createSaxParser();</span>
<span class="fc" id="L69">		 return new XmlFileBlastParser(parser, xml);</span>
	}
	
	public static BlastParser create(InputStream xml) throws IOException{
<span class="nc" id="L73">		 SAXParser parser = createSaxParser();</span>
<span class="nc" id="L74">		 return new XmlFileBlastParser(parser, xml);</span>
	}

	private static SAXParser createSaxParser() throws IOException {
<span class="fc" id="L78">		SAXParserFactory spf = SAXParserFactory.newInstance();</span>
<span class="fc" id="L79">		spf.setValidating(false);</span>
		 SAXParser parser;
		try {
<span class="fc" id="L82">			parser = spf.newSAXParser();</span>
<span class="nc" id="L83">		} catch (ParserConfigurationException e) {</span>
<span class="nc" id="L84">			throw new IOException(&quot;error creating SAX parser&quot;, e);</span>
<span class="nc" id="L85">		} catch (SAXException e) {</span>
<span class="nc" id="L86">			throw new IOException(&quot;error creating SAX parser&quot;, e);</span>
<span class="fc" id="L87">		}</span>
<span class="fc" id="L88">		return parser;</span>
	}
	
<span class="nc" id="L91">    private XmlFileBlastParser(SAXParser parser, InputStream inputStream){</span>
<span class="nc" id="L92">    	this.parser = parser;</span>
<span class="nc" id="L93">    	this.inputStream = new OpenAwareInputStream(inputStream);</span>
<span class="nc" id="L94">    }</span>
<span class="fc" id="L95">    private XmlFileBlastParser(SAXParser parser, File file){</span>
<span class="fc" id="L96">    	this.parser = parser;</span>
<span class="fc" id="L97">    	this.file = file;</span>
<span class="fc" id="L98">    }</span>
    
    
    
    @Override
	public boolean canParse() {
<span class="pc bpc" id="L104" title="3 of 4 branches missed.">		if(inputStream !=null &amp;&amp; !inputStream.isOpen()){</span>
<span class="nc" id="L105">			return false;</span>
		}
<span class="fc" id="L107">		return true;</span>
	}



	@Override
	public void parse(BlastVisitor visitor) throws IOException {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">		if(canParse()){</span>
			try {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">				if (inputStream == null) {				</span>
<span class="fc" id="L117">					parser.parse(file, new SaxBlastParser(visitor));</span>
				}else{
<span class="nc" id="L119">					parser.parse(inputStream, new SaxBlastParser(visitor));</span>
				}
<span class="nc" id="L121">			} catch (SAXException e) {</span>
<span class="nc" id="L122">				throw new IOException(&quot;error parsing xml blast output&quot;,e);</span>
<span class="fc" id="L123">			}</span>
		}
		
<span class="fc" id="L126">	}</span>



    
   
    
    private static class SaxBlastParser extends DefaultHandler{

    	private static final String HIT = &quot;Hit&quot;;
        private static final String HSP = &quot;Hsp&quot;;
        private static final String BIT_SCORE = &quot;Hsp_bit-score&quot;;
        private static final String E_VALUE = &quot;Hsp_evalue&quot;;
        private static final String HSP_SCORE = &quot;Hsp_score&quot;;
        private static final String ALIGN_LENGTH = &quot;Hsp_align-len&quot;;
        private static final String QUERY_FROM = &quot;Hsp_query-from&quot;;
        private static final String QUERY_TO = &quot;Hsp_query-to&quot;;
        private static final String HIT_FROM = &quot;Hsp_hit-from&quot;;
        private static final String HIT_TO = &quot;Hsp_hit-to&quot;;
        private static final String IDENTICAL_MATCHES = &quot;Hsp_identity&quot;;
        private static final String POSITIVE_MATCHES = &quot;Hsp_positive&quot;;
        private static final String NUM_GAPS = &quot;Hsp_gaps&quot;;
        private static final String HIT_FRAME = &quot;Hsp_hit-frame&quot;;
        
        
        
        private static final String SUBJECT_LENGTH = &quot;Hit_len&quot;;
        private static final String MIDLINE = &quot;Hsp_midline&quot;;
        
        
        private static final String QUERY_SEQUENCE = &quot;Hsp_qseq&quot;;
        private static final String SUBJECT_SEQUENCE = &quot;Hsp_hseq&quot;;
        private static final String SUBJECT_DEF = &quot;Hit_def&quot;;
         
<span class="fc" id="L160">        private static final Pattern DEFLINE_PATTERN = Pattern.compile(&quot;^\\s*(\\S+)\\s*(.*)$&quot;);</span>
        
        private static final String LEGACY_QUERY_ID = &quot;BlastOutput_query-def&quot;;
        
        private static final String PROGRAM_NAME = &quot;BlastOutput_program&quot;;
        private static final String PROGRAM_VERSION = &quot;BlastOutput_version&quot;;
        private static final String QUERY_LENGTH = &quot;BlastOutput_query-len&quot;;
        private static final String BLAST_DB = &quot;BlastOutput_db&quot;;
        
        private static final String BLAST_ITERATIONS = &quot;BlastOutput_iterations&quot;;
        
        private static final String ITERATION_QUERY_ID = &quot;Iteration_query-def&quot;;
        private static final String ITERATION_QUERY_LENGTH = &quot;Iteration_query-len&quot;;
        
        private static final String HIT_ACCESSION = &quot;Hit_accession&quot;;
        
        private HspBuilder&lt;?,?,?&gt; hspBuilder;
        private final BlastVisitor visitor;
<span class="fc" id="L178">        private String tempVal=null;</span>
<span class="fc" id="L179">        private StringBuilder tempBuilder =null;</span>
        private Integer queryStart, queryEnd, subjectStart,subjectEnd, queryLength, subjectLength, numMatches;
        private String queryId, subjectId;
        private String programName, programVersion, blastDb, subjectDeflineComment;
        
<span class="fc" id="L184">        int misMatches=0,numberOfGapOpenings=0;</span>
        Sequence&lt;?&gt; querySequence, subjectSequence;
<span class="fc" id="L186">        private boolean isNucleotide=false;</span>
        
<span class="fc" id="L188">        private boolean inHspBlock=false;</span>
        private BlastHitImpl.Builder hitBuilder;
        
<span class="fc" id="L191">        SaxBlastParser(BlastVisitor visitor){</span>
<span class="fc" id="L192">            this.visitor = visitor;</span>
<span class="fc" id="L193">        }</span>
        
        
        
        @Override
		public InputSource resolveEntity(String publicId, String systemId)
				throws IOException, SAXException {
			//for some stupid reason, SAXParser#parse()
        	//ignores our dtd validation settings
        	//
        	//so we have to override this method
        	//to do a NullObject dtd resolution and check
<span class="fc" id="L205">			return new InputSource(new StringReader(&quot;&quot;));</span>
		}
        
        /**
        * {@inheritDoc}
        */
        @Override
        public void startElement(String uri, String localName, String qName,
                Attributes attributes) throws SAXException {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        	if(BLAST_ITERATIONS.equals(qName)){</span>
<span class="fc" id="L215">        		reportBlastHeaderInfo();</span>
<span class="fc bfc" id="L216" title="All 4 branches covered.">        	}else if(HSP.equals(qName) &amp;&amp; !inHspBlock){</span>
        		
<span class="fc" id="L218">        		inHspBlock =true;</span>
<span class="fc" id="L219">        		hitBuilder = new BlastHitImpl.Builder(queryId, subjectId);</span>
        	
<span class="fc" id="L221">        		hitBuilder.setQueryLength(queryLength);</span>
<span class="fc" id="L222">        		hitBuilder.setSubjectDefline(subjectDeflineComment);</span>
        		
<span class="fc" id="L224">        		hitBuilder.setBlastDbName(blastDb);</span>
<span class="fc" id="L225">        		hitBuilder.setBlastProgramName(programName);</span>
        	}
<span class="fc" id="L227">        	tempBuilder = new StringBuilder();           </span>
            
<span class="fc" id="L229">        }</span>
        private void reportBlastHeaderInfo() {
<span class="fc" id="L231">			visitor.visitInfo(programName, programVersion, blastDb, queryId);</span>
			
<span class="fc" id="L233">		}</span>
		public void characters(char[] ch, int start, int length) throws SAXException {
<span class="fc" id="L235">        	tempBuilder.append( new String(ch,start,length));</span>
<span class="fc" id="L236">        }</span>

        @Override
		public void endDocument() throws SAXException {
<span class="fc" id="L240">			visitor.visitEnd();</span>
<span class="fc" id="L241">		}</span>
		/**
        * {@inheritDoc}
        */
        @SuppressWarnings(&quot;unchecked&quot;)
		@Override
        public void endElement(String uri, String localName, String qName)
                throws SAXException {
<span class="fc" id="L249">        	tempVal = tempBuilder.toString();</span>
        	
<span class="fc bfc" id="L251" title="All 2 branches covered.">        	if(inHspBlock){</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        		if(HSP.equals(qName)){</span>
<span class="fc" id="L253">                    DirectedRange queryRange = DirectedRange.parse(queryStart, queryEnd, CoordinateSystem.RESIDUE_BASED);</span>
<span class="fc" id="L254">    				hspBuilder.queryRange(queryRange);</span>
<span class="fc" id="L255">                    hspBuilder.subjectRange(DirectedRange.parse(subjectStart, subjectEnd, CoordinateSystem.RESIDUE_BASED));</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">                    if(subjectLength !=null){</span>
<span class="fc" id="L257">                    	hspBuilder.subjectLength(subjectLength);</span>
                    }
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                    if(numMatches ==null){</span>
<span class="nc" id="L260">    	                double percentIdentity = (tempVal.length()-misMatches)/(double)tempVal.length();</span>
<span class="nc" id="L261">    	                hspBuilder.percentIdentity(percentIdentity);</span>
<span class="nc" id="L262">    	                hspBuilder.numMismatches(misMatches);	                </span>
    	               
<span class="nc" id="L264">                    }else{</span>
<span class="fc" id="L265">                    	long length = queryRange.asRange().getLength();</span>
<span class="fc" id="L266">                    	int numMismatches = (int)(length - numMatches);</span>
<span class="fc" id="L267">                    	hspBuilder.percentIdentity(numMatches/(double)length);</span>
<span class="fc" id="L268">                    	 hspBuilder.numMismatches(numMismatches);</span>
                    }
<span class="fc" id="L270">                    hspBuilder.numGapOpenings(numberOfGapOpenings);</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                    if(isNucleotide){</span>
<span class="fc" id="L272">                    	 ((HspBuilder&lt;Nucleotide,NucleotideSequence, NucleotideSequenceBuilder&gt;)hspBuilder)</span>
<span class="fc" id="L273">                    	 				.gappedAlignments((NucleotideSequence)querySequence, (NucleotideSequence)subjectSequence);</span>
                    }else{
<span class="nc" id="L275">                    	 ((HspBuilder&lt;AminoAcid,ProteinSequence, ProteinSequenceBuilder&gt;)hspBuilder)</span>
<span class="nc" id="L276">     	 								.gappedAlignments((ProteinSequence)querySequence, (ProteinSequence)subjectSequence);</span>

                    }
                   
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                    if(queryLength !=null){</span>
<span class="fc" id="L281">                    	hspBuilder.queryLength(queryLength);</span>
                    }
<span class="fc" id="L283">                    hitBuilder.addHsp(hspBuilder.build());</span>
                    
                   
<span class="fc" id="L286">                    queryStart=null;</span>
<span class="fc" id="L287">                    queryEnd=null;</span>
<span class="fc" id="L288">                    subjectStart=null;</span>
<span class="fc" id="L289">                    subjectEnd=null;</span>
<span class="fc" id="L290">                    subjectLength =null;</span>
                    
<span class="fc" id="L292">                    numberOfGapOpenings=0;</span>
<span class="fc" id="L293">                    misMatches=0;</span>
<span class="fc" id="L294">                    querySequence=null;</span>
<span class="fc" id="L295">                    subjectSequence=null;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                }else if(BIT_SCORE.equals(qName)){</span>
<span class="fc" id="L297">                    hspBuilder.bitScore(new BigDecimal(tempVal));</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">                }else if(E_VALUE.equals(qName)){</span>
<span class="fc" id="L299">                    hspBuilder.eValue(new BigDecimal(tempVal));</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                }else if(ALIGN_LENGTH.equals(qName)){</span>
<span class="fc" id="L301">                    hspBuilder.alignmentLength(Integer.parseInt(tempVal));</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                }else if(QUERY_FROM.equals(qName)){</span>
<span class="fc" id="L303">                   queryStart = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                }else if(QUERY_TO.equals(qName)){</span>
<span class="fc" id="L305">                   queryEnd = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                }else if(HIT_FROM.equals(qName)){</span>
<span class="fc" id="L307">                   subjectStart = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                }else if(IDENTICAL_MATCHES.equals(qName)){</span>
<span class="fc" id="L309">    		        hspBuilder.numIdenticalMatches(Integer.parseInt(tempVal));</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">    		    }else if(POSITIVE_MATCHES.equals(qName)){</span>
<span class="fc" id="L311">    		    	numMatches = Integer.parseInt(tempVal);</span>
<span class="fc" id="L312">    				hspBuilder.numPositiveMatches(numMatches);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">    		    }else if(HIT_FRAME.equals(qName)){</span>
<span class="fc" id="L314">    		        hspBuilder.hitFrame(Integer.valueOf(tempVal));</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">    		    }else if(HIT_TO.equals(qName)){</span>
<span class="fc" id="L316">                    subjectEnd = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                }else if(HSP_SCORE.equals(qName)){</span>
<span class="fc" id="L318">                    hspBuilder.hspScore(Float.parseFloat(tempVal));</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                }else if(QUERY_SEQUENCE.equals(qName)){</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">                    if(isNucleotide){</span>
<span class="fc" id="L321">                    	querySequence = new NucleotideSequenceBuilder(tempVal).build();</span>
                    }else{
<span class="nc" id="L323">                    	querySequence = new ProteinSequenceBuilder(tempVal).build();</span>
                    }
<span class="fc bfc" id="L325" title="All 2 branches covered.">                }else if(SUBJECT_SEQUENCE.endsWith(qName)){</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                    if(isNucleotide){</span>
<span class="fc" id="L327">                    	subjectSequence = new NucleotideSequenceBuilder(tempVal).build();</span>
                    }else{
<span class="nc" id="L329">                    	subjectSequence = new ProteinSequenceBuilder(tempVal).build();</span>
                    }
<span class="fc bfc" id="L331" title="All 2 branches covered.">                }else if(NUM_GAPS.equals(qName)){</span>
<span class="fc" id="L332">                	numberOfGapOpenings = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                }else if(MIDLINE.equals(qName)){</span>
<span class="fc" id="L334">                    int totalMisMatches= parseNumberOfMismatches(tempVal);</span>
<span class="fc" id="L335">                    misMatches = totalMisMatches- numberOfGapOpenings;                </span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                }else if (HIT.equals(qName)){</span>
<span class="fc" id="L337">                	inHspBlock=false;</span>
<span class="fc" id="L338">                	visitor.visitHit(hitBuilder.build());</span>
                }
        	}else{
<span class="fc bfc" id="L341" title="All 2 branches covered.">        		if(LEGACY_QUERY_ID.equals(qName)){                </span>
<span class="fc" id="L342">                    queryId = tempVal;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                 }else if(ITERATION_QUERY_ID.equals(qName)){</span>
<span class="fc" id="L344">                 	queryId = tempVal;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                 }else if(ITERATION_QUERY_LENGTH.equals(qName)){</span>
<span class="fc" id="L346">                 	queryLength = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                 }else if(SUBJECT_LENGTH.equals(qName)){</span>
<span class="fc" id="L348">                 	subjectLength = Integer.parseInt(tempVal);</span>
                 }
<span class="fc bfc" id="L350" title="All 2 branches covered.">                 else if(SUBJECT_DEF.equals(qName)){</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">                 	if(isNucleotide){</span>
<span class="fc" id="L352">                 		hspBuilder = HspBuilder.forBlastN().query(queryId);</span>
                 	}else{
<span class="nc" id="L354">                 		hspBuilder = HspBuilder.forBlastP().query(queryId);</span>
                 	}
                 	
                 	//defline could have comments
                 	//only include up to first whitespace
<span class="fc" id="L359">                 	Matcher matcher = DEFLINE_PATTERN.matcher(tempVal);</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                 	if(matcher.find()){            		</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                 		if(&quot;No definition line found&quot;.equals(tempVal)){</span>
<span class="fc" id="L362">                 				hspBuilder.subject(tempVal);</span>
	                         
<span class="fc" id="L364">	                         subjectId = tempVal; </span>
                 		}else{
<span class="fc" id="L366">	                         hspBuilder.subject(matcher.group(1));</span>
	                         
<span class="fc" id="L368">	                         subjectId = matcher.group(1); </span>
                 		}
<span class="fc" id="L370">                         subjectDeflineComment = tempVal.trim();</span>
<span class="fc" id="L371">                         hspBuilder.subjectDef(subjectDeflineComment);</span>
                 	}else{
                 		//doesn't match defline pattern
                 		//use whole string?
<span class="nc" id="L375">                 		hspBuilder.subject(tempVal);</span>
<span class="nc" id="L376">                 		subjectId = tempVal.trim();</span>
<span class="nc" id="L377">                 		hspBuilder.subject(subjectId);</span>
                 	}
<span class="fc bfc" id="L379" title="All 4 branches covered.">             }else if(HIT_ACCESSION.equals(qName) &amp;&amp; &quot;No definition line found&quot;.equals(subjectId)){</span>
            	 //VHTNGS-1131 use accession hit as subject if no defline found
<span class="fc" id="L381">            	 subjectId = tempVal.trim();</span>
<span class="fc" id="L382">            	 hspBuilder.subject(subjectId);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">        	}else if(PROGRAM_NAME.equals(qName)){</span>
<span class="fc" id="L384">            	isNucleotide = &quot;blastn&quot;.equalsIgnoreCase(tempVal);</span>
<span class="fc" id="L385">            	programName = tempVal;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            }else if(PROGRAM_VERSION.equals(qName)){</span>
<span class="fc" id="L387">            	programVersion = tempVal;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            }else if (QUERY_LENGTH.equals(qName)){</span>
<span class="fc" id="L389">            	this.queryLength = Integer.parseInt(tempVal);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">            }else if (BLAST_DB.equals(qName)){</span>
<span class="fc" id="L391">            	this.blastDb = tempVal;</span>
            }
        	}
<span class="fc" id="L394">        }</span>
        /**
         * @param tempVal2
         * @return
         */
        private int parseNumberOfMismatches(String midline) {
           
<span class="fc" id="L401">            int misMatches=0;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">            for(int i=0; i&lt;midline.length(); i++){</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">                if(midline.charAt(i) != '|'){</span>
<span class="fc" id="L404">                    misMatches++;</span>
                }
            }
<span class="fc" id="L407">            return misMatches;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>