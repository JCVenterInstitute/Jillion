<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TraceDirPhdDataStoreBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.phd</a> &gt; <span class="el_source">TraceDirPhdDataStoreBuilder.java</span></div><h1>TraceDirPhdDataStoreBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.phd;

import java.io.File;
import java.io.IOException;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;

import org.jcvi.jillion.core.datastore.DataStoreEntry;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.io.FileUtil;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.internal.core.datastore.DataStoreStreamingIterator;
import org.jcvi.jillion.trace.chromat.Chromatogram;
import org.jcvi.jillion.trace.chromat.ChromatogramFactory;

/**
 * Class that can make a {@link PhdDataStore}
 * from a folder of trace files (ab1, ztr, scf etc).
 * 
 * @author dkatzel
 *
 */
public class TraceDirPhdDataStoreBuilder {

	
	private final File dir;
<span class="nc" id="L52">	private Function&lt;File, String&gt; nameConverter = f -&gt; FileUtil.getBaseName(f);</span>
	
<span class="nc" id="L54">	private Function&lt;File, Date&gt; dateFunction = f-&gt; new Date(f.lastModified());</span>
	
	
<span class="nc" id="L57">	public TraceDirPhdDataStoreBuilder(File traceDir) throws IOException{</span>
<span class="nc" id="L58">		IOUtil.verifyIsReadable(traceDir);</span>
<span class="nc" id="L59">		this.dir = traceDir;</span>
<span class="nc" id="L60">	}</span>
	/**
	 * Function to compute the date for the trace.
	 * If this method is not called, the default implementation
	 * will use the File's last modified timestamp.
	 * 
	 * @param dateFunction the date function to use; can not be null.
	 * @return this.
	 * 
	 * @throws NullPointerException if the function is null.
	 */
	public TraceDirPhdDataStoreBuilder dateFunction(Function&lt;File, Date&gt; dateFunction){
<span class="nc" id="L72">		Objects.requireNonNull(dateFunction);</span>
<span class="nc" id="L73">		this.dateFunction = dateFunction;</span>
		
<span class="nc" id="L75">		return this;</span>
	}

	/**
	 * Function to compute the Name to use for this trace so it can
	 * be retrieved by {@link PhdDataStore#get(String)}.
	 * If this method is not called, the default implementation
	 * will use the file name up to but not incuding the extension (the base name).
	 * 
	 * @param nameConverter the function to use; can not be null.
	 * @return this.
	 * 
	 * @throws NullPointerException if the function is null.
	 */
	public TraceDirPhdDataStoreBuilder nameConverter(Function&lt;File, String&gt; nameConverter){
<span class="nc" id="L90">		Objects.requireNonNull(nameConverter);</span>
<span class="nc" id="L91">		this.nameConverter = nameConverter;</span>
		
<span class="nc" id="L93">		return this;</span>
	}
	/**
	 * Build a new {@link PhdDataStore} using the given configuration so far.
	 * @return a new PhdDataStore; will never be null.
	 * @throws IOException if there is a problem parsing the trace files.
	 */
	public PhdDataStore build() throws IOException{
<span class="nc" id="L101">		return new TraceDirPhdDataStore(this);</span>
	}
	
	
	private static final class TraceDirPhdDataStore implements PhdDataStore{

<span class="nc" id="L107">		private final Map&lt;String, File&gt; fileMapping =new LinkedHashMap&lt;&gt;();</span>
		
		private final Function&lt;File, Date&gt; dateFunction;
		
<span class="nc" id="L111">		public TraceDirPhdDataStore(TraceDirPhdDataStoreBuilder builder) throws IOException{</span>
			
<span class="nc" id="L113">			File dir = builder.dir;</span>
<span class="nc" id="L114">			Function&lt;File, String&gt; nameConverter = builder.nameConverter;</span>
			
<span class="nc" id="L116">			this.dateFunction = builder.dateFunction;</span>
			
<span class="nc" id="L118">			File[] files = dir.listFiles();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">			if(files ==null){</span>
<span class="nc" id="L120">				return;</span>
			}
<span class="nc bnc" id="L122" title="All 2 branches missed.">			for(File f : files){</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">				if(f.isDirectory()){</span>
					//TODO handle nested directories
<span class="nc" id="L125">					continue;</span>
				}
<span class="nc" id="L127">				String id = nameConverter.apply(f);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">				if(id !=null){</span>
<span class="nc" id="L129">					fileMapping.put(id, f);</span>
				}
			}
<span class="nc" id="L132">		}</span>
		
		@Override
		public StreamingIterator&lt;String&gt; idIterator() throws DataStoreException {
<span class="nc" id="L136">			return DataStoreStreamingIterator.create(this, IteratorUtil.createStreamingIterator(fileMapping.keySet()));</span>
		}

		@Override
		public Phd get(String id) throws DataStoreException {
<span class="nc" id="L141">			File f = fileMapping.get(id);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">			if(f ==null){</span>
<span class="nc" id="L143">				return null;</span>
			}
			try{
<span class="nc" id="L146">			return asPhd(f, id);</span>
<span class="nc" id="L147">			}catch(IOException e){</span>
<span class="nc" id="L148">				throw new DataStoreException(e.getMessage(), e);</span>
			}
		}
		
		private Phd asPhd(File f, String id) throws IOException{
<span class="nc" id="L153">			Chromatogram chromo = ChromatogramFactory.create(id, f);</span>
			
<span class="nc" id="L155">			Date chromoDate = dateFunction.apply(f);</span>
<span class="nc" id="L156">			return new PhdBuilder(chromo)</span>
<span class="nc" id="L157">					.comments(PhdUtil.createPhdTimeStampAndChromatFileCommentsFor(chromoDate, f.getName()))</span>
<span class="nc" id="L158">					.build();</span>
		}

		@Override
		public boolean contains(String id) throws DataStoreException {
<span class="nc" id="L163">			return fileMapping.containsKey(id);</span>
		}

		@Override
		public long getNumberOfRecords() throws DataStoreException {
<span class="nc" id="L168">			return fileMapping.size();</span>
		}

		@Override
		public boolean isClosed() {
			// TODO Auto-generated method stub
<span class="nc" id="L174">			return false;</span>
		}

		@Override
		public StreamingIterator&lt;Phd&gt; iterator() throws DataStoreException {
<span class="nc" id="L179">			return DataStoreStreamingIterator.create(this, new StreamingIterator&lt;Phd&gt;() {</span>
<span class="nc" id="L180">				StreamingIterator&lt;String&gt; idIter = idIterator();</span>

				@Override
				public boolean hasNext() {
<span class="nc" id="L184">					return idIter.hasNext();</span>
				}

				@Override
				public void close() {
<span class="nc" id="L189">					idIter.close();</span>
<span class="nc" id="L190">				}</span>

				@Override
				public Phd next() {
					
					try {
<span class="nc" id="L196">						return get(idIter.next());</span>
<span class="nc" id="L197">					} catch (DataStoreException e) {</span>
<span class="nc" id="L198">						throw new IllegalStateException(e);</span>
					}
				}
				
				
			});
		}

		@Override
		public StreamingIterator&lt;DataStoreEntry&lt;Phd&gt;&gt; entryIterator() throws DataStoreException {
<span class="nc" id="L208">			return DataStoreStreamingIterator.create(this,</span>
<span class="nc" id="L209">					new StreamingIterator&lt;DataStoreEntry&lt;Phd&gt;&gt;() {</span>
<span class="nc" id="L210">				StreamingIterator&lt;Phd&gt; iter = iterator();</span>

				@Override
				public boolean hasNext() {
<span class="nc" id="L214">					return iter.hasNext();</span>
				}

				@Override
				public void close() {
<span class="nc" id="L219">					iter.close();</span>
<span class="nc" id="L220">				}</span>

				@Override
				public DataStoreEntry&lt;Phd&gt; next() {
<span class="nc" id="L224">					Phd phd = iter.next();</span>
<span class="nc" id="L225">					return new DataStoreEntry&lt;Phd&gt;(phd.getId(), phd);</span>
				}
				
			});
		}

		@Override
		public void close() throws IOException {
			// TODO Auto-generated method stub
			
<span class="nc" id="L235">		}</span>

	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>