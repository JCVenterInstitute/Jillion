<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PhdBallFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.phd</a> &gt; <span class="el_source">PhdBallFileParser.java</span></div><h1>PhdBallFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.phd;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.assembly.consed.phd.PhdBallVisitorCallback.PhdBallVisitorMemento;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.internal.core.io.LineParser;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
import org.jcvi.jillion.internal.core.io.TextLineParser;

/**
 * {@code PhdBallFileParser} can parse
 * {@literal phd.ball} files and individual phd files.
 * @author dkatzel
 *
 */
public abstract class PhdBallFileParser implements PhdBallParser{

	 private static final String BEGIN_COMMENT = &quot;BEGIN_COMMENT&quot;;
    private static final String END_SEQUENCE = &quot;END_SEQUENCE&quot;;
    private static final String END_COMMENT = &quot;END_COMMENT&quot;;
    
    private static final String BEGIN_DNA = &quot;BEGIN_DNA&quot;;
    private static final String END_DNA = &quot;END_DNA&quot;;
    
    private static final String BEGIN_TAG = &quot;BEGIN_TAG&quot;;
    private static final String END_TAG = &quot;END_TAG&quot;;

<span class="fc" id="L65">    private static final Pattern KEY_VALUE_PATTERN = Pattern.compile(&quot;^\\s*(\\w+)\\s*[:]\\s+(.+)\\s*$&quot;);</span>
<span class="fc" id="L66">    private static final Pattern CALLED_INFO_PATTERN = Pattern.compile(&quot;^\\s*(\\w)\\s+(\\d+)\\s*(\\d+)?\\s*?&quot;);</span>
<span class="fc" id="L67">    private static final Pattern BEGIN_SEQUENCE_PATTERN = Pattern.compile(&quot;BEGIN_SEQUENCE\\s+(\\S+)\\s*(\\d+)?\\s*$&quot;);</span>
    private static final String BEGIN_WR = &quot;WR{&quot;;
    private static final String END_WR = &quot;}&quot;;

<span class="fc" id="L71">    private static final Pattern FILE_COMMENT_PATTERN = Pattern.compile(&quot;^#(.*)\\s*$&quot;);</span>
	
    
<span class="fc" id="L74">    private static final Pattern RIGHT_TRIM_PATTERN = Pattern.compile(&quot;(.*)\\s+$&quot;);</span>
	/**
	 * Create a new {@link PhdBallParser} that will parse the given phdball file.
	 * @param phdBall the phd to parse.
	 * 
	 * @return a new {@link PhdBallParser}; will never be null.
	 * @throws FileNotFoundException if the file does not exist.
	 */
	public static PhdBallParser create(File phdBall) throws FileNotFoundException{
<span class="fc" id="L83">		return new FileBasedPhdBallParser(phdBall);</span>
	}
	/**
	 * Create a new {@link PhdBallParser} that will parse the given phdball data
	 * from an InputStream.
	 * @param phdBallStream the InputStream that contains the phd data to parse.
	 * 
	 * @return a new {@link PhdBallParser}; will never be null.
	 */
	public static PhdBallParser create(InputStream phdBallStream){
<span class="fc" id="L93">		return new InputStreamBasedPhdBallParser(phdBallStream);</span>
	}

<span class="fc" id="L96">	private PhdBallFileParser(){</span>
		//can not instantiate outside of this .java file
<span class="fc" id="L98">	}</span>
	
	
	
	void accept(TextLineParser parser, PhdBallVisitor visitor) throws IOException{
<span class="fc" id="L103">		ParserState parserState = new ParserState();</span>
<span class="fc" id="L104">		boolean seenFileComment=false;</span>
<span class="fc" id="L105">		 PhdVisitor phdVisitor =null;</span>
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">		while(parser.hasNextLine() &amp;&amp; parserState.keepParsing()){</span>
			
<span class="fc" id="L108">			long currentOffset = parser.getPosition();</span>
<span class="fc" id="L109">			String line = parser.nextLine();</span>
<span class="fc" id="L110">			Matcher beginSequenceMatcher = BEGIN_SEQUENCE_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">			if(beginSequenceMatcher.matches()){</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">				if(phdVisitor !=null){</span>
<span class="fc" id="L113">					phdVisitor.visitEnd();</span>
				}
				//if the previous phdVisitor's visitEnd()
				//was just called, it may have used a callback
				//to halt parsing so check flag to see 
				//if we should still continue parsing/visiting
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">				if(!parserState.keepParsing()){</span>
<span class="nc" id="L120">					phdVisitor=null; //set to null to avoid calling visitEnd() twice</span>
<span class="nc" id="L121">					break;</span>
				}
<span class="fc" id="L123">				phdVisitor = visitNewRecordHeader(visitor, parserState, currentOffset, beginSequenceMatcher);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">				if(phdVisitor ==null){</span>
<span class="fc" id="L125">					skipSequence(parser);</span>
				}else{
<span class="fc" id="L127">					handleSequence(parserState, parser, phdVisitor);</span>
				}
<span class="fc bfc" id="L129" title="All 2 branches covered.">			}else if(!seenFileComment){</span>
<span class="fc" id="L130">				Matcher fileCommentMatcher = FILE_COMMENT_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">				if(fileCommentMatcher.matches()){</span>
<span class="fc" id="L132">					seenFileComment=true;</span>
<span class="fc" id="L133">					visitor.visitFileComment(fileCommentMatcher.group(1));</span>
				}
			}
<span class="fc" id="L136">		}</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">		if(parserState.keepParsing()){</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">			if(phdVisitor !=null){</span>
<span class="fc" id="L139">				phdVisitor.visitEnd();</span>
			}
<span class="fc" id="L141">			visitor.visitEnd();</span>
		}else{
<span class="nc bnc" id="L143" title="All 2 branches missed.">			if(phdVisitor !=null){</span>
<span class="nc" id="L144">				phdVisitor.halted();</span>
			}
<span class="nc" id="L146">			visitor.halted();</span>
		}
<span class="fc" id="L148">	}</span>
	
	private PhdVisitor visitNewRecordHeader(PhdBallVisitor visitor,ParserState parserState, long currentOffset, Matcher beginSequenceMatcher){
<span class="fc" id="L151">		String readId = beginSequenceMatcher.group(1);</span>
<span class="fc" id="L152">		String optionalVersion = beginSequenceMatcher.group(2);</span>
<span class="fc" id="L153">		PhdBallVisitorCallback callback = createCallback(parserState,currentOffset);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">		if(optionalVersion ==null){</span>
<span class="fc" id="L155">			return visitor.visitPhd(callback, readId, null);</span>
		}else{
<span class="fc" id="L157">			return visitor.visitPhd(callback, readId, Integer.parseInt(optionalVersion));</span>
		}
	}
	
	private void skipSequence(LineParser parser) throws IOException {
<span class="fc" id="L162">		boolean entireSequenceBlockRead=false;</span>
<span class="pc bpc" id="L163" title="3 of 4 branches missed.">		while(entireSequenceBlockRead &amp;&amp; parser.hasNextLine()){</span>
<span class="nc" id="L164">			String line = parser.nextLine();</span>
<span class="nc" id="L165">			entireSequenceBlockRead = line.startsWith(END_SEQUENCE);</span>
<span class="nc" id="L166">		}</span>
		
<span class="fc" id="L168">	}</span>


	protected abstract  PhdBallVisitorCallback createCallback(ParserState parserState, long offset);

	private void handleWholeReadTag(ParserState parserState,
			LineParser parser, PhdVisitor visitor) throws IOException {
		final PhdWholeReadItemVisitor itemVisitor;
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">		if(visitor ==null){</span>
<span class="nc" id="L177">			itemVisitor=null;</span>
		}else{
<span class="fc" id="L179">			itemVisitor =visitor.visitWholeReadItem();</span>
		}
		
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">		while(parser.hasNextLine() &amp;&amp; parserState.keepParsing()){</span>
<span class="fc" id="L183">			String line = parser.nextLine();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">			if(line.startsWith(END_WR)){</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">				if(itemVisitor!=null){</span>
<span class="fc" id="L186">					itemVisitor.visitEnd();</span>
				}
				break;
			}
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">			if(itemVisitor !=null){</span>
<span class="fc" id="L191">				itemVisitor.visitLine(rightTrim(line));</span>
			}
<span class="fc" id="L193">		}</span>
<span class="pc bpc" id="L194" title="2 of 4 branches missed.">		if(itemVisitor !=null &amp;&amp; !parserState.keepParsing()){</span>
<span class="nc" id="L195">			visitor.halted();</span>
		}
<span class="fc" id="L197">	}</span>

	private String rightTrim(String line){
<span class="fc" id="L200">		Matcher matcher = RIGHT_TRIM_PATTERN.matcher(line);</span>
<span class="fc" id="L201">		matcher.find();</span>
<span class="fc" id="L202">		return matcher.group(1);</span>
	}

	private void handleSequence(ParserState parserState, LineParser parser,
			PhdVisitor visitor) throws IOException {
		//format of each sequence is:
		//BEGIN_COMMENT
		//&lt;comments&gt;
		//END_COMMENT
		//BEGIN_DNA
		//&lt;lines of base qual pos&gt;
		//pos is now optional as of Consed 20.0 ?
		//END_DNA
		//BEGIN_TAG
		//&lt;tag data&gt;
		//END_TAG
		//..multiple tags allowed
		//END_SEQUENCE
		//possible other read tags
		//WR{..} (multiple optional WR tags)
		
<span class="fc" id="L223">		parseCommentBlock(parser, visitor);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">		if(!parserState.keepParsing()){</span>
<span class="nc" id="L225">			visitor.halted();</span>
<span class="nc" id="L226">			return;</span>
		}
<span class="fc" id="L228">		parseReadData(parserState, parser, visitor);</span>
		
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">		if(!parserState.keepParsing()){</span>
<span class="nc" id="L231">			visitor.halted();</span>
<span class="nc" id="L232">			return;</span>
		}
<span class="fc" id="L234">		parseTags(parserState, parser, visitor);</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">		if(!parserState.keepParsing()){</span>
<span class="nc" id="L236">			visitor.halted();</span>
<span class="nc" id="L237">			return;</span>
		}
		
<span class="fc" id="L240">	}</span>

	private void parseTags(ParserState parserState, LineParser parser,
			PhdVisitor visitor) throws IOException {
<span class="pc bpc" id="L244" title="1 of 4 branches missed.">		while(parser.hasNextLine() &amp;&amp; parserState.keepParsing()){</span>
<span class="fc" id="L245">			String peekedLine = parser.peekLine();</span>
<span class="fc" id="L246">			Matcher beginSequenceMatcher = BEGIN_SEQUENCE_PATTERN.matcher(peekedLine);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">			if(beginSequenceMatcher.matches()){</span>
				//found next sequence
<span class="fc" id="L249">				return;</span>
			}
<span class="fc" id="L251">			String line = parser.nextLine();</span>
			
<span class="fc bfc" id="L253" title="All 2 branches covered.">			if(line.startsWith(BEGIN_TAG)){</span>
<span class="fc" id="L254">				parseSingleTag(parserState, parser, visitor.visitReadTag());</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">			}else if(line.startsWith(BEGIN_WR)){</span>
<span class="fc" id="L256">				handleWholeReadTag(parserState, parser, visitor);</span>
			}
<span class="fc" id="L258">		}</span>
		
		
		
<span class="fc" id="L262">	}</span>


	private void parseSingleTag(ParserState parserState, LineParser parser,
			PhdReadTagVisitor visitor) throws IOException {
<span class="fc" id="L267">		boolean inTag=true;</span>
		do{
<span class="fc" id="L269">			String line = parser.nextLine();</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">			if(line.startsWith(END_TAG)){</span>
<span class="fc" id="L271">				inTag=false;</span>
			}else{
<span class="fc" id="L273">				Matcher keyValueMatcher = KEY_VALUE_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">				if(keyValueMatcher.find()){</span>
<span class="fc" id="L275">					String key = keyValueMatcher.group(1);</span>
<span class="fc" id="L276">					String value = keyValueMatcher.group(2);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">					if(&quot;TYPE&quot;.equals(key)){</span>
<span class="fc" id="L278">						visitor.visitType(value);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">					}else if(&quot;SOURCE&quot;.equals(key)){</span>
<span class="fc" id="L280">						visitor.visitSource(value);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">					}else if(&quot;UNPADDED_READ_POS&quot;.equals(key)){</span>
						//use tokenizer instead of Scanner
						//for performance improvement
<span class="fc" id="L284">						StringTokenizer tokenizer = new StringTokenizer(value);						</span>
<span class="fc" id="L285">						visitor.visitUngappedRange(Range.of(</span>
								Range.CoordinateSystem.RESIDUE_BASED,
<span class="fc" id="L287">								Integer.parseInt(tokenizer.nextToken()),</span>
<span class="fc" id="L288">								Integer.parseInt(tokenizer.nextToken())));</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">					}else if(&quot;DATE&quot;.equals(key)){</span>
						try {
<span class="fc" id="L291">							visitor.visitDate(PhdUtil.parseReadTagDate(value));</span>
<span class="nc" id="L292">						} catch (ParseException e) {</span>
<span class="nc" id="L293">							throw new IOException(&quot;error parsing read tag date: &quot; + value, e);</span>
<span class="fc" id="L294">						}</span>
					}else{
						//unrecognized key-value pair
						//could be free-form misc data that happened to be in key:value format?
<span class="nc" id="L298">						visitor.visitFreeFormData(line);</span>
					}
<span class="fc" id="L300">				}else{</span>
					//not a key value pair
<span class="fc bfc" id="L302" title="All 2 branches covered.">					if(line.startsWith(BEGIN_COMMENT)){</span>
<span class="fc" id="L303">						visitor.visitComment( parseReadTagComment(parser));</span>
					}else{
						//free form misc data?
<span class="fc" id="L306">						visitor.visitFreeFormData(line);</span>
					}
				}
			}
<span class="pc bpc" id="L310" title="2 of 6 branches missed.">		}while(inTag &amp;&amp; parser.hasNextLine() &amp;&amp; parserState.keepParsing());</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">		if(parserState.keepParsing()){			</span>
<span class="fc" id="L312">			visitor.visitEnd();</span>
		}else{
<span class="nc" id="L314">			visitor.halted();</span>
		}
<span class="fc" id="L316">	}</span>

	private String parseReadTagComment(LineParser parser) throws IOException{
<span class="fc" id="L319">		boolean inCommentBlock=true;</span>
<span class="fc" id="L320">		StringBuilder comment = new StringBuilder();</span>
		do{
<span class="fc" id="L322">			String line = parser.nextLine();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">			if(line.startsWith(END_COMMENT)){</span>
<span class="fc" id="L324">				inCommentBlock=false;</span>
			}else{
<span class="fc" id="L326">				comment.append(line);</span>
			}
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">		}while(inCommentBlock &amp;&amp; parser.hasNextLine());</span>
		//right trim to get rid of trailing \n's but not 
		//\n in the middle
<span class="fc" id="L331">		return rightTrim(comment.toString());</span>
	}

	private void parseReadData(ParserState parserState, LineParser parser, PhdVisitor visitor) throws IOException {
<span class="fc" id="L335">		boolean inDnaBlock =false;</span>
<span class="pc bpc" id="L336" title="1 of 4 branches missed.">		while(!inDnaBlock &amp;&amp; parser.hasNextLine()){</span>
<span class="fc" id="L337">			String line = parser.nextLine();</span>
<span class="fc" id="L338">			inDnaBlock = line.startsWith(BEGIN_DNA);</span>
<span class="fc" id="L339">		}</span>
		
		do{
<span class="fc" id="L342">			String line = parser.nextLine();</span>
<span class="fc" id="L343">			Matcher matcher = CALLED_INFO_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">			if(matcher.matches()){</span>
<span class="fc" id="L345">				Nucleotide base = Nucleotide.parse(matcher.group(1).charAt(0));</span>
<span class="fc" id="L346">				PhredQuality qual = PhredQuality.valueOf(Integer.parseInt(matcher.group(2)));</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">				if(matcher.group(3)==null){</span>
<span class="fc" id="L348">					visitor.visitBasecall(base, qual, null);</span>
				}else{
<span class="fc" id="L350">					visitor.visitBasecall(base, qual, Integer.parseInt(matcher.group(3)));</span>
				}
<span class="fc" id="L352">			}else{</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">				inDnaBlock = !line.startsWith(END_DNA);</span>
			}
<span class="pc bpc" id="L355" title="2 of 6 branches missed.">		}while(inDnaBlock &amp;&amp; parser.hasNextLine() &amp;&amp; parserState.keepParsing());</span>
<span class="fc" id="L356">	}</span>


	private void parseCommentBlock(LineParser parser, PhdVisitor visitor) throws IOException {
<span class="fc" id="L360">		boolean inCommentBlock =false;</span>
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">		while(!inCommentBlock &amp;&amp; parser.hasNextLine()){</span>
<span class="fc" id="L362">			String line = parser.nextLine();</span>
<span class="fc" id="L363">			inCommentBlock = line.startsWith(BEGIN_COMMENT);</span>
<span class="fc" id="L364">		}</span>
<span class="fc" id="L365">		Map&lt;String, String&gt; comments = parseComments(parser);</span>
		
<span class="fc" id="L367">		visitor.visitComments(comments);</span>
<span class="fc" id="L368">	}</span>


	private Map&lt;String, String&gt; parseComments(LineParser parser) throws IOException {
<span class="fc" id="L372">		boolean inCommentBlock=true;</span>
<span class="fc" id="L373">		Map&lt;String, String&gt; comments = new LinkedHashMap&lt;String, String&gt;();</span>
		do{
<span class="fc" id="L375">			String line = parser.nextLine();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">			if(line.startsWith(END_COMMENT)){</span>
<span class="fc" id="L377">				inCommentBlock=false;</span>
			}else{
<span class="fc" id="L379">				Matcher commentMatcher = KEY_VALUE_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">	            if(commentMatcher.find()){</span>
<span class="fc" id="L381">	            	comments.put(commentMatcher.group(1), commentMatcher.group(2));</span>
	            }
			}
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">		}while(inCommentBlock &amp;&amp; parser.hasNextLine());</span>
<span class="fc" id="L385">		return comments;</span>
	}

	private static class ParserState{
		private final AtomicBoolean keepParsing;
		
<span class="fc" id="L391">		public ParserState(){</span>
<span class="fc" id="L392">			keepParsing = new AtomicBoolean(true);</span>
<span class="fc" id="L393">		}</span>
		
		public boolean keepParsing(){
<span class="fc" id="L396">			return keepParsing.get();</span>
		}
		
		public void haltParsing(){
<span class="fc" id="L400">			keepParsing.set(false);</span>
<span class="fc" id="L401">		}</span>
	}
	
	private static class MementoedPhdBallVisitorCallbackImpl implements PhdBallVisitorCallback{

		private final long byteOffset;
		private final ParserState parserState;
		
		public MementoedPhdBallVisitorCallbackImpl(long byteOffset,
<span class="fc" id="L410">				ParserState parserState) {</span>
<span class="fc" id="L411">			this.byteOffset = byteOffset;</span>
<span class="fc" id="L412">			this.parserState = parserState;</span>
<span class="fc" id="L413">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L417">			return true;</span>
		}

		@Override
		public PhdBallVisitorMemento createMemento() {
<span class="fc" id="L422">			return new PhdBallVisitorMementoImpl(byteOffset);</span>
		}

		@Override
		public void haltParsing() {
<span class="fc" id="L427">			parserState.haltParsing();			</span>
<span class="fc" id="L428">		}</span>
		
	}
	
	private static class NoMementoPhdBallVisitorCallbackImpl implements PhdBallVisitorCallback{

		private final ParserState parserState;
		
<span class="fc" id="L436">		public NoMementoPhdBallVisitorCallbackImpl(ParserState parserState) {</span>
<span class="fc" id="L437">			this.parserState = parserState;</span>
<span class="fc" id="L438">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L442">			return false;</span>
		}

		@Override
		public PhdBallVisitorMemento createMemento() {
<span class="nc" id="L447">			throw new UnsupportedOperationException(&quot;can not create mementos from inputstream&quot;);</span>
		}

		@Override
		public void haltParsing() {
<span class="nc" id="L452">			parserState.haltParsing();			</span>
<span class="nc" id="L453">		}</span>
		
	}
	
	private static class PhdBallVisitorMementoImpl implements PhdBallVisitorMemento{
		private final long offset;

		
<span class="fc" id="L461">		public PhdBallVisitorMementoImpl(long offset) {</span>
<span class="fc" id="L462">			this.offset = offset;</span>
<span class="fc" id="L463">		}</span>
		
		public final long getOffset() {
<span class="fc" id="L466">			return offset;</span>
		}

	}
	
	private static final class FileBasedPhdBallParser extends PhdBallFileParser{
		private final File phdBall;
		
<span class="fc" id="L474">		private FileBasedPhdBallParser(File phdBall) throws FileNotFoundException{</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">			if(phdBall ==null){</span>
<span class="nc" id="L476">				throw new NullPointerException(&quot;phdball can not be null&quot;);</span>
			}
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">			if(!phdBall.exists()){</span>
<span class="nc" id="L479">				throw new FileNotFoundException(&quot;phdball must exist&quot;);</span>
			}
<span class="fc" id="L481">			this.phdBall = phdBall;</span>
<span class="fc" id="L482">		}</span>
		
		public void accept(PhdBallVisitor visitor) throws IOException{
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">			if(visitor==null){</span>
<span class="nc" id="L486">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
<span class="fc" id="L488">			TextLineParser parser =null;</span>
			try{
<span class="fc" id="L490">				parser = new TextLineParser(new BufferedInputStream(new FileInputStream(phdBall)));</span>
<span class="fc" id="L491">				accept(parser, visitor);</span>
			}finally{
<span class="pc" id="L493">				IOUtil.closeAndIgnoreErrors(parser);</span>
<span class="fc" id="L494">			}</span>
<span class="fc" id="L495">		}</span>
		
		
		@Override
		public boolean canParse() {
<span class="nc" id="L500">			return true;</span>
		}

		public void accept(PhdBallVisitor visitor, PhdBallVisitorMemento memento) throws IOException{
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">			if(visitor ==null){</span>
<span class="nc" id="L505">	            throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
	        }
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">	        if(memento ==null){</span>
<span class="nc" id="L508">	            throw new NullPointerException(&quot;memento can not be null&quot;);</span>
	        }
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">		    if(!(memento instanceof PhdBallVisitorMementoImpl)){</span>
<span class="nc" id="L511">		    	throw new IllegalArgumentException(&quot;unknown memento type &quot; + memento);</span>
		    }
<span class="fc" id="L513">		    long offset = ((PhdBallVisitorMementoImpl)memento).getOffset();</span>
		    //TODO add check to make sure its the same parser object?
<span class="fc" id="L515">	        TextLineParser parser=null;</span>
	        try{
<span class="fc" id="L517">		        InputStream in = new RandomAccessFileInputStream(phdBall, offset);</span>
		        
<span class="fc" id="L519">		        parser = new TextLineParser(in, offset);</span>
<span class="fc" id="L520">		        accept(parser, visitor);</span>
	        }finally{
<span class="pc" id="L522">	        	IOUtil.closeAndIgnoreErrors(parser);</span>
<span class="fc" id="L523">	        }</span>
<span class="fc" id="L524">		}</span>
		
		protected PhdBallVisitorCallback createCallback(ParserState parserState, long offset) {
<span class="fc" id="L527">			return new MementoedPhdBallVisitorCallbackImpl(offset, parserState);</span>
		}
	}
	
	private static final class InputStreamBasedPhdBallParser extends PhdBallFileParser{

		private final OpenAwareInputStream in;
<span class="fc" id="L534">    	private boolean hasParsedBefore=false;</span>
    	
<span class="fc" id="L536">		public InputStreamBasedPhdBallParser(InputStream in) {</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">			if(in ==null){</span>
<span class="nc" id="L538">				throw new NullPointerException(&quot;input stream can not be null&quot;);</span>
			}
<span class="fc" id="L540">			this.in = new OpenAwareInputStream(new BufferedInputStream(in));</span>
<span class="fc" id="L541">		}</span>

		@Override
		public void accept(PhdBallVisitor visitor) throws IOException {
			
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">			if(visitor==null){</span>
<span class="nc" id="L547">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
			//this is a work around to fix a regression
			//where we give an empty stream
			//first time should not throw an error
			//even if there is nothing to parse.
<span class="pc bpc" id="L553" title="3 of 4 branches missed.">			if(hasParsedBefore &amp;&amp; !canParse()){</span>
<span class="nc" id="L554">				throw new IllegalStateException(&quot;can not accept - inputstream has been closed&quot;);</span>
			}
<span class="fc" id="L556">			hasParsedBefore=true;</span>
<span class="fc" id="L557">			TextLineParser parser =null;</span>
			try{
<span class="fc" id="L559">				parser = new TextLineParser(in);</span>
<span class="fc" id="L560">				accept(parser, visitor);</span>
			}finally{
<span class="pc" id="L562">				IOUtil.closeAndIgnoreErrors(parser);</span>
<span class="fc" id="L563">			}</span>
			
<span class="fc" id="L565">		}</span>
		
		@Override
		public boolean canParse() {
<span class="nc" id="L569">			return in.isOpen();</span>
		}

		@Override
		public void accept(PhdBallVisitor visitor,
				PhdBallVisitorMemento memento) throws IOException {
<span class="nc" id="L575">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
			
		}

		@Override
		protected PhdBallVisitorCallback createCallback(
				ParserState parserState, long offset) {
<span class="fc" id="L582">			return new NoMementoPhdBallVisitorCallbackImpl(parserState);</span>
		}
		
		
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>