<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PhdBallWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.phd</a> &gt; <span class="el_source">PhdBallWriter.java</span></div><h1>PhdBallWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.phd;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Scanner;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.pos.PositionSequence;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.JoinedStringBuilder;

public class PhdBallWriter implements PhdWriter{

	 private static final int INITIAL_SIZE_READ_TAG_BUFFER = 500;
	private static final String BEGIN_SEQUENCE = &quot;BEGIN_SEQUENCE&quot;;
	    private static final String BEGIN_COMMENT = &quot;BEGIN_COMMENT&quot;;
	    private static final String END_SEQUENCE = &quot;END_SEQUENCE&quot;;
	    private static final String END_COMMENT = &quot;END_COMMENT&quot;;
	    
	    private static final String BEGIN_DNA = &quot;BEGIN_DNA&quot;;
	    private static final String END_DNA = &quot;END_DNA&quot;;
	    
	    private static final String BEGIN_TAG = &quot;BEGIN_TAG\n&quot;;
	    private static final String END_TAG = &quot;END_TAG\n&quot;;

<span class="fc" id="L58">	    private static final String NEW_LINE = String.format(&quot;%n&quot;);</span>
	    /**
	     * Initial size of StringBuffer used to write out phd
	     * text data.  Buffer will grow if this size is exceeded.
	     */
		private static final int INITIAL_PHD_BUFFER_SIZE = 1024;
	
	private final Writer writer;
	/**
	 * Create a new {@link PhdBallWriter} instance
	 * that will write its contents to the given {@link OutputStream}.
	 * @param out the {@link OutputStream} to write to;
	 * can not be null.  
	 * @throws NullPointerException if outputFile is null.
	 * 
	 * @throws IOException if there are problems creating the writer.
	 */
	public PhdBallWriter(OutputStream out) throws IOException{
<span class="fc" id="L76">		this(out, null);</span>
		
<span class="fc" id="L78">	}</span>
	/**
	 * Create a new {@link PhdBallWriter} instance
	 * that will write its contents to the given {@link OutputStream}.
	 * @param out the {@link OutputStream} to write to;
	 * can not be null.  
	 * @param fileComment a comment String to be written
	 * at the top of the phdball; Should only be 
	 * one line. The writer will format the comment
	 * so phd's know that it is a comment.  If fileComment
	 * is null, then no comment will be written.
	 * @throws NullPointerException if outputFile is null.
	 * @throws IllegalArgumentException if fileComment is more
	 * than one line.
	 * @throws IOException if there are problems writing
	 * the fileComment to the outputStream.
	 */
<span class="fc" id="L95">	public PhdBallWriter(OutputStream out, String fileComment) throws IOException{</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">		if(out ==null){</span>
<span class="nc" id="L97">			throw new NullPointerException(&quot;output stream can not be null&quot;);</span>
		}
<span class="fc" id="L99">		assertCommentIsOnlyOneLine(fileComment);</span>
<span class="fc" id="L100">		this.writer = new BufferedWriter(new OutputStreamWriter(out, IOUtil.UTF_8));</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">		if(fileComment !=null){</span>
<span class="fc" id="L102">			writer.write(String.format(&quot;#%s%n&quot;, fileComment));</span>
		}
<span class="fc" id="L104">	}</span>
	/**
	 * Create a new {@link PhdBallWriter} instance
	 * that will write its contents to the given file.
	 * @param outputFile the {@link File} to write to;
	 * can not be null.  If this file already exists,
	 * then it will be overwritten.  If the File does
	 * not exist it will be created along with any non-existent
	 * parent directories.
	 * @param fileComment a comment String to be written
	 * at the top of the phdball; Should only be 
	 * one line. The writer will format the comment
	 * so phd's know that it is a comment.  If fileComment
	 * is null, then no comment will be written.
	 * @throws IOException if there is a problem creating
	 * the file or writing the fileComment (if non-null).
	 * @throws NullPointerException if outputFile is null.
	 * @throws IllegalArgumentException if fileComment is more
	 * than one line.
	 */
<span class="fc" id="L124">	public PhdBallWriter(File outputFile, String fileComment) throws IOException{</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">		if(outputFile ==null){</span>
<span class="nc" id="L126">			throw new NullPointerException(&quot;output file can not be null&quot;);</span>
		}
<span class="fc" id="L128">		assertCommentIsOnlyOneLine(fileComment);</span>
<span class="fc" id="L129">		IOUtil.mkdirs(outputFile.getParentFile());</span>
<span class="fc" id="L130">		this.writer = new BufferedWriter(</span>
				new OutputStreamWriter(new FileOutputStream(outputFile), IOUtil.UTF_8));
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">		if(fileComment !=null){</span>
<span class="nc" id="L133">			writer.write(String.format(&quot;#%s%n&quot;, fileComment));</span>
		}
<span class="fc" id="L135">	}</span>
	
	private void assertCommentIsOnlyOneLine(String fileComment){
<span class="fc bfc" id="L138" title="All 2 branches covered.">		if(fileComment !=null){</span>
<span class="fc" id="L139">			Scanner scanner = new Scanner(fileComment);</span>
			try{
<span class="fc" id="L141">				scanner.nextLine();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">				if(scanner.hasNext()){</span>
<span class="nc" id="L143">					throw new IllegalArgumentException(&quot;fileComment can not be multi-line&quot;);</span>
				}
			}finally{
<span class="pc" id="L146">				scanner.close();</span>
<span class="fc" id="L147">			}</span>
		}
<span class="fc" id="L149">	}</span>
	/**
	 * Create a new {@link PhdBallWriter} instance
	 * that will write its contents to the given file.
	 * @param outputFile the {@link File} to write to;
	 * can not be null.  If this file already exists,
	 * then it will be overwritten.  If the File does
	 * not exist it will be created along with any non-existent
	 * parent directories.
	 * @throws IOException if there is a problem creating
	 * the file.  
	 * @throws NullPointerException if outputFile is null.
	 */
	public PhdBallWriter(File outputFile) throws IOException{
<span class="fc" id="L163">		this(outputFile, null);</span>
<span class="fc" id="L164">	}</span>

	@Override
	public void close() throws IOException {
<span class="fc" id="L168">		writer.close();</span>
		
<span class="fc" id="L170">	}</span>

	@Override
	public void write(Phd phd) throws IOException {
<span class="fc" id="L174">		write(phd, null);</span>
		
<span class="fc" id="L176">	}</span>

	@Override
	public void write(Phd phd, Integer version) throws IOException {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">		if(phd ==null){</span>
<span class="nc" id="L181">			throw new NullPointerException(&quot;phd can not be null&quot;);</span>
		}
<span class="pc bpc" id="L183" title="3 of 4 branches missed.">		if(version !=null &amp;&amp; version.intValue() &lt;1){</span>
<span class="nc" id="L184">			throw new IllegalArgumentException(&quot;version must be &gt;=1&quot;);</span>
		}
<span class="fc" id="L186">		writePhd(phd, version);</span>
		
<span class="fc" id="L188">	}</span>
	
	
	    private void writePhd(Phd phd, Integer version) throws IOException{
	        try{
<span class="fc" id="L193">	            StringBuilder phdRecord = new StringBuilder(INITIAL_PHD_BUFFER_SIZE);</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">	            if(version ==null){</span>
<span class="fc" id="L195">	            	phdRecord.append( String.format(&quot;%s %s%n%n&quot;,BEGIN_SEQUENCE, phd.getId()));</span>
	            }else{
<span class="nc" id="L197">	            	phdRecord.append( String.format(&quot;%s %s %d%n%n&quot;,BEGIN_SEQUENCE, phd.getId(),version));</span>
	            }
<span class="fc" id="L199">	            phdRecord.append(createComments(phd))</span>
<span class="fc" id="L200">			            .append(writeDnaSection(phd))</span>
<span class="fc" id="L201">			            .append(NEW_LINE);</span>
<span class="fc" id="L202">	            List&lt;PhdReadTag&gt; tags = phd.getReadTags();</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">	            if(!tags.isEmpty()){</span>
<span class="fc" id="L204">	            	 phdRecord.append(writeReadTags(tags));</span>
	            }
<span class="fc" id="L206">	            phdRecord.append(String.format(&quot;%s%n&quot;,END_SEQUENCE))</span>
<span class="fc" id="L207">	            	.append(createWholeReadItems(phd));</span>
<span class="fc" id="L208">	            writer.write(phdRecord.toString());</span>
<span class="nc" id="L209">	        }catch(Throwable t){</span>
<span class="nc" id="L210">	            throw new IOException(&quot;error writing phd record for &quot;+phd.getId(), t);</span>
<span class="fc" id="L211">	        }</span>
	        
<span class="fc" id="L213">	    }</span>
	    

	    private String writeReadTags(List&lt;PhdReadTag&gt; tags) {
<span class="fc" id="L217">			List&lt;String&gt; printedTags = new ArrayList&lt;String&gt;(tags.size());</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">	    	for(PhdReadTag tag : tags){</span>
<span class="fc" id="L219">	    		Range range = tag.getUngappedRange();</span>
<span class="fc" id="L220">				StringBuilder builder = new StringBuilder(INITIAL_SIZE_READ_TAG_BUFFER)</span>
<span class="fc" id="L221">					.append(BEGIN_TAG)</span>
<span class="fc" id="L222">					.append(String.format(&quot;TYPE: %s%n&quot;,tag.getType()))</span>
<span class="fc" id="L223">					.append(String.format(&quot;SOURCE: %s%n&quot;,tag.getSource()))</span>
				
<span class="fc" id="L225">					.append(String.format(&quot;UNPADDED_READ_POS: %d %d%n&quot;,</span>
<span class="fc" id="L226">						range.getBegin(Range.CoordinateSystem.RESIDUE_BASED),</span>
<span class="fc" id="L227">						range.getEnd(Range.CoordinateSystem.RESIDUE_BASED)))</span>
				
<span class="fc" id="L229">						.append(String.format(&quot;DATE: %s%n&quot;, PhdUtil.formatReadTagDate(tag.getDate())));</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">				if(tag.getComment() !=null){</span>
<span class="fc" id="L231">					builder.append(BEGIN_COMMENT).append(NEW_LINE)</span>
<span class="fc" id="L232">					.append(tag.getComment()).append(NEW_LINE)</span>
<span class="fc" id="L233">					.append(END_COMMENT).append(NEW_LINE);</span>
				}
<span class="fc bfc" id="L235" title="All 2 branches covered.">				if(tag.getFreeFormData() !=null){</span>
<span class="fc" id="L236">					builder.append(tag.getFreeFormData()).append(NEW_LINE);</span>
				}
				
<span class="fc" id="L239">				printedTags.add(builder.append(END_TAG)</span>
<span class="fc" id="L240">									.toString());</span>
<span class="fc" id="L241">			}</span>
<span class="fc" id="L242">			return JoinedStringBuilder.create(printedTags)</span>
<span class="fc" id="L243">						.glue(NEW_LINE)</span>
<span class="fc" id="L244">						.build();</span>
		}
		private StringBuilder createWholeReadItems(Phd phd) {
<span class="fc" id="L247">	        StringBuilder tags = new StringBuilder();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">	        for(PhdWholeReadItem tag : phd.getWholeReadItems()){</span>
<span class="fc" id="L249">	        	String lines = JoinedStringBuilder.create(tag.getLines())</span>
<span class="fc" id="L250">	        						.glue(NEW_LINE)</span>
<span class="fc" id="L251">	        						.build();</span>
<span class="fc" id="L252">	            tags.append(String.format(&quot;WR{%n%s%n}%n&quot;,lines));</span>
<span class="fc" id="L253">	        }</span>
<span class="fc" id="L254">	        return tags;</span>
	        
	        
	    }

	    private StringBuilder writeDnaSection(Phd phd) {
<span class="fc" id="L260">	        StringBuilder dna = new StringBuilder(INITIAL_PHD_BUFFER_SIZE);</span>
<span class="fc" id="L261">	        dna.append(String.format(&quot;%s%n&quot;,BEGIN_DNA))</span>
<span class="fc" id="L262">	        .append(writeCalledInfo(phd))</span>
<span class="fc" id="L263">	        .append(String.format(&quot;%s%n&quot;,END_DNA));   </span>
<span class="fc" id="L264">	        return dna;</span>
	    }

	    private StringBuilder writeCalledInfo( Phd phd){
	       
<span class="fc" id="L269">	        NucleotideSequence nucleotideSequence = phd.getNucleotideSequence();</span>
<span class="fc" id="L270">	        int seqLength = (int)nucleotideSequence.getLength();</span>
<span class="fc" id="L271">			Iterator&lt;Nucleotide&gt; basesIter = nucleotideSequence.iterator();</span>
<span class="fc" id="L272">	        Iterator&lt;PhredQuality&gt; qualIter = phd.getQualitySequence().iterator();</span>
	       
<span class="fc" id="L274">	        PositionSequence peaks = phd.getPeakSequence();</span>
<span class="fc" id="L275">	        StringBuilder result = new StringBuilder(seqLength *10);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">	        if(peaks==null){</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">	            while(basesIter.hasNext()){</span>
<span class="fc" id="L278">	            	result.append(String.format(&quot;%s %d%n&quot;,</span>
<span class="fc" id="L279">	            			basesIter.next(), </span>
<span class="fc" id="L280">	                        qualIter.next().getQualityScore()));</span>
	            }
	        }else{
	        	 //optimization to convert to array instead 
	            //of iterating over Position objects
	            //this way we get primitives.
<span class="fc" id="L286">	        	short[] positions = phd.getPeakSequence().toArray();</span>
<span class="fc" id="L287">	        	int i=0;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">	            while(basesIter.hasNext()){</span>
<span class="fc" id="L289">	            	result.append(String.format(&quot;%s %d %d%n&quot;,</span>
<span class="fc" id="L290">	            			basesIter.next(), </span>
<span class="fc" id="L291">	                        qualIter.next().getQualityScore(),</span>
<span class="fc" id="L292">	                        IOUtil.toUnsignedShort(positions[i])));</span>
<span class="fc" id="L293">	            	i++;</span>
	            }
	        }
	       
<span class="fc" id="L297">	        return result;</span>
	        
	    }

	    private StringBuilder createComments(Phd phd) {
<span class="fc" id="L302">	        StringBuilder comments = new StringBuilder(INITIAL_SIZE_READ_TAG_BUFFER)</span>
<span class="fc" id="L303">								        .append(BEGIN_COMMENT)</span>
<span class="fc" id="L304">								        .append(NEW_LINE);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">	        for(Entry&lt;String, String&gt; entry :phd.getComments().entrySet()){</span>
<span class="fc" id="L306">	            comments.append(String.format(&quot;%s: %s%n&quot;,entry.getKey(),entry.getValue()));</span>
<span class="fc" id="L307">	        }</span>
<span class="fc" id="L308">	        comments.append(END_COMMENT)</span>
<span class="fc" id="L309">	        		.append(NEW_LINE);</span>
	        
<span class="fc" id="L311">	        return comments;</span>
	    }
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>