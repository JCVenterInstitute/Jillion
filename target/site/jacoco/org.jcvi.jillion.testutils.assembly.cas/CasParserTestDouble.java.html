<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CasParserTestDouble.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.testutils.assembly.cas</a> &gt; <span class="el_source">CasParserTestDouble.java</span></div><h1>CasParserTestDouble.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.testutils.assembly.cas;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;

import org.jcvi.jillion.assembly.clc.cas.CasAlignment;
import org.jcvi.jillion.assembly.clc.cas.CasAlignmentRegion;
import org.jcvi.jillion.assembly.clc.cas.CasAlignmentRegionType;
import org.jcvi.jillion.assembly.clc.cas.CasFileInfo;
import org.jcvi.jillion.assembly.clc.cas.CasFileVisitor;
import org.jcvi.jillion.assembly.clc.cas.CasFileVisitor.CasVisitorCallback;
import org.jcvi.jillion.assembly.clc.cas.CasMatch;
import org.jcvi.jillion.assembly.clc.cas.CasMatchVisitor;
import org.jcvi.jillion.assembly.clc.cas.CasParser;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.util.iter.ArrayIterator;
import org.jcvi.jillion.fasta.nt.NucleotideFastaWriter;
import org.jcvi.jillion.fasta.nt.NucleotideFastaWriterBuilder;
import org.jcvi.jillion.testutils.NucleotideSequenceTestUtil;

/**
 * {@code CasParserTestDouble} is a {@link CasParser}
 * implementation that will allow
 * {@link CasFileVisitor}s to get visit messages from
 * arbitrary cas data without needing a real
 * cas file.
 * @see CasParserTestDouble.Builder
 * @author dkatzel
 *
 */
public final class CasParserTestDouble implements CasParser {
	
<span class="fc" id="L70">	private static final NucleotideSequence EMPTY_SEQ = NucleotideSequenceTestUtil.emptySeq();</span>
	
<span class="fc" id="L72">	private static final CasMatch NOT_MATCHED = new CasMatch() {</span>
		
		@Override
		public boolean readIsPartOfAPair() {
<span class="nc" id="L76">			return false;</span>
		}
		
		@Override
		public boolean readHasMutlipleMatches() {
<span class="nc" id="L81">			return false;</span>
		}
		
		@Override
		public boolean matchReported() {
<span class="fc" id="L86">			return false;</span>
		}
		
		@Override
		public boolean hasMultipleAlignments() {
<span class="nc" id="L91">			return false;</span>
		}
		
		@Override
		public Range getTrimRange() {
<span class="fc" id="L96">			return null;</span>
		}
		
		@Override
		public int getScore() {
<span class="nc" id="L101">			return 0;</span>
		}
		
		@Override
		public long getNumberOfReportedAlignments() {
<span class="nc" id="L106">			return 0;</span>
		}
		
		@Override
		public long getNumberOfMatches() {
<span class="nc" id="L111">			return 0;</span>
		}
		
		@Override
		public CasAlignment getChosenAlignment() {
<span class="fc" id="L116">			return null;</span>
		}
	};
	
	
	private final List&lt;CasMatch&gt; matches;
	private final File workingDir;
	
	private final CasFileInfo referenceFileInfo, readFileInfo;
	private final long numReferences, numReads;
	
<span class="fc" id="L127">	private CasParserTestDouble(Builder builder){</span>
<span class="fc" id="L128">		this.matches = builder.matches;</span>

<span class="fc" id="L130">		this.workingDir = builder.workingDir;</span>
		
<span class="fc" id="L132">		this.referenceFileInfo = builder.refFileInfo;</span>
<span class="fc" id="L133">		this.readFileInfo = builder.readFileInfo;</span>
		
<span class="fc" id="L135">		this.numReads = builder.readCounter;</span>
<span class="fc" id="L136">		this.numReferences = builder.references.size();</span>
<span class="fc" id="L137">	}</span>
	
	@Override
	public boolean canParse() {
<span class="nc" id="L141">		return true;</span>
	}

	@Override
	public void parse(CasFileVisitor visitor) throws IOException {
<span class="fc" id="L146">		visitor.visitAssemblyProgramInfo(&quot;CasParserTestDouble&quot;, &quot;1.0&quot;, &quot;&quot;);</span>
<span class="fc" id="L147">		visitor.visitMetaData(numReferences, numReads);</span>
		
<span class="fc" id="L149">		visitor.visitNumberOfReferenceFiles(1);		</span>
<span class="fc" id="L150">		visitor.visitNumberOfReadFiles(1);</span>
		
<span class="fc" id="L152">		visitor.visitReferenceFileInfo(referenceFileInfo);</span>
<span class="fc" id="L153">		visitor.visitReadFileInfo(readFileInfo);</span>
		
<span class="fc" id="L155">		AtomicBoolean keepParsing = new AtomicBoolean(true);</span>
		
<span class="fc" id="L157">		CasVisitorCallback callback = new CasVisitorCallback() {</span>
			
			@Override
			public void haltParsing() {
<span class="fc" id="L161">				keepParsing.set(false);</span>
<span class="fc" id="L162">			}</span>
			
			@Override
			public boolean canCreateMemento() {
<span class="nc" id="L166">				return false;</span>
			}

			@Override
			public CasVisitorMemento createMemento() {
<span class="nc" id="L171">				throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
			}
		};
	

<span class="fc" id="L176">		handleMatches(visitor.visitMatches(callback), keepParsing);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">		if(keepParsing.get()){</span>
<span class="fc" id="L178">			visitor.visitEnd();</span>
		}else{
<span class="fc" id="L180">			visitor.halted();</span>
		}
<span class="fc" id="L182">	}</span>

	private void handleMatches(CasMatchVisitor visitor, AtomicBoolean keepParsing) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">		if(visitor ==null){</span>
<span class="fc" id="L186">			return;</span>
		}
<span class="fc bfc" id="L188" title="All 2 branches covered.">		for(CasMatch match : matches){</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">			if(keepParsing.get()){</span>
<span class="fc" id="L190">				visitor.visitMatch(match);</span>
			}
<span class="fc" id="L192">		}</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">		if(keepParsing.get()){</span>
<span class="fc" id="L194">			visitor.visitEnd();</span>
		}else{
<span class="fc" id="L196">			visitor.halted();</span>
		}
<span class="fc" id="L198">	}</span>

	@Override
	public File getWorkingDir() {
<span class="fc" id="L202">		return workingDir;</span>
	}
	
	public interface ReadFileGenerator extends Closeable{
		void write(NucleotideSequence readSequence) throws IOException;
		
		List&lt;String&gt; getPaths();
	}
	
	private static final class DefaultReadIdGenerator implements ReadFileGenerator{
<span class="fc" id="L212">		private int readCounter=0;</span>
		
<span class="fc" id="L214">		private final List&lt;RecordWriter&gt; readWriters = new ArrayList&lt;&gt;();</span>
		private final Iterator&lt;RecordWriter&gt; recordWriterIterator;
		private RecordWriter currentRecordWriter;

<span class="fc" id="L218">		public DefaultReadIdGenerator(RecordWriter...recordWriters){</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">			for(RecordWriter recordWriter : recordWriters){</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">				if(recordWriter ==null){</span>
<span class="fc" id="L221">					throw new NullPointerException(&quot;record writer can not be null&quot;);</span>
				}
<span class="fc" id="L223">				readWriters.add(recordWriter);</span>
			}
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">			if(readWriters.isEmpty()){</span>
<span class="nc" id="L226">				throw new IllegalStateException(&quot;must have at least 1 RecordWriter&quot;);</span>
			}
			
<span class="fc" id="L229">			recordWriterIterator = readWriters.iterator();</span>
<span class="fc" id="L230">			currentRecordWriter = recordWriterIterator.next();</span>
<span class="fc" id="L231">		}</span>
		
		
		
		private void updateCurrentRecordWriterIfNeeded() {
<span class="fc bfc" id="L236" title="All 2 branches covered.">			if(!currentRecordWriter.canWriteAnotherRecord()){				</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">				if(!recordWriterIterator.hasNext()){</span>
<span class="fc" id="L238">					throw new IllegalStateException(&quot;no more record writers&quot;);</span>
				}
				
<span class="fc" id="L241">				currentRecordWriter = recordWriterIterator.next();</span>
			}
<span class="fc" id="L243">		}</span>
		
		
		public String getNextId() {
<span class="fc" id="L247">			updateCurrentRecordWriterIfNeeded();</span>
<span class="fc" id="L248">			return &quot;read&quot; + (readCounter++);</span>
		}

		@Override
		public void close() throws IOException {
<span class="fc" id="L253">			List&lt;String&gt; paths = new ArrayList&lt;&gt;(readWriters.size());</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">			for(RecordWriter writer : readWriters){</span>
<span class="fc" id="L255">				paths.add(writer.getFile().getName());</span>
<span class="fc" id="L256">				IOUtil.closeAndIgnoreErrors(writer);</span>
<span class="fc" id="L257">			}</span>
<span class="fc" id="L258">		}</span>
		@Override
		public List&lt;String&gt; getPaths(){
		
<span class="fc" id="L262">			List&lt;String&gt; paths = new ArrayList&lt;&gt;(readWriters.size());</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">			for(RecordWriter writer : readWriters){</span>
<span class="fc" id="L264">				paths.add(writer.getFile().getName());		</span>
<span class="fc" id="L265">			}</span>
<span class="fc" id="L266">			return paths;</span>
		}


		@Override
		public void write(NucleotideSequence readSequence) throws IOException {
<span class="fc" id="L272">			String id = getNextId();</span>
<span class="fc" id="L273">			currentRecordWriter.write(id, readSequence);</span>
			
<span class="fc" id="L275">		}</span>
		
	}

	/**
	 * This class allows arbitrary cas data to be visited
	 * without needing a real underlying CLC .cas encoded file.
	 * This allows test code to make up cas alignments to fit
	 * the situation under test.  The builder will
	 * make all related reference and read files as well
	 * in case the visiting code needs to reference or parse them.
	 * 
	 * @author dkatzel
	 *
	 */
	public static class Builder{
<span class="fc" id="L291">		private final List&lt;CasMatch&gt; matches = new ArrayList&lt;&gt;();</span>
		
		
<span class="fc" id="L294">		Map&lt;String, Integer&gt; refIndex = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc" id="L295">		Map&lt;String, NucleotideSequence&gt; references = new LinkedHashMap&lt;&gt;();</span>
		
		private final File workingDir,referenceFile;
		
		private final ReadFileGenerator readFileGenerator;
<span class="fc" id="L300">		private int readCounter=0;</span>
<span class="fc" id="L301">		private long residueCounter=0;</span>
		private NucleotideFastaWriter referenceWriter;
		
		private CasFileInfo refFileInfo, readFileInfo;
		/**
		 * 
		 * @param workingDir
		 * @throws IOException
		 */
		public Builder(File workingDir) throws IOException{
<span class="fc" id="L311">			this(workingDir, new FastaRecordWriter(workingDir));</span>
<span class="fc" id="L312">		}</span>
		/**
		 * Create a new Builder instance which will
		 * use the provided working directory to write all 
		 * of its read and reference files.
		 * 
		 * @param workingDir the working directory to use 
		 * which will not only be the root of the reference and read files
		 * created but will also be returned by {@link CasParser#getWorkingDir()}.
		 * 
		 * @param recordWriters {@link RecordWriter}s to use to write
		 * the underlying read data.  The record writers will be used
		 * in the provided order.  The Builder to keep using a RecordWriter
		 * until it has reached its max records to be written as specified 
		 * by {@link RecordWriter#canWriteAnotherRecord()}, then it will
		 * move onto the next RecordWriter.  No {@link RecordWriter}s
		 * can be null.
		 * @throws NullPointerException if any recordWriters are null.
		 * @throws IllegalStateException if no RecordWriters are provided.
		 * @throws IOException if there is a problem creating the working directory
		 * or opening a file for writing in that directory.
		 */
		public Builder(File workingDir, RecordWriter...recordWriters) throws IOException{
			
<span class="fc" id="L336">			this(workingDir, new File(workingDir,&quot;reference.fasta&quot;),</span>
					new DefaultReadIdGenerator(recordWriters));
			
<span class="fc" id="L339">		}</span>
		
		
		/**
		 * Create a new Builder instance which will
		 * use the provided working directory to write all 
		 * of its read and reference files.
		 * 
		 * @param workingDir the working directory to use 
		 * which will not only be the root of the reference and read files
		 * created but will also be returned by {@link CasParser#getWorkingDir()}.
		 * 
		 * @param referenceFile the {@link File} to write the reference sequence to; can not be null.
		 * 
		 * @param recordWriters {@link RecordWriter}s to use to write
		 * the underlying read data.  The record writers will be used
		 * in the provided order.  The Builder to keep using a RecordWriter
		 * until it has reached its max records to be written as specified 
		 * by {@link RecordWriter#canWriteAnotherRecord()}, then it will
		 * move onto the next RecordWriter.  No {@link RecordWriter}s
		 * can be null.
		 * 
		 * @throws NullPointerException if any recordWriters or referenceFile are null.
		 * 
		 * @throws IllegalStateException if no RecordWriters are provided.
		 * 
		 * @throws IOException if there is a problem creating the working directory
		 * or opening a file for writing in that directory.
		 */
<span class="fc" id="L368">		public Builder(File workingDir, File referenceFile, ReadFileGenerator readIdGenerator) throws IOException{</span>
<span class="fc" id="L369">			Objects.requireNonNull(referenceFile);</span>
<span class="fc" id="L370">			Objects.requireNonNull(readIdGenerator);</span>
<span class="fc" id="L371">			this.readFileGenerator = readIdGenerator;</span>
			
			
<span class="fc" id="L374">			this.referenceFile = referenceFile;</span>
<span class="fc" id="L375">			referenceWriter = new NucleotideFastaWriterBuilder(referenceFile).build();</span>
<span class="fc" id="L376">			this.workingDir = workingDir;</span>
		
			
<span class="fc" id="L379">		}</span>
		
		/**
		 * Add a reference with the given reference name
		 * and the provided full sequence.  This reference
		 * can now be referred to by its name 
		 * in {@link #forwardMatch(String, long)} and {@link #reverseMatch(String, long)}
		 * and the reference and sequence will be written to the reference fasta file.
		 * 
		 * @param name the reference name.
		 * @param sequence the nucleotide sequence as a String.
		 * 
		 * @return this
		 * 
		 * @throws NullPointerException if either parameter is null.
		 * @throws IllegalStateException if a reference with the same name
		 * already exists.
		 * @throws IllegalArgumentException if the given sequence is emtpy
		 * or has any invalid bases.
		 */
		public Builder addReference(String name, String sequence){
<span class="fc" id="L400">			Objects.requireNonNull(name);</span>
<span class="fc" id="L401">			Objects.requireNonNull(sequence);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">			if(references.containsKey(name)){</span>
<span class="nc" id="L403">				throw new IllegalStateException(&quot;reference name already exists : &quot; + name);</span>
			}
			
			
<span class="fc" id="L407">			NucleotideSequence seq = new NucleotideSequenceBuilder(sequence).build();</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">			if(seq.getLength() ==0){</span>
<span class="nc" id="L409">				throw new IllegalArgumentException(&quot;sequence must not be empty&quot;);</span>
			}
<span class="fc" id="L411">			refIndex.put(name, refIndex.size());</span>
<span class="fc" id="L412">			references.put(name, seq);</span>
			
			try {
<span class="fc" id="L415">				referenceWriter.write(name, seq);</span>
<span class="nc" id="L416">			} catch (IOException e) {</span>
<span class="nc" id="L417">				throw new IllegalStateException(&quot;error writing reference sequence&quot;, e);</span>
<span class="fc" id="L418">			}</span>
<span class="fc" id="L419">			return this;</span>
		}
		/**
		 * Create a new {@link AlignmentBuilder} to make an alignment
		 * of a read that matches the given reference in the forward direction.
		 * 
		 * @param refName the reference the read aligns to (this name 
		 * must already exist by a previous call to {@link #addReference(String, String)} ).
		 * @param ungappedStart the ungapped left most offset (0- based) that this
		 * read begins to align to the reference PROVIDING COVERAGE.  If the read starts off
		 * with trimmed off   ({@link CasAlignmentRegionType#INSERT} ) bases,
		 * then this offset value should be the value after those. 
		 * @return a new {@link AlignmentBuilder}
		 * 
		 * @throws IllegalArgumentException if refName is not known or if ungappedStart
		 * starts beyond the reference end.
		 */
		public AlignmentBuilder forwardMatch(String refName, long ungappedStart){
			
<span class="fc" id="L438">			validateReadParameters(refName, ungappedStart);</span>
<span class="fc" id="L439">			return new AlignmentBuilder(this,refName, ungappedStart, Direction.FORWARD);</span>
		}

		private void validateReadParameters(String refName, long ungappedStart) {
<span class="fc" id="L443">			NucleotideSequence seq = references.get(refName);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">			if(seq ==null){</span>
<span class="fc" id="L445">				throw new IllegalArgumentException(&quot;unknown reference : &quot; + refName);</span>
			}
<span class="fc bfc" id="L447" title="All 2 branches covered.">			if(ungappedStart &gt; seq.getUngappedLength()){</span>
<span class="fc" id="L448">				throw new IllegalArgumentException(&quot;read starts beyond reference &quot; + ungappedStart);</span>
			}
<span class="fc" id="L450">		}</span>
		/**
		 * Create a new {@link AlignmentBuilder} to make an alignment
		 * of a read that matches the given reference in the reverse direction.
		 * 
		 * @param refName the reference the read aligns to (this name 
		 * must already exist by a previous call to {@link #addReference(String, String)} ).
		 * @param ungappedStart the ungapped left most offset (0- based) that this
		 * read begins to align to the reference PROVIDING COVERAGE.  If the read starts off
		 * with trimmed off   ({@link CasAlignmentRegionType#INSERT} ) bases,
		 * then this offset value should be the value after those. 
		 * @return a new {@link AlignmentBuilder}
		 * 
		 * @throws IllegalArgumentException if refName is not known or if ungappedStart
		 * starts beyond the reference end.
		 */
		public AlignmentBuilder reverseMatch(String refName, long ungappedStart){
<span class="fc" id="L467">			validateReadParameters(refName, ungappedStart);</span>
<span class="fc" id="L468">			return new AlignmentBuilder(this,refName, ungappedStart, Direction.REVERSE);</span>
		}
		private Builder match(String refName, long ungappedStart, Direction dir, CasAlignmentRegionImpl[] alignmentRegions){
<span class="fc" id="L471">			Integer index = refIndex.get(refName);</span>

<span class="fc" id="L473">			readCounter++;</span>
			
<span class="fc" id="L475">			boolean matchReported = matchReported(alignmentRegions);</span>
			CasAlignment alignment;
<span class="fc bfc" id="L477" title="All 2 branches covered.">			if(matchReported){</span>
<span class="fc" id="L478">				DefaultCasAlignment.Builder alignmentBuilder = new DefaultCasAlignment.Builder(index.longValue(), ungappedStart, dir);</span>
				
<span class="fc bfc" id="L480" title="All 2 branches covered.">				for(CasAlignmentRegion alignmentRegion : alignmentRegions){</span>
<span class="fc" id="L481">					alignmentBuilder.addRegion(alignmentRegion);</span>
				}
			
<span class="fc" id="L484">				NucleotideSequence fullLengthReadSequence = computeFullRangeUngappedReadSequence2(refName, ungappedStart, dir, alignmentRegions);</span>
<span class="fc" id="L485">				residueCounter += fullLengthReadSequence.getLength();</span>
				try {
<span class="fc" id="L487">					readFileGenerator.write(fullLengthReadSequence);</span>
<span class="nc" id="L488">				} catch (IOException e) {</span>
<span class="nc" id="L489">					throw new IllegalStateException(&quot;error writing fasta read sequence&quot;, e);</span>
<span class="fc" id="L490">				}</span>
				
<span class="fc" id="L492">				alignment = alignmentBuilder.build();</span>
<span class="fc" id="L493">			}else{</span>
<span class="fc" id="L494">				alignment =null;</span>
				//need to write empty sequence
				try {
<span class="fc" id="L497">					readFileGenerator.write(EMPTY_SEQ);</span>
<span class="nc" id="L498">				} catch (IOException e) {</span>
<span class="nc" id="L499">					throw new IllegalStateException(&quot;error writing fasta read sequence&quot;, e);</span>
<span class="fc" id="L500">				}</span>
			}
<span class="fc" id="L502">			matches.add(new CasMatch() {</span>
				
				@Override
				public boolean readIsPartOfAPair() {
<span class="nc" id="L506">					return false;</span>
				}
				
				@Override
				public boolean readHasMutlipleMatches() {
<span class="nc" id="L511">					return false;</span>
				}
				
				@Override
				public boolean matchReported() {
<span class="fc" id="L516">					return matchReported;</span>
				}
				
				@Override
				public boolean hasMultipleAlignments() {
<span class="nc" id="L521">					return false;</span>
				}
				
				@Override
				public Range getTrimRange() {
<span class="fc" id="L526">					return null;</span>
				}
				
				@Override
				public int getScore() {
<span class="nc" id="L531">					return 0;</span>
				}
				
				@Override
				public long getNumberOfReportedAlignments() {
<span class="nc" id="L536">					return 1;</span>
				}
				
				@Override
				public long getNumberOfMatches() {
<span class="nc" id="L541">					return 1;</span>
				}
				
				@Override
				public CasAlignment getChosenAlignment() {
<span class="fc" id="L546">					return alignment;</span>
				}
			});
			
<span class="fc" id="L550">			return this;</span>
		}

		

		private NucleotideSequence computeFullRangeUngappedReadSequence2(
				String refName, long ungappedStart, Direction dir,
				CasAlignmentRegionImpl[] alignmentRegions) {
<span class="fc" id="L558">			NucleotideSequence refSeq = references.get(refName);</span>
			
<span class="fc" id="L560">			NucleotideSequenceBuilder fullLengthBuilder = new NucleotideSequenceBuilder();</span>
<span class="fc" id="L561">			Iterator&lt;CasAlignmentRegionImpl&gt; alignmentIter = new ArrayIterator&lt;&gt;(alignmentRegions);</span>
<span class="fc" id="L562">			boolean inValidRange = false;</span>
<span class="fc" id="L563">			long currentUngappedRefOffset = ungappedStart;</span>
			
<span class="fc bfc" id="L565" title="All 2 branches covered.">			while(alignmentIter.hasNext()){</span>
<span class="fc" id="L566">				CasAlignmentRegionImpl region = alignmentIter.next();</span>
<span class="fc" id="L567">				CasAlignmentRegionType type = region.getType();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">				if(!inValidRange){</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">					if(type ==CasAlignmentRegionType.INSERT){</span>
						//outside of validrange
						//don't update currentoffset
<span class="fc bfc" id="L572" title="All 2 branches covered.">						if(region.seq ==null){</span>
							//use N's
<span class="fc" id="L574">							char[] ns = new char[(int)region.getLength()];</span>
<span class="fc" id="L575">							Arrays.fill(ns, 'N');</span>
<span class="fc" id="L576">							fullLengthBuilder.append(ns);</span>
<span class="fc" id="L577">						}else{</span>
<span class="fc" id="L578">							fullLengthBuilder.append(region.seq);</span>
						}
					}else{
<span class="fc" id="L581">						inValidRange =true;</span>
					}
				}
<span class="fc bfc" id="L584" title="All 2 branches covered.">				if(inValidRange){</span>
					//already iterated so don't need to again
<span class="pc bpc" id="L586" title="1 of 4 branches missed.">					switch(type){</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">						case INSERT: if(region.seq ==null){</span>
										//use N's
<span class="fc" id="L589">										char[] ns = new char[(int)region.getLength()];</span>
<span class="fc" id="L590">										Arrays.fill(ns, 'N');</span>
<span class="fc" id="L591">										fullLengthBuilder.append(ns);</span>
										
<span class="fc" id="L593">									}else{</span>
<span class="fc" id="L594">										fullLengthBuilder.append(region.seq);</span>
									}
									//don't increment refOffset
<span class="fc" id="L597">									break;</span>
						case DELETION : 
									//we would normally add gaps here
									//but since this is the full range ungapped
									//sequence we don't use gaps
									//but increment ref offset
									
<span class="fc" id="L604">									currentUngappedRefOffset+=region.getLength();</span>
<span class="fc" id="L605">									break;</span>
						case MATCH_MISMATCH :
<span class="fc bfc" id="L607" title="All 2 branches covered.">									if(region.seq==null){</span>
										//use ref seq
<span class="fc" id="L609">										Range refRange = new Range.Builder(region.getLength())</span>
<span class="fc" id="L610">																.shift(currentUngappedRefOffset)</span>
<span class="fc" id="L611">																.build();</span>
<span class="fc" id="L612">										Iterator&lt;Nucleotide&gt; refIter = refSeq.iterator(refRange);</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">										while(refIter.hasNext()){</span>
<span class="fc" id="L614">											fullLengthBuilder.append(refIter.next());</span>
										}										
<span class="fc" id="L616">									}else{</span>
<span class="fc" id="L617">										fullLengthBuilder.append(region.seq);</span>
									}
<span class="fc" id="L619">									currentUngappedRefOffset+=region.getLength();</span>
<span class="fc" id="L620">									break;</span>
						default : //no-op
					}
					
				}
<span class="fc" id="L625">			}</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">			if(dir ==Direction.REVERSE){</span>
<span class="fc" id="L627">				fullLengthBuilder.reverseComplement();</span>
			}
<span class="fc" id="L629">			return fullLengthBuilder.build();</span>
		}

		
		
		private boolean matchReported(CasAlignmentRegion[] alignmentRegions) {
<span class="fc bfc" id="L635" title="All 2 branches covered.">			for(CasAlignmentRegion r : alignmentRegions){</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">				if(r.getType() !=CasAlignmentRegionType.INSERT){</span>
<span class="fc" id="L637">					return true;</span>
				}
			}
<span class="fc" id="L640">			return false;</span>
		}

	
		

		
		/**
		 * Write all the underlying read and reference files
		 * out and create a new {@link CasParser} instance
		 * that will make the visit calls that conform to the 
		 * alignment data previously given.
		 * @return a new {@link CasParser} instance; will never be null.
		 * 
		 * @throws IOException if there is a problem writing any of the files.
		 * 
		 * @throws IllegalStateException if no alignments were written.
		 */
		public CasParserTestDouble build() throws IOException{
<span class="fc bfc" id="L659" title="All 2 branches covered.">			if(readCounter ==0){</span>
				//have to have some reads!
<span class="fc" id="L661">				throw new IllegalStateException(&quot;must have at least one read&quot;);</span>
			}
<span class="fc" id="L663">			List&lt;String&gt; paths = readFileGenerator.getPaths();</span>
			
<span class="fc" id="L665">			IOUtil.closeAndIgnoreErrors(readFileGenerator);</span>
			
			try {
<span class="fc" id="L668">				referenceWriter.close();</span>
<span class="nc" id="L669">			} catch (IOException e) {</span>
<span class="nc" id="L670">				throw new IllegalStateException(&quot;error closing referece fasta writer&quot; ,e);</span>
<span class="fc" id="L671">			}</span>
<span class="fc" id="L672">			refFileInfo = new CasFileInfoImpl(referenceFile.getName(), references);</span>
			
<span class="fc" id="L674">			readFileInfo = new CasFileInfoImpl(paths, readCounter, residueCounter);</span>
<span class="fc" id="L675">			return new CasParserTestDouble(this);</span>
		}
		/**
		 * Write a Read that did not align to any of the references.
		 * By default, this will write a new read with 10 Ns.
		 * @return this
		 */
		public Builder unMatched() {
<span class="fc" id="L683">			readCounter++;</span>
			//make a read of 10 Ns
<span class="fc" id="L685">			char[] ns = new char[10];</span>
<span class="fc" id="L686">			Arrays.fill(ns ,'N');</span>
<span class="fc" id="L687">			NucleotideSequence seq = new NucleotideSequenceBuilder(ns).build();</span>
			try{
<span class="fc" id="L689">				readFileGenerator.write(seq);</span>
<span class="nc" id="L690">			} catch (IOException e) {</span>
<span class="nc" id="L691">				throw new IllegalStateException(&quot;error writing fasta read sequence&quot;, e);</span>
<span class="fc" id="L692">			}</span>
			
<span class="fc" id="L694">			matches.add(NOT_MATCHED);</span>
			
<span class="fc" id="L696">			return this;</span>
			
		}
	}
	/**
	 * Class that builds an alignment
	 * for a single read to a reference.
	 * @author dkatzel
	 *
	 */
	public static final class AlignmentBuilder{
		

		private final String refName;
		private final long ungappedStart;
		private final Direction dir;
		private final Builder builder;
		
		
<span class="fc" id="L715">		private final List&lt;CasAlignmentRegionImpl&gt; regions = new ArrayList&lt;&gt;();</span>
		
		private AlignmentBuilder(Builder builder, String refName, long ungappedStart,
<span class="fc" id="L718">				Direction dir) {</span>
<span class="fc" id="L719">			this.builder = builder;</span>
<span class="fc" id="L720">			this.refName = refName;</span>
<span class="fc" id="L721">			this.ungappedStart = ungappedStart;</span>
<span class="fc" id="L722">			this.dir = dir;</span>
<span class="fc" id="L723">		}</span>
		/**
		 * Add a new {@link CasAlignmentRegion} of the specified
		 * length.  The read's ungapped sequence of the will default
		 * to either the reference sequence if the type is a 
		 * {@link CasAlignmentRegionType#MATCH_MISMATCH} or
		 * Ns for {@link CasAlignmentRegionType#INSERT}s.
		 * @param type the alignment type; can not be null.
		 * @param length the length; must be  &gt;= 1.
		 * @return this
		 * 
		 * @throws NullPointerException if type is null.
		 * @throws IllegalArgumentException if length &lt; 1
		 */
		public AlignmentBuilder addAlignmentRegion(CasAlignmentRegionType type, int length){
<span class="fc" id="L738">			regions.add(new CasAlignmentRegionImpl(type,length));</span>
<span class="fc" id="L739">			return this;</span>
		}
		/**
		 * Add a new {@link CasAlignmentRegion} of the specified
		 * sequence. The sequence provided is in the ALIGNED
		 * orientation.  So a reverse read will have the 
		 * final full sequence reverse complemented 
		 * when it is written out to the read file.
		 * 
		 * The decision to use the aligned orientation
		 * is to make tests more clear by having
		 * the reverse reads easily understandable
		 * from an alignment context without having
		 * to mentally reverse complement when reading code.
		 * 
		 * @param type the alignment type; can not be null.
		 * @param length the length; must be  &gt;= 1.
		 * @return this
		 * 
		 * @throws NullPointerException if type is null.
		 * @throws IllegalArgumentException if length &lt; 1
		 */
		public AlignmentBuilder addAlignmentRegion(CasAlignmentRegionType type, String sequence){
<span class="fc" id="L762">			regions.add(new CasAlignmentRegionImpl(type,sequence));</span>
<span class="fc" id="L763">			return this;</span>
		}
		/**
		 * This read's alignment is complete.
		 * @return the parent CasParserTestDouble.Builder instance
		 * that created this object.
		 */
		public CasParserTestDouble.Builder build(){
<span class="fc" id="L771">			return builder.match(refName, ungappedStart, dir, regions.toArray(new CasAlignmentRegionImpl[regions.size()]));</span>
		}
	}
	
	private static final class CasAlignmentRegionImpl implements
			CasAlignmentRegion {
		private final CasAlignmentRegionType type;
		private final int length;
		private final NucleotideSequence seq;
		
<span class="fc" id="L781">		private CasAlignmentRegionImpl(CasAlignmentRegionType type, int length) {</span>
<span class="fc" id="L782">			Objects.requireNonNull(type);</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">			if(length &lt;1){</span>
<span class="nc" id="L784">				throw new IllegalArgumentException(&quot;length must be positive&quot;);</span>
			}
<span class="fc" id="L786">			this.type = type;</span>
<span class="fc" id="L787">			this.length = length;</span>
<span class="fc" id="L788">			this.seq = null;</span>
<span class="fc" id="L789">		}</span>
		
<span class="fc" id="L791">		private CasAlignmentRegionImpl(CasAlignmentRegionType type, String seq){</span>
<span class="fc" id="L792">			Objects.requireNonNull(type);</span>
<span class="fc" id="L793">			this.type = type;</span>
<span class="fc" id="L794">			this.seq = new NucleotideSequenceBuilder(seq).build();</span>
<span class="fc" id="L795">			this.length = (int)this.seq.getLength();</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">			if(length &lt;1){</span>
<span class="nc" id="L797">				throw new IllegalArgumentException(&quot;length must be positive&quot;);</span>
			}
<span class="fc" id="L799">		}</span>

		@Override
		public CasAlignmentRegionType getType() {
<span class="fc" id="L803">			return type;</span>
		}

		@Override
		public long getLength() {
<span class="fc" id="L808">			return length;</span>
		}
	}
	
	private static final class CasFileInfoImpl implements CasFileInfo{
		private final long numSeq;
		private final BigInteger residues;
		private final List&lt;String&gt; path;
		
<span class="fc" id="L817">		public CasFileInfoImpl(List&lt;String&gt; path, int numReads, long numResidues){</span>
<span class="fc" id="L818">			this.path = path;</span>
<span class="fc" id="L819">			this.numSeq = numReads;</span>
<span class="fc" id="L820">			this.residues = BigInteger.valueOf(numResidues);</span>
<span class="fc" id="L821">		}</span>
<span class="fc" id="L822">		public CasFileInfoImpl(String path, Map&lt;String, NucleotideSequence&gt; seqMap){</span>
<span class="fc" id="L823">			this.path = Collections.singletonList(path);;</span>
<span class="fc" id="L824">			this.numSeq = seqMap.size();</span>
			
<span class="fc" id="L826">			long sum =0;</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">			for(NucleotideSequence s : seqMap.values()){</span>
<span class="fc" id="L828">				sum += s.getLength();</span>
<span class="fc" id="L829">			}</span>
<span class="fc" id="L830">			residues= BigInteger.valueOf(sum);</span>
<span class="fc" id="L831">		}</span>
		@Override
		public long getNumberOfSequences() {
<span class="nc" id="L834">			return numSeq;</span>
		}

		@Override
		public BigInteger getNumberOfResidues() {
<span class="nc" id="L839">			return residues;</span>
		}

		@Override
		public List&lt;String&gt; getFileNames() {
<span class="fc" id="L844">			return path;</span>
		}
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>