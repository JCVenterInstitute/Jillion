<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Range.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core</a> &gt; <span class="el_source">Range.java</span></div><h1>Range.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jul 18, 2007
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core;

import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.LongConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.util.Caches;
import org.jcvi.jillion.internal.core.util.JillionUtil;


/**
 * A &lt;code&gt;Range&lt;/code&gt; is a pair of coordinate values which describe a
 * contiguous subset of a sequence of values.  &lt;code&gt;Range&lt;/code&gt;s are
 * immutable.  Changes to a &lt;code&gt;Range&lt;/code&gt; are done using {@link Builder Range.Builder} 
 * to create new instances.
 * &lt;p&gt;
 * &lt;code&gt;Range&lt;/code&gt;s have a begin value and an end
 * value.  The start value will always be less than or equal to the end value.
 * The minimum start value of a Range is {@link Long#MIN_VALUE}  and the max end
 * value of a Range is {@link Long#MAX_VALUE}. Also due to limitations
 * to Java primitives, Ranges can not have a length &amp;lt; {@link Long#MAX_VALUE}.
 *  Any attempt to build Ranges beyond
 * those values will throw Exceptions.
 * &lt;p&gt;
 * The Range coordinates are 0-based inclusive.  Thus, a &lt;code&gt;Range&lt;/code&gt;
 * of 20 to 30 has a size of 11, not 10, and a &lt;code&gt;Range&lt;/code&gt; of 42 to 42
 * will have a size of 1 not 0.  This is done to conform with the overwhelming
 * majority use of inclusive ranges in Bioinformatics. The implications of this are particularly important when thinking about the
 * desire to represent no range at all.  A &lt;code&gt;Range&lt;/code&gt; of 0 to 0 still
 * has a size of 1.  In order to represent a &lt;code&gt;Range&lt;/code&gt; with length 0,
 * you need to create a Range of length 0 by either using the static factory method
 * {@link Range#ofLength(long) Range.ofLength(0)} or create a new
 * {@link Builder Range.Builder} instance with either the empty constructor
 * or use the methods on the builder to shrink the range to an empty length.
 * &lt;p&gt;
 * Often, Bioinformatics formats use non-0-based coordinates. Other coordinate system start and end values can be queried
 * via the {@link #getBegin(CoordinateSystem)} and {@link #getEnd(CoordinateSystem)} methods.  
 * A different {@link CoordinateSystem} can be also be specified at construction time
 * via the {@link Range#of(CoordinateSystem, long, long)} method.  If this method is used,
 * the input values will automatically get converted into 0-based coordinates.
 * &lt;p&gt;
 * Ranges can be constructed using either {@link Builder Range.Builder} 
 * of through several convenience static factory methods including
 *  {@link Range#of(long)}, {@link Range#of(long, long)} ,
 *  {@link Range#of(CoordinateSystem, long, long)} and {@link Range#ofLength(long)}.
 *  All of these methods use {@link Builder Range.Builder}  internally.
 *  &lt;p&gt;
 *  The actual implementation of Range returned by these methods or the {@link Builder Range.Builder} 
 *  might vary based on input values in order to decrease memory usage.  (For example a Range that is very short
 *  could represent the length as a byte instead of a long.  Or if the range is in positive
 *  coordinates then memory could be saved by using unsigned values instead of signed. etc).
 *  In addition, since Ranges are immutable,
 * it is not guaranteed that the Range object returned by these creation methods
 * is a new instance since Ranges are often cached (Flyweight pattern).  Therefore;
 * &lt;strong&gt; Range objects should not be used
 * for synchronization locks.&lt;/strong&gt;  Range objects are cached and shared, synchronizing
 * on the same object as other, unrelated code can cause deadlock.
 * &lt;pre&gt; 
 * &amp;#047;&amp;#047;don't do this
 * Range range = ...
 * ...
 *   synchronized(range){ 
 *       ...   
 *    }
 * ...
 * &lt;/pre&gt;
 * 
 * Range is Serializable in a (hopefully)
 * forwards compatible way. However, there is no 
 * guarantee that the Range implementation will be the same
 * or even that the implementation class will be the same,
 * the the deserialized object should always be equal
 * to the Range that was serialized.
 * 
 * @author dkatzel
 * @author jsitz@jcvi.org
 * 
 * @see CoordinateSystem
 * @see org.jcvi.jillion.core.Range.Builder
 * 
 */
//This is a really long class
//because of all the private inner classes
@SuppressWarnings(&quot;FileLengthCheck&quot;)
public abstract class Range implements Rangeable,Iterable&lt;Long&gt;, Serializable{
	
	//This class uses the Serialization Proxy Pattern
	//described in Effective Java 2nd Ed
	//to substitute a proxy class to be serialized instead of Range.
	
	private static final long serialVersionUID = -4383105989868994198L;
	/**
	 * 2^8 -1.
	 */
	private static final int UNSIGNED_BYTE_MAX = 255;
	/**
	 * 2^16 -1.
	 */
	private static final int UNSIGNED_SHORT_MAX = 65535;
	/**
	 * 2^32 -1.
	 */
	private static final long UNSIGNED_INT_MAX = 4294967295L;
	/**
	 * Initial size of our cache of ranges {@link #CACHE}.
	 */
    private static final int INITIAL_CACHE_SIZE = 1024;

    /**
     * Regular expression in the form (left) .. (right).
     */
<span class="fc" id="L149">    private static Pattern DOT_PATTERN = Pattern.compile(&quot;(\\d+)\\s*\\.\\.\\s*(\\d+)&quot;);</span>
    /**
     * Regular expression in the form (left) - (right).
     */
<span class="fc" id="L153">    private static Pattern DASH_PATTERN = Pattern.compile(&quot;(\\d+)\\s*-\\s*(\\d+)&quot;);</span>
    /**
     * Regular expression in the form (left) , (right).
     */
<span class="fc" id="L157">    private static Pattern COMMA_PATTERN = Pattern.compile(&quot;(\\d+)\\s*,\\s*(\\d+)&quot;);</span>
    /**
     * Cache of previously built ranges.  
     * This cache uses  {@link SoftReference}s
     * so memory can be reclaimed if needed.
     */
    private static final Map&lt;CacheKey, Range&gt; CACHE;
    
    
    /**
     * {@code Comparators} is an enum of common Range
     * {@link Comparator} implementations.
     * @author dkatzel
     *
     *
     */
<span class="pc" id="L173">    public enum Comparators implements Comparator&lt;Range&gt;{</span>
        /**
         * Compares a pair of {@link Range}s
         * and assigns the lower comparative value to the Range which begins earlier.
         * In the case of two ranges having identical start coordinates, the one
         * with the lower end coordinate (the shorter range) will be ranked lower.
         * 
         */
<span class="fc" id="L181">        ARRIVAL{</span>
            @Override
            public int compare(Range first, Range second) 
            {
                /*
                 * We don't accept null values for comparison.
                 */
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (first == null){</span>
<span class="fc" id="L189">                    throw new NullPointerException(&quot;The first parameter in the comparison is null.&quot;);</span>
                }
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if (second == null){</span>
<span class="fc" id="L192">                    throw new NullPointerException(&quot;The second parameter in the comparison is null.&quot;);</span>
                }

                /*
                 * Compare first by the start values, then by the end values, if the ranges start
                 * in the same place.
                 */
<span class="fc" id="L199">                final int startComparison = JillionUtil.compare(first.getBegin(),second.getBegin());</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                if (startComparison == 0)</span>
                {
<span class="fc" id="L202">                    return JillionUtil.compare(first.getEnd(), second.getEnd());</span>
                }
<span class="fc" id="L204">                return startComparison;</span>
            }
        },
        /**
         * Compares a pair of {@link Range}s
         * and assigns the lower comparative value to the Range which ends earlier.
         * In the case of two ranges having identical end coordinates, the one
         * with the lower start coordinate (the longer range) will be ranked lower.
         * 
         */
<span class="fc" id="L214">        DEPARTURE{</span>
            @Override
            public int compare(Range first, Range second) 
            {
                /*
                 * We don't accept null values for comparison.
                 */
<span class="fc bfc" id="L221" title="All 2 branches covered.">                if (first == null){</span>
<span class="fc" id="L222">                    throw new NullPointerException(&quot;The first parameter in the comparison is null.&quot;);</span>
                }
<span class="fc bfc" id="L224" title="All 2 branches covered.">                if (second == null){</span>
<span class="fc" id="L225">                    throw new NullPointerException(&quot;The second parameter in the comparison is null.&quot;);</span>
                }
                
                /*
                 * Compare first by the end values, then by the start values, if the ranges end
                 * in the same place.
                 */
<span class="fc" id="L232">                final int endComparison = JillionUtil.compare(first.getEnd(),second.getEnd());</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (endComparison == 0)</span>
                {
<span class="fc" id="L235">                    return JillionUtil.compare(first.getBegin(),second.getBegin());</span>
                }
<span class="fc" id="L237">                return endComparison;</span>
            }
        },
        /**
         * Compares Ranges by length
         * and orders them longest to shortest. Ranges
         * of the same length are considered equal.
         */
<span class="fc" id="L245">        LONGEST_TO_SHORTEST{</span>

            @Override
            public int compare(Range o1, Range o2) {
<span class="fc" id="L249">                return -1 * JillionUtil.compare(o1.getLength(), o2.getLength());</span>
            }
            
        },
        /**
         * Compares Ranges by length
         * and orders them shortest to longest.
         * Ranges
         * of the same length are considered equal.
         */
<span class="fc" id="L259">        SHORTEST_TO_LONGEST{</span>

            @Override
            public int compare(Range o1, Range o2) {
<span class="fc" id="L263">                return JillionUtil.compare(o1.getLength(),o2.getLength());</span>
            }
            
        }
        ;
     
    }
    /**
     * Enumeration of available range coordinate systems.
     * &lt;p&gt;
     * Different file formats or conventions use
     * different numbering systems in bioinformatics utilities.
     * All Range objects use the same internal system to be inter-operable
     * but users may want ranges to be input or output into different
     * coordinate systems to fit their needs.  CoordinateSystem implementations
     * can be used to translate to and from the various bioinformatics coordinate
     * systems to simplify working with multiple coordinate systems at the same time.
     * @see Range#getBegin(CoordinateSystem)
     * @see Range#getEnd(CoordinateSystem)
     */
<span class="pc" id="L283">    public enum CoordinateSystem {</span>
        /**
         * Zero-based coordinate systems are exactly like
         * array index offsets.  CoordinateSystem starts at 0
         * and the last element in the range has an offset
         * of {@code length() -1}.
         * &lt;pre&gt; 
         * coordinate system    0  1  2  3  4  5
         *                    --|--|--|--|--|--|
         * range elements       0  1  2  3  4  5
         * &lt;/pre&gt;
         */
<span class="fc" id="L295">    	ZERO_BASED(&quot;Zero Based&quot;, &quot;0B&quot;, 0, 0, 0, 0),</span>
    	/**
    	 * Residue based coordinate system is a &quot;1s based&quot;
    	 * position system where there first element has a 
    	 * position of 1 and the last element in the range
    	 * has a position of length.
    	 *  &lt;pre&gt; 
         * coordinate system    1  2  3  4  5  6
         *                    --|--|--|--|--|--|
         * range elements       0  1  2  3  4  5
         * &lt;/pre&gt;
    	 */
<span class="fc" id="L307">        RESIDUE_BASED(&quot;Residue Based&quot;, &quot;RB&quot;, 1, 1, -1, -1),</span>
        /**
         * Spaced based coordinate systems count the &quot;spaces&quot;
         * between elements.  The first element has a coordinate
         * of 0 while the last element in the range has a position 
         * of length.
         * &lt;pre&gt; 
         * coordinate system   0  1  2  3  4  5  6
         *                    --|--|--|--|--|--|--
         * range elements       0  1  2  3  4  5
         * &lt;/pre&gt;
         */
<span class="fc" id="L319">        SPACE_BASED(&quot;Space Based&quot;, &quot;SB&quot;, 0, 1, 0, -1);</span>

        /** The full name used to display this coordinate system. */
        private String displayName;
        
        /** An abbreviated name to use as a printable &lt;code&gt;Range&lt;/code&gt; annotation. */
        private String abbreviatedName;

        private long zeroBaseToCoordinateSystemStartAdjustmentValue;
        private long zeroBaseToCoordinateSystemEndAdjustmentValue;

        private long coordinateSystemToZeroBaseStartAdjustmentValue;
        private long coordinateSystemToZeroBaseEndAdjustmentValue;

        /**
         * Builds a &lt;code&gt;CoordinateSystem&lt;/code&gt;.
         *
         * @param displayName The full name used to display this coordinate system.
         * @param abbreviatedName An abbreviated name to use as a printable &lt;code&gt;Range&lt;/code&gt;
         * annotation.
         * @param zeroBaseToCoordinateSystemStartAdjustmentValue
         * @param zeroBaseToCoordinateSystemEndAdjustmentValue
         * @param coordinateSystemToZeroBaseStartAdjustmentValue
         * @param coordinateSystemToZeroBaseEndAdjustmentValue
         */
        private CoordinateSystem(String displayName,
                                 String abbreviatedName,
                                 long zeroBaseToCoordinateSystemStartAdjustmentValue,
                                 long zeroBaseToCoordinateSystemEndAdjustmentValue,
                                 long coordinateSystemToZeroBaseStartAdjustmentValue,
<span class="fc" id="L349">                                 long coordinateSystemToZeroBaseEndAdjustmentValue) {</span>
<span class="fc" id="L350">            this.displayName = displayName;</span>
<span class="fc" id="L351">            this.abbreviatedName = abbreviatedName;</span>
<span class="fc" id="L352">            this.zeroBaseToCoordinateSystemStartAdjustmentValue = zeroBaseToCoordinateSystemStartAdjustmentValue;</span>
<span class="fc" id="L353">            this.zeroBaseToCoordinateSystemEndAdjustmentValue = zeroBaseToCoordinateSystemEndAdjustmentValue;</span>
<span class="fc" id="L354">            this.coordinateSystemToZeroBaseStartAdjustmentValue = coordinateSystemToZeroBaseStartAdjustmentValue;</span>
<span class="fc" id="L355">            this.coordinateSystemToZeroBaseEndAdjustmentValue = coordinateSystemToZeroBaseEndAdjustmentValue;</span>
<span class="fc" id="L356">        }</span>

        /**
         * Get the shortened &quot;tag&quot; name for this &lt;code&gt;CoordinateSystem&lt;/code&gt;.
         * to be used in the toString value.
         * @return A two-letter abbreviation for this &lt;code&gt;CoordinateSystem&lt;/code&gt;.
         */
        public String getAbbreviatedName() 
        {
<span class="fc" id="L365">            return abbreviatedName;</span>
        }
        
        /**
         * 
         * {@inheritDoc}
         */
        @Override
        public String toString() 
        {
<span class="fc" id="L375">            return displayName;</span>
        }

        /**
         * Get the start coordinate in this system from the 
         * equivalent zero-based start coordinate.
         * @param zeroBasedStart start coordinate in 0-based
         * coordinate system.
         */
        private long getLocalStart(long zeroBasedStart) {
<span class="fc" id="L385">            return zeroBasedStart + zeroBaseToCoordinateSystemStartAdjustmentValue;</span>
        }
        /**
         * Get the end coordinate in this system from the 
         * equivalent zero-based end coordinate.
         * @param zeroBasedEnd the end coordinate in 0-based
         * coordiante system.
         */
        private long getLocalEnd(long zeroBasedEnd) {
<span class="fc" id="L394">            return zeroBasedEnd + zeroBaseToCoordinateSystemEndAdjustmentValue;</span>
        }

        /**
         * Get 0-base start coordinate
        * from this coordinate system start location.
         */
        private long getStart(long localStart) {
<span class="fc" id="L402">            return localStart + coordinateSystemToZeroBaseStartAdjustmentValue;</span>
        }
        /**
         * Get 0-base end location
        * from this coordinate system  end location.
         */
        private long getEnd(long localEnd) {
<span class="fc" id="L409">            return localEnd + coordinateSystemToZeroBaseEndAdjustmentValue;</span>
        }

    }
    
    /**
     * Initialize cache with a soft reference cache that will grow as needed.
     */
    static{
<span class="fc" id="L418">         CACHE = Caches.createSoftReferencedValueCache(INITIAL_CACHE_SIZE);</span>
<span class="fc" id="L419">    }</span>
    /**
     * Factory method to get a {@link Range} object in
     * the {@link CoordinateSystem#ZERO_BASED} coordinate system.
     * If end == start -1 then this method will return an empty range.
     * This method is not guaranteed to return new instances and may return
     * a cached instance instead (flyweight pattern).
     * @param start start coordinate inclusive.
     * @param end end coordinate inclusive.
     * @return a {@link Range}; never null but might 
     * not be a new instance.
     * @throws IllegalArgumentException if {@code end &lt; start -1} 
     * or if the resulting range length &amp;gt; {@link Long#MAX_VALUE}.
     */
    public static Range of(long start, long end){
<span class="fc" id="L434">        return new Range.Builder(start,end).build();</span>
    }
    /**
     * Factory method to build a {@link Range} object.
     * of length 1 with the given coordinate in 
     * the {@link CoordinateSystem#ZERO_BASED} coordinate system.
     * @param singleCoordinate only coordinate in this range.
     * @return a {@link Range}; never null but might 
     * not be a new instance.
     */
    public static Range of(long singleCoordinate){
<span class="fc" id="L445">        return new Range.Builder(1)</span>
<span class="fc" id="L446">        			.shift(singleCoordinate)</span>
<span class="fc" id="L447">        			.build();</span>
    }
    
    /**
     * Factory method to build a {@link Range} object.
     * of length 1 with the given coordinate in 
     * the  given coordinate system.
     * @param coordinateSystem the {@link CoordinateSystem} to use; can not be null.
     * 
     * @param singleCoordinate only coordinate in this range.
     * @return a {@link Range}; never null but might 
     * not be a new instance.
     * 
     * @throws NullPointerException if {@link CoordinateSystem} is null.
     * 
     * @since 5.3
     */
    public static Range of(CoordinateSystem coordinateSystem, long singleCoordinate){
<span class="fc" id="L465">        return new Range.Builder(1)</span>
<span class="fc" id="L466">                                .shift(coordinateSystem.getStart(singleCoordinate))</span>
<span class="fc" id="L467">                                .build();</span>
    }

    /**
     * Factory method to build a {@link Range} object
     * with the given coordinates
     * specified in the given coordinate system. If after converting 
     * the coordinates into 0-based coordinate,
     * {@code end = start -1}, then
     * the returned range is equivalent to an empty range
     * at the start coordinate.
     * @param coordinateSystem the {@link CoordinateSystem} to use.
     * @param localStart the start coordinate in the given coordinateSystem.
     * @param localEnd the end coordinate in the given coordinateSystem.
     * @return a non-empty Range instance.  This is not guaranteed to be a 
     * new instance since Ranges use the flyweight pattern
     * to reuse the same objects.
     * @throws NullPointerException if coordinateSystem is null.
     * @throws IllegalArgumentException if length is negative
     *  @throws IndexOutOfBoundsException if the combination 
     * of start and length values would cause the Range to extend
     * beyond {@link Long#MAX_VALUE}.
     */
    public static Range of(CoordinateSystem coordinateSystem,long localStart, long localEnd){
<span class="fc" id="L491">        return new Range.Builder(coordinateSystem, localStart, localEnd)</span>
<span class="fc" id="L492">        			.build();    	</span>
    }
    /**
     * Builds a new Range instance whose implementation depends
     * on the input start and end coordinates.  The implementation
     * that can take up the fewest number of bytes is chosen.
     * @param zeroBasedStart
     * @param zeroBasedEnd
     * @return a new Range instance.
     */
    private static Range buildNewRange(long zeroBasedStart, long zeroBasedEnd){
    	
    	
<span class="fc bfc" id="L505" title="All 2 branches covered.">    	if(zeroBasedStart &gt;=0){</span>
    		//can use unsigned
<span class="fc" id="L507">    		long length = zeroBasedEnd - zeroBasedStart+1;</span>
<span class="fc" id="L508">    		return buildNewUnsignedRange(zeroBasedStart, zeroBasedEnd,length);</span>
    	}
    	
<span class="fc" id="L511">    	return buildNewSignedRange(zeroBasedStart, zeroBasedEnd);</span>
    }
    /**
     * Create a new Range instance that requires signed values
     * (probably because the range has negative coordinates).
     *  The implementation
     * that can take up the fewest number of bytes is chosen.
     * @param zeroBasedStart
     * @param zeroBasedEnd
     * @return a new Range instance.
     */
	private static Range buildNewSignedRange(long zeroBasedStart,
			long zeroBasedEnd) {

<span class="fc bfc" id="L525" title="All 2 branches covered.">    	if(canFitInSignedByte(zeroBasedStart, zeroBasedEnd)){</span>
<span class="fc" id="L526">    		return new ByteRange((byte)zeroBasedStart, (byte)zeroBasedEnd);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">    	}else if(canFitInSignedShort(zeroBasedStart,zeroBasedEnd)){</span>
<span class="fc" id="L528">    		return new ShortRange((short)zeroBasedStart, (short)zeroBasedEnd);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">    	}else if(canFitInSignedInt(zeroBasedStart,zeroBasedEnd)){</span>
<span class="fc" id="L530">    		return new IntRange((int)zeroBasedStart, (int)zeroBasedEnd);</span>
    	}    	
<span class="fc" id="L532">    	return new LongRange(zeroBasedStart, zeroBasedEnd);</span>
	}
	
	private static boolean canFitInSignedByte(long start, long end){
<span class="pc bpc" id="L536" title="2 of 8 branches missed.">		return start &lt;= Byte.MAX_VALUE &amp;&amp; start &gt;=Byte.MIN_VALUE</span>
    			&amp;&amp; end &lt;= Byte.MAX_VALUE &amp;&amp; end &gt;=Byte.MIN_VALUE;
	}
	private static boolean canFitInSignedShort(long start, long end){
<span class="pc bpc" id="L540" title="2 of 8 branches missed.">		return start &lt;= Short.MAX_VALUE &amp;&amp; start &gt;=Short.MIN_VALUE</span>
    			&amp;&amp; end &lt;= Short.MAX_VALUE &amp;&amp; end &gt;=Short.MIN_VALUE;
	}
	private static boolean canFitInSignedInt(long start, long end){
<span class="pc bpc" id="L544" title="2 of 8 branches missed.">		return start &lt;= Integer.MAX_VALUE &amp;&amp; start &gt;=Integer.MIN_VALUE</span>
    			&amp;&amp; end &lt;= Integer.MAX_VALUE &amp;&amp; end &gt;=Integer.MIN_VALUE;
	}
	/**
	 * Create a new Range instance which can use unsigned
	 * values to save memory.  The implementation
     * that can take up the fewest number of bytes is chosen.
	 * @param zeroBasedStart
	 * @param zeroBasedEnd
	 * @param length
	 * @return
	 */
	private static Range buildNewUnsignedRange(long zeroBasedStart,
			long zeroBasedEnd, long length) {
		
		//JVM spec of computing size of objects
		//in heap includes padding
		//to keep objects a multiple of 8 bytes.
		//This means that not all byte-short-int-long combinations
		//actually affect the object size.
<span class="fc bfc" id="L564" title="All 2 branches covered.">		if(zeroBasedStart &lt;= UNSIGNED_BYTE_MAX){			</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">			if(length &lt;= UNSIGNED_SHORT_MAX){</span>
<span class="fc" id="L566">				return new UnsignedByteStartShortLengthRange((short) zeroBasedStart, (int)length);</span>
			}
<span class="fc bfc" id="L568" title="All 2 branches covered.">			if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="fc" id="L569">				return new UnsignedByteStartIntLengthRange((short) zeroBasedStart, length);</span>
			}
<span class="fc" id="L571">			return new UnsignedByteStartLongLengthRange((short) zeroBasedStart, length);</span>
		}
		
<span class="fc bfc" id="L574" title="All 2 branches covered.">		if(zeroBasedStart &lt;= UNSIGNED_SHORT_MAX){</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">			if(length &lt;= UNSIGNED_SHORT_MAX){</span>
<span class="fc" id="L576">				return new UnsignedShortStartShortLengthRange((int) zeroBasedStart, (int)length);</span>
			}
<span class="fc bfc" id="L578" title="All 2 branches covered.">			if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="fc" id="L579">				return new UnsignedShortStartIntLengthRange((int) zeroBasedStart, length);</span>
			}
<span class="fc" id="L581">			return new UnsignedShortStartLongLengthRange((int) zeroBasedStart, length);</span>
		}
<span class="fc bfc" id="L583" title="All 2 branches covered.">		if(zeroBasedStart &lt;= UNSIGNED_INT_MAX){</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">			if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="fc" id="L585">				return new UnsignedIntStartIntLengthRange(zeroBasedStart, length);</span>
			}
<span class="fc" id="L587">			return new UnsignedIntStartLongLengthRange(zeroBasedStart, length);</span>
		}
<span class="fc bfc" id="L589" title="All 2 branches covered.">		if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="fc" id="L590">			return new LongStartIntLengthRange(zeroBasedStart, length);</span>
		}
<span class="fc" id="L592">		return new LongRange(zeroBasedStart, zeroBasedEnd);</span>

	}
	private static Range buildNewEmptyRange(long zeroBasedStart) {
<span class="fc" id="L596">		long absValue = Math.abs(zeroBasedStart);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">		if(absValue &lt;=Byte.MAX_VALUE){</span>
<span class="fc" id="L598">			return new EmptyByteRange((byte)zeroBasedStart);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">		}else if(absValue &lt;=Short.MAX_VALUE){</span>
<span class="fc" id="L600">			return new EmptyShortRange((short)zeroBasedStart);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">		}else if(absValue &lt;=Integer.MAX_VALUE){</span>
<span class="fc" id="L602">			return new EmptyIntRange((int)zeroBasedStart);</span>
		}else{
<span class="fc" id="L604">			return new EmptyLongRange(zeroBasedStart);</span>
		}
		
	}
	/**
	 * Warning: Only used for testing.  Please do not use.
	 * Removes the given Range from the cache.
	 * @param range the Range to remove
	 * @return The Range that was stored in the cache;
	 * or null if the Range was not in the cache.
	 * @throws NullPointerException if range is null.
	 */
	static synchronized Range removeFromCache(Range range){
<span class="fc" id="L617">	    CacheKey key = CacheKey.createCacheKeyFor(range);</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">	    if(key !=null){</span>
<span class="fc" id="L619">		return CACHE.remove(key);</span>
	    }
<span class="fc" id="L621">	    return null;</span>
	}


    /**
     * Create a non-empty Range object in the Zero based coordinate
     * system starting at 0 and with the given length.
     * @param length the length of this range.
     * @return a non-empty Range instance  whose {@link Range#getBegin()}
     * will return {@code 0} and {@link Range#getLength()}
     * will return the pass in value.  This is not guaranteed to be a 
     * new instance since Ranges use the flyweight pattern
     * to reuse the same objects.
     * @throws IllegalArgumentException if length is negative
     */
    public static Range ofLength(long length){
<span class="fc" id="L637">        return new Range.Builder(length).build();</span>
    }
   
   
    
    /**
     * Parses a string in the format &amp;lt;left&amp;gt;[.. | - ]&amp;lt;right&amp;gt;. 
     * Any whitespace between the left and right parameters is ignored.
     * &lt;br&gt;
     * Examples:
     * &lt;ul&gt;
     * &lt;li&gt;24 .. 35&lt;/li&gt;
     * &lt;li&gt;24-35&lt;/li&gt;
     * &lt;li&gt;24,35&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param rangeAsString the range to parse.
     * @param coordinateSystem the {@link CoordinateSystem} the coordinates
     * in the String to parse are in.
     * 
     * @return a {@link Range}; will never be null.
     * 
     * @throws IllegalArgumentException if the given String does not
     * match the correct format.
     */
    public static Range parseRange(String rangeAsString, CoordinateSystem coordinateSystem){
<span class="fc" id="L663">        Matcher dotMatcher =DOT_PATTERN.matcher(rangeAsString);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if(dotMatcher.find()){</span>
<span class="fc" id="L665">            return convertIntoRange(dotMatcher,coordinateSystem);</span>
        }
<span class="fc" id="L667">        Matcher dashMatcher = DASH_PATTERN.matcher(rangeAsString);</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        if(dashMatcher.find()){</span>
<span class="fc" id="L669">            return convertIntoRange(dashMatcher,coordinateSystem);</span>
        }
<span class="fc" id="L671">        Matcher commaMatcher = COMMA_PATTERN.matcher(rangeAsString);</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">        if(commaMatcher.find()){</span>
<span class="fc" id="L673">            return convertIntoRange(commaMatcher,coordinateSystem);</span>
        }
<span class="fc" id="L675">        throw new IllegalArgumentException(&quot;can not parse &quot;+ rangeAsString +&quot; into a Range&quot;);</span>
    }
    /**
     * Parses a string in the format &amp;lt;left&amp;gt;[.. | - ]&amp;lt;right&amp;gt;. 
     * Any whitespace between the left and right parameters is ignored.
     * &lt;br&gt;
     * Examples:
     * &lt;ul&gt;
     * &lt;li&gt;24 .. 35&lt;/li&gt;
     * &lt;li&gt;24-35&lt;/li&gt;
     * &lt;li&gt;24,35&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param rangeAsString the range to parse.
     * @return a {@link Range}.
     * @throws IllegalArgumentException if the given String does not
     * match the correct format.
     */
    public static Range parseRange(String rangeAsString){
<span class="fc" id="L694">        return parseRange(rangeAsString, CoordinateSystem.ZERO_BASED);</span>
    }
    
    private static Range convertIntoRange(Matcher dashMatcher, CoordinateSystem coordinateSystem) {
<span class="fc" id="L698">        return Range.of(coordinateSystem,Long.parseLong(dashMatcher.group(1)), </span>
<span class="fc" id="L699">                Long.parseLong(dashMatcher.group(2))</span>
                );
    }


<span class="fc" id="L704">    private Range(){</span>
    	//can not instantiate outside of this file.
    	//however there are several private subclasses
    	//in this file that implement Range methods
    	//in different ways to keep memory usage down.
<span class="fc" id="L709">    }</span>

    
    @Override
	public abstract int hashCode();
    /**
     * Two {@link Range}s are equal
     * if they have the same begin and end
     * values.
     */
	@Override
	public abstract boolean equals(Object obj);
	
	/**
     * Fetch the first coordinate in this Range. This is the same as 
     * {@link #getBegin(CoordinateSystem)
     * getBegin(ZERO_BASED)}.
     *
     * @return The left-hand (starting) coordinate.
     * 
     */
    @Override
    public abstract long getBegin();
    /**
     * Fetch the first coordinate using the given 
     * {@link CoordinateSystem}.  
     *
     * @param coordinateSystem the {@link CoordinateSystem} to use to convert the coordinate.
     *
     * @return The first coordinate.
     * @throws NullPointerException if the given {@link CoordinateSystem} is null.
     */
    public long getBegin(CoordinateSystem coordinateSystem) {
<span class="fc bfc" id="L742" title="All 2 branches covered.">    	if(coordinateSystem==null){</span>
<span class="fc" id="L743">    		throw new NullPointerException(&quot;CoordinateSystem can not be null&quot;);</span>
    	}
<span class="fc" id="L745">        return coordinateSystem.getLocalStart(getBegin());</span>
    }
    /**
     * Fetch the 0-based last coordinate.
     * This is the same as {@link #getEnd(CoordinateSystem)
     * getEnd(ZERO_BASED)}.
     *
     * @return The right-hand (ending) coordinate.
     */
    @Override
    public abstract long getEnd();
    
    
    /**
     * Fetch the right (end) coordinate using the given 
     * {@link CoordinateSystem}.
     *
     *@param coordinateSystem the {@link CoordinateSystem} to use to convert the coordinate.
     *
     * @return The right-hand (ending) coordinate.
     * @throws NullPointerException if the given {@link CoordinateSystem} is null.
     */
    public long getEnd(CoordinateSystem coordinateSystem) {
<span class="fc bfc" id="L768" title="All 2 branches covered.">    	if(coordinateSystem==null){</span>
<span class="fc" id="L769">    		throw new NullPointerException(&quot;CoordinateSystem can not be null&quot;);</span>
    	}
<span class="fc" id="L771">        return coordinateSystem.getLocalEnd(getEnd());</span>
    }

    /**
     * Checks if this range is empty (has length of 0).
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if the range is empty, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    @Override
    public boolean isEmpty(){
<span class="fc" id="L782">    	return false;</span>
    }
    /**
     * Checks to see if the this &lt;code&gt;Range&lt;/code&gt; is contained within
     * the given &lt;code&gt;Range&lt;/code&gt;.  This does not require this &lt;code&gt;Range&lt;/code&gt;
     * to be a strict subset of the target.  More precisely: a
     * &lt;code&gt;Range&lt;/code&gt; is always a sub-range of itself.
     *
     * @param range The &lt;code&gt;Range&lt;/code&gt; to compare to; can not be null.
     * @return &lt;code&gt;true&lt;/code&gt; if every value in this &lt;code&gt;Range&lt;/code&gt; is
     * found in the given comparison &lt;code&gt;Range&lt;/code&gt;.
     * @throws NullPointerException if range is null.
     */
    public boolean isSubRangeOf(Range range) {
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if(range==null){</span>
<span class="fc" id="L797">            throw new NullPointerException(&quot;range can not be null&quot;);</span>
        }
<span class="fc bfc" id="L799" title="All 4 branches covered.">        return getBegin()&gt;=range.getBegin() &amp;&amp; getEnd()&lt;=range.getEnd();</span>
       
    }
    

    @Override
    public boolean intersects(Rangeable target) {
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if(target instanceof Range){</span>
<span class="nc" id="L807">            return intersects((Range)target);</span>
        }
<span class="nc" id="L809">        return Rangeable.super.intersects(target);</span>
    }
    /**
     * Checks to see if the given {@link Range} intersects this one.
     * An empty range will never intersect any other range
     * (even itself)
     * @param target The {@link Range} to check.
     * @return &lt;code&gt;true&lt;/code&gt; if the coordinates of the two ranges overlap
     * each other in at least one point.
     * @throws NullPointerException if target is null.
     */
    public boolean intersects(Range target)
    {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (target == null)</span>
        {
<span class="fc" id="L824">            throw new NullPointerException(&quot;Null Range used in intersection operation.&quot;);</span>
        }
<span class="fc bfc" id="L826" title="All 2 branches covered.">        if(isEmpty()){</span>
<span class="fc" id="L827">            return false;</span>
        }
<span class="fc bfc" id="L829" title="All 2 branches covered.">        if (target.isEmpty())</span>
        {
            /*
             * Instead of defining empty set semantics here, we do it in the
             * EmptyRange class
             * -jsitz
             */
<span class="fc" id="L836">            return target.intersects(this);</span>
        }

<span class="fc bfc" id="L839" title="All 4 branches covered.">        return !(this.getBegin() &gt; target.getEnd() || this.getEnd() &lt; target.getBegin());</span>
    }
    /**
     * Calculates the intersection of this {@link Range} and a second one.
     * 
     * &lt;p&gt;
     * The intersection of an empty Range with any other Range is always the
     * empty Range.
     *
     * @param other The second {@link Range} to compare
     * @return A {@link Range} object spanning only the range of values covered
     * by both this Range and the other {@link Range}.
     */
    public Range intersection(Range other)
    {
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (other == null){</span>
<span class="fc" id="L855">            throw new IllegalArgumentException(&quot;Null Range used in intersection operation.&quot;);</span>
        }
<span class="fc bfc" id="L857" title="All 2 branches covered.">        if(isEmpty()){</span>
<span class="fc" id="L858">        	return this;</span>
        }
<span class="fc bfc" id="L860" title="All 2 branches covered.">        if (other.isEmpty()){</span>
<span class="fc" id="L861">        	return other;</span>
        }
<span class="fc" id="L863">        long intersectionStart = Math.max(other.getBegin(), this.getBegin());</span>
<span class="fc" id="L864">		long intersectionEnd = Math.min(other.getEnd(), this.getEnd());</span>
		//this mess is so we don't deal with underflow
		//if start is Long.MIN_VALUE
<span class="fc" id="L867">		long length = intersectionEnd - intersectionStart+1;</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">		if(length&lt;=-1){</span>
<span class="fc" id="L869">			return new Range.Builder().build();</span>
		}
		//length &gt;=0 can be handled by builder
		//we include length of 0 since 
		//that might have a different start coordinate
<span class="fc" id="L874">			return new Range.Builder(length)</span>
<span class="fc" id="L875">						.shift(intersectionStart)</span>
<span class="fc" id="L876">						.build();</span>
		
    }
    /**
     * Get the List of Ranges that represents the 
     * {@code this - other}.  This is similar to the 
     * Set of all coordinates that don't intersect. 
     * 
     * @param other the range to complement with.
     * 
     * @return a List of {@link Ranges}; will never be null but may be empty.
     */
    public List&lt;Range&gt; complement(Range other){
        //this - other
        //anything in this that doesn't intersect with other
<span class="fc" id="L891">        Range intersection = intersection(other);</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        if(intersection.isEmpty()){</span>
<span class="fc" id="L893">            return Collections.singletonList(this);</span>
        }
<span class="fc" id="L895">        List&lt;Range&gt; complementedRanges = new ArrayList&lt;Range&gt;();</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        if(intersection.getBegin()!=Long.MIN_VALUE){</span>
<span class="fc" id="L897">	        Range beforeOther = Range.of(getBegin(), intersection.getBegin()-1);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">	        if(!beforeOther.isEmpty()){</span>
<span class="fc" id="L899">	            complementedRanges.add(beforeOther);</span>
	        }
        }
        
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if(intersection.getEnd()!=Long.MAX_VALUE){        	</span>
<span class="fc" id="L904">        	Range afterOther= Range.of(intersection.getEnd()+1, getEnd());</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        	if(!afterOther.isEmpty()){</span>
<span class="fc" id="L906">                complementedRanges.add(afterOther);</span>
            }
        }
        
       
        
<span class="fc" id="L912">        return Ranges.merge(complementedRanges);</span>
    }
    /**
     * Get the List of Ranges that represents 
     * {@code this - others}.  This is similar to the 
     * Set of all coordinates in this Range
     * that do not intersect the ranges in others.
     * If the Ranges contained in others extends beyond
     * this Range, then only coordinates within 
     * this Range are returned.
     * @param others the ranges to complement from.
     * @return a List of Ranges; may be empty
     * if this Range is entirely covered by others.
     * @throws NullPointerException if others is null.
     */
    public List&lt;Range&gt; complement(Collection&lt;Range&gt; others){
    	//we can treat this operation 
    	//like genomic concept of introns and exons
    	//if we treat &quot;this&quot; as the complete genome size
    	//(or universe length)
    	//and the others as exons
    	//then finding what's left are the introns.
<span class="fc" id="L934">    	List&lt;Range&gt; exons = Ranges.merge(others);</span>
    	//short circuit
<span class="fc bfc" id="L936" title="All 2 branches covered.">    	if(exons.isEmpty()){</span>
<span class="fc" id="L937">    		return Collections.singletonList(this);</span>
    	}
    	
<span class="fc" id="L940">    	List&lt;Range&gt; completeExonRange = Collections.singletonList(this);</span>
<span class="fc" id="L941">		List&lt;Range&gt; introns = completeExonRange;</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">		for(Range exon : exons){</span>
<span class="fc" id="L943">			 introns = exon.complementFrom(introns);</span>
<span class="fc" id="L944">		}</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">		return introns.equals(completeExonRange)</span>
<span class="fc" id="L946">				? Collections.&lt;Range&gt;emptyList() </span>
				: introns;
    }
    
    
    List&lt;Range&gt; complementFrom(Collection&lt;Range&gt; ranges){
<span class="fc" id="L952">        List&lt;Range&gt; universe = Ranges.merge(new ArrayList&lt;Range&gt;(ranges));</span>
<span class="fc" id="L953">        List&lt;Range&gt; complements = new ArrayList&lt;Range&gt;(universe.size());</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">        for(Range range : universe){</span>
<span class="fc" id="L955">            complements.addAll(range.complement(this));</span>
<span class="fc" id="L956">        }</span>
<span class="fc" id="L957">        return Ranges.merge(complements);</span>
    }

    /**
     * Checks to see if this &lt;code&gt;Range&lt;/code&gt; starts before the given
     * comparison &lt;code&gt;Range&lt;/code&gt;.
     *
     * @param other The other &lt;code&gt;Range&lt;/code&gt; to compare to.
     * @return &lt;code&gt;true&lt;/code&gt; if the begin coordinate of this
     * &lt;code&gt;Range&lt;/code&gt; is less than the  begin coordinate of the
     * other &lt;code&gt;Range&lt;/code&gt;.
     * @throws NullPointerException if other is null.
     */
    public boolean startsBefore(Range other)
    {
<span class="fc bfc" id="L972" title="All 2 branches covered.">        if (other == null){</span>
<span class="fc" id="L973">            throw new NullPointerException(&quot;Null Range used in range comparison operation.&quot;);</span>
        }

<span class="fc bfc" id="L976" title="All 2 branches covered.">        return this.getBegin() &lt; other.getBegin();</span>
    }

    /**
     * Checks to see if this &lt;code&gt;Range&lt;/code&gt; ends before the given target.
     *
     * @param other The target &lt;code&gt;Range&lt;/code&gt; to check against.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Range&lt;/code&gt; has an end value
     * which occurs before (and not at the same point as) the target
     * &lt;code&gt;Range&lt;/code&gt;.
     * @throws NullPointerException if other is null.
     */
    public boolean endsBefore(Range other)
    {
<span class="fc bfc" id="L990" title="All 2 branches covered.">        if (other == null){</span>
<span class="fc" id="L991">            throw new NullPointerException(&quot;Null Range used in range comparison operation.&quot;);</span>
        }
        
<span class="fc bfc" id="L994" title="All 2 branches covered.">        return this.getEnd() &lt; other.getBegin();</span>
    } 
   
    /**
     * Convenience method that delegates to
     * {@link #toString(CoordinateSystem)} using {@link CoordinateSystem#ZERO_BASED}.
     * 
     * @see #toString(CoordinateSystem)
     * 
     */
    @Override
    public String toString()
    {
<span class="fc" id="L1007">        return toString(CoordinateSystem.ZERO_BASED);</span>
    }
    /**
     * Returns a String representation of this Range in given coordinate system.
     * The actual format is {@code [localStart .. localEnd]/systemAbbreviatedName}
     * 
     * @param coordinateSystem the {@link CoordinateSystem} to use; can not be null.
     * 
     * @return the Range as a String formatted in the given {@link CoordinateSystem};
     * will never be null.
     * 
     * @throws NullPointerException if coordinateSystem is null.
     */
    public String toString(CoordinateSystem coordinateSystem)
    {
<span class="fc" id="L1022">    	return toString((b,e,cs) -&gt; &quot;[ &quot; + b + &quot; .. &quot; + e+&quot; ]/&quot; + cs.getAbbreviatedName(), coordinateSystem);</span>
       
    }
   /**
    * Generate a new String representation of this Range using
    * the given {@link RangeToStringFunction} with this Range's begin
    * and end coordinates in zero based coordinate system.
    * 
    * @param function the {@link RangeToStringFunction} to create String with; can not be null.
    * @return a new String; should not be null.
    * 
    * @throws NullPointerException if function is null.
    * 
    * @since 5.2
    * 
    * @implNote this is the same as 
    * {@link #toString(RangeToStringFunction, CoordinateSystem) toString(function, CoordinateSystem.ZERO_BASED)}.
    */
    public String toString(RangeToStringFunction function){
<span class="fc" id="L1041">        return toString(function, CoordinateSystem.ZERO_BASED);</span>
    }
    /**
     * Generate a new String representation of this Range using
     * the given {@link RangeToStringFunction} with this Range's begin
     * and end coordinates converted into the given CoordinateSystem.
     * 
     * @param function the {@link RangeToStringFunction} to create String with; can not be null.
     * @param coordinateSystem the CoordinateSystem to use to convert the begin and end values to pass into the function.
     * 
     * @return a new String; should not be null.
     * 
     * @throws NullPointerException if either parameter is null.
     * 
     * @since 5.2
     */
    public String toString(RangeToStringFunction function, CoordinateSystem coordinateSystem){
<span class="fc" id="L1058">        Objects.requireNonNull(coordinateSystem);</span>
<span class="fc" id="L1059">        return function.apply(</span>
<span class="fc" id="L1060">                        coordinateSystem.getLocalStart(getBegin()) ,</span>
<span class="fc" id="L1061">                        coordinateSystem.getLocalEnd(getEnd()));</span>
    }
    /**
     * Generate a new String representation of this Range using
     * the given {@link RangeAndCoordinateSystemToStringFunction} with this Range's begin
     * and end coordinates in zero based coordinate system.
     * 
     * @param function the {@link RangeAndCoordinateSystemToStringFunction} to create String with; can not be null.
     * @return a new String; should not be null.
     * 
     * @throws NullPointerException if function is null.
     * 
     * @since 5.2
     * 
     * @implNote this is the same as 
     * {@link #toString(RangeAndCoordinateSystemToStringFunction, CoordinateSystem) toString(function, CoordinateSystem.ZERO_BASED)}.
     */
    public String toString(RangeAndCoordinateSystemToStringFunction function){
<span class="nc" id="L1079">        return toString(function, CoordinateSystem.ZERO_BASED);</span>
    }
    /**
     * Generate a new String representation of this Range using
     * the given {@link RangeAndCoordinateSystemToStringFunction} with this Range's begin
     * and end coordinates converted into the given CoordinateSystem.
     * 
     * @param function the {@link RangeAndCoordinateSystemToStringFunction} to create String with; can not be null.
     * @param coordinateSystem the CoordinateSystem to use to convert the begin and end values to pass into the function.
     * 
     * @return a new String; should not be null.
     * 
     * @throws NullPointerException if either parameter is null.
     * 
     * @since 5.2
     */
    public String toString(RangeAndCoordinateSystemToStringFunction function, CoordinateSystem coordinateSystem){
<span class="fc" id="L1096">        Objects.requireNonNull(coordinateSystem);</span>
<span class="fc" id="L1097">        return function.apply(</span>
<span class="fc" id="L1098">                        coordinateSystem.getLocalStart(getBegin()) ,</span>
<span class="fc" id="L1099">                        coordinateSystem.getLocalEnd(getEnd()),</span>
                        coordinateSystem);
    }
    /**
     * Functional interface to generate a toString() string
     * for the given range coordinates only.
     * 
     * @author dkatzel
     *
     * @since 5.2
     * 
     * @see RangeAndCoordinateSystemToStringFunction
     * @see #toString(RangeToStringFunction)
     * @see #toString(RangeToStringFunction, CoordinateSystem)
     */
    @FunctionalInterface
    interface RangeToStringFunction{
        /**
         * Generate a toString() String for a Range
         * with the given begin and end coordinates
         * that have already been translated into the local
         * coordinate system (zero based, residue based etc)
         * 
         * @param begin the local begin coordinate of this Range.
         * @param end the local end coordinate of this Range.
         * 
         * @return a new String object; should not be null.
         */
        String apply(long begin, long end);
    }
    /**
     * Functional interface to generate a toString() string
     * for the given range coordinates and the {@link CoordinateSystem}
     * that was used to compute those coordinates.
     * 
     * @author dkatzel
     *
     * @since 5.2
     * 
     * @see RangeToStringFunction
     * @see #toString(RangeAndCoordinateSystemToStringFunction)
     * @see #toString(RangeAndCoordinateSystemToStringFunction, CoordinateSystem)
     */
    @FunctionalInterface
    interface RangeAndCoordinateSystemToStringFunction{
        /**
         * Generate a toString() String for a Range
         * with the given begin and end coordinates
         * that have already been translated into the local
         * coordinate system (zero based, residue based etc)
         * 
         * @param begin the local begin coordinate of this Range.
         * @param end the local end coordinate of this Range.
         * @param coordinateSystem the {@link CoordinateSystem} that was 
         *              used to compute the other parameters; will never be null.
         * 
         * @return a new String object; should not be null.
         */
        String apply(long begin, long end, CoordinateSystem coordinateSystem);
    }

    @Override
    public Iterator&lt;Long&gt; iterator() {
<span class="fc" id="L1162">        return new RangeIterator(this);</span>
    }
    
   
    /**
     * Splits a Range into a List of possibly several adjacent Range objects
     * where each of the returned ranges has a max length specified.
     * @param maxSplitLength the max length any of the returned split ranges can be.
     * @return a List of split Ranges; never null or empty but may
     * just be a single element if this Range is smaller than the max length
     * specified.
     * @throws IllegalArgumentException if maxSplitLength
     * &amp;lt; 1.
     */
    public List&lt;Range&gt; split(long maxSplitLength){
<span class="fc bfc" id="L1177" title="All 2 branches covered.">    	if(maxSplitLength &lt;1){</span>
<span class="fc" id="L1178">    		throw new IllegalArgumentException(&quot;max splitLength must be &gt;= 1&quot;);</span>
    	}
<span class="fc" id="L1180">    	List&lt;Range&gt; list = new ArrayList&lt;Range&gt;();</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        if(getLength()&lt;maxSplitLength){</span>
<span class="fc" id="L1182">            list.add(this);</span>
        }else{
<span class="fc" id="L1184">	        long currentStart=getBegin();	        </span>
<span class="fc" id="L1185">	        long end = getEnd();</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">			while(currentStart&lt;=end){</span>
<span class="fc" id="L1187">	            long endCoordinate = Math.min(end, currentStart+maxSplitLength-1);</span>
<span class="fc" id="L1188">	            list.add(Range.of(currentStart, endCoordinate));</span>
<span class="fc" id="L1189">	            currentStart = currentStart+maxSplitLength;</span>
<span class="fc" id="L1190">	        }</span>
        }
<span class="fc" id="L1192">        return list;</span>
    }
    /**
     * Loop over each offset value in this range using the given
     * coordinate system.  This method is preferred
     * over {@link Iterable#forEach(java.util.function.Consumer)} because
     * that method must autobox the primitive longs into Long objects;
     * in addition, the coordinate system couldn't be specified.
     * 
     * 
     * @apiNote this will automatically convert the coordinates of each offset
     * into the given coordinate system.  For example if the range is from offsets 0 - 9,
     * then calling this method with a {@value CoordinateSystem#RESIDUE_BASED}
     * will call the consumer for 1..10.
     *  
     * @param cs the CoordinateSystem to use; can not be null.
     * @param consumer the {@link LongConsumer} to call for each offset; can not be null.
     * 
     * @throws NullPointerException if either parameter is null.
     */
    public void forEachValue(CoordinateSystem cs, LongConsumer consumer){
<span class="fc" id="L1213">        Objects.requireNonNull(cs);</span>
<span class="fc" id="L1214">        Objects.requireNonNull(consumer);</span>
        
<span class="fc" id="L1216">        long begin = getBegin(cs);</span>
<span class="fc" id="L1217">        long end = getEnd(cs);</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">        for(long l = begin; l &lt;=end; l++){</span>
<span class="fc" id="L1219">            consumer.accept(l);</span>
        }
<span class="fc" id="L1221">    }</span>
    
    /**
     * Convenience method for {@link #forEachValue(CoordinateSystem, LongConsumer)}
     * with {@value CoordinateSystem#ZERO_BASED} coordinate system.
     * 
     * @param consumer the {@link LongConsumer} to call for each offset; can not be null.
     * 
     * @throws NullPointerException if consumer is null.
     */
    public void forEachValue(LongConsumer consumer){
<span class="fc" id="L1232">       forEachValue(CoordinateSystem.ZERO_BASED, consumer);</span>
<span class="fc" id="L1233">    }</span>
    /**
     * Get the length of this range.
     * @return the length;
     * will always be &amp;ge; 0.
     */
    @Override
    public long getLength() {
<span class="fc" id="L1241">    	 return getEnd() - getBegin() + 1;</span>
    }
    /**
    * {@inheritDoc} 
    * &lt;p&gt;
    * Returns this since it is already a Range.
    * @return this.
    */
    @Override
    public Range asRange() {
<span class="fc" id="L1251">        return this;</span>
    }
    //serialization methods need to be protected
    //so the subclasses inherit them!
    /**
     * writeReplace method that must be called
     * by subclasses for serialization
     * using the Serialzation Proxy Class.
     * 
     * @return a new RangeProxy to handle
     * serialization for us.
     */
    protected Object writeReplace(){
<span class="fc" id="L1264">		return new RangeProxy(this);</span>
	}
    /**
     * readObject method that must be called
     * by subclasses for serialization
     * using the Serialzation Proxy Class.
     * 
     * @param stream the {@link ObjectInputStream} to read from.
     * 
     * @throws java.io.InvalidObjectException always
     * to prevent users from constructing
     * invalid objects.
     */
	protected void readObjectTemplate(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1278">		throw new java.io.InvalidObjectException(&quot;Proxy required&quot;);</span>
	}
	/**
	 * Serialization Proxy Pattern object to handle
	 * serialization of Range objects.  This allows us
	 * to change Range fields and subclasses without
	 * breaking serialization.
	 * 
	 * @author dkatzel
	 *
	 */
	private static final class RangeProxy implements Serializable{


		private static final long serialVersionUID = -4585616544869644009L;
		
		private final long begin,end;
		
<span class="fc" id="L1296">		RangeProxy(Range range){</span>
<span class="fc" id="L1297">			begin = range.getBegin();</span>
<span class="fc" id="L1298">			end = range.getEnd();</span>
<span class="fc" id="L1299">		}</span>
		
		private Object readResolve(){
<span class="fc" id="L1302">			return Range.of(begin, end);</span>
		}
	}
    
    private static class RangeIterator implements Iterator&lt;Long&gt;{
        private final long from;
        private final long to;
        private long index;
        
<span class="fc" id="L1311">        public RangeIterator(Range range){</span>
<span class="fc" id="L1312">            from = range.getBegin();</span>
<span class="fc" id="L1313">            to = range.getEnd();</span>
<span class="fc" id="L1314">            index = from;</span>
<span class="fc" id="L1315">        }</span>
        @Override
        public boolean hasNext() {
        	//have to handle special case where end
        	//coordinate is Long.MAX_VALUE since
        	//all longs are &lt;= MAX value
        	//see Java Puzzlers Puzzle #26 for more info
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        	if(to == Long.MAX_VALUE){</span>
        		//if we wrap around to a number
        		//less than our starting point
        		//we know we overflowed
        		//so we have passed MAX_VALUE
        		//(or we are an empty range which
        		//wouldn't have a next anyway)
<span class="pc bpc" id="L1329" title="1 of 4 branches missed.">        		return index &gt;= from &amp;&amp; index !=to;</span>
        	}else{
<span class="fc bfc" id="L1331" title="All 2 branches covered.">        		return index&lt;=to;</span>
        	}
        }

        @Override
        public Long next() {
<span class="fc bfc" id="L1337" title="All 2 branches covered.">        	if(!hasNext()){</span>
<span class="fc" id="L1338">        		throw new NoSuchElementException();</span>
        	}
<span class="fc" id="L1340">            return index++;</span>
        }

        @Override
        public void remove() {
<span class="fc" id="L1345">            throw new UnsupportedOperationException(&quot;can not remove from Range&quot;);</span>
            
        }
        
    }
    /**
     * Range implementation that stores the 
     * start and end coordinates as longs.
     * @author dkatzel
     *
     */
    private static final class LongRange extends Range{

		private static final long serialVersionUID = -9049228665266839643L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient long start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient long end;
        
<span class="fc" id="L1372">    	private LongRange(long start, long end){</span>
<span class="fc" id="L1373">    		 this.start = start;</span>
<span class="fc" id="L1374">	        this.end = end;</span>
<span class="fc" id="L1375">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1387">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L1398">            return end;</span>
        }
		@Override
		public int hashCode() {
<span class="fc" id="L1402">			final int prime = 31;</span>
<span class="fc" id="L1403">			int result = 1;</span>
<span class="fc" id="L1404">			result = prime * result + (int) (end ^ (end &gt;&gt;&gt; 32));</span>
<span class="fc" id="L1405">			result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="fc" id="L1406">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1411" title="All 2 branches covered.">			if (this == obj){</span>
<span class="fc" id="L1412">				return true;</span>
			}
<span class="fc bfc" id="L1414" title="All 2 branches covered.">			if (obj == null){</span>
<span class="fc" id="L1415">				return false;</span>
			}
<span class="fc bfc" id="L1417" title="All 2 branches covered.">			if (getClass() != obj.getClass()){</span>
<span class="fc" id="L1418">				return false;</span>
			}
<span class="fc" id="L1420">			LongRange other = (LongRange) obj;</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">			if (end != other.end){</span>
<span class="fc" id="L1422">				return false;</span>
			}
<span class="fc bfc" id="L1424" title="All 2 branches covered.">			if (start != other.start){</span>
<span class="fc" id="L1425">				return false;</span>
			}
<span class="fc" id="L1427">			return true;</span>
		}
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1431">			readObjectTemplate(stream);</span>
<span class="nc" id="L1432">		}</span>
    	
    }
    /**
     * Range implementation that stores the 
     * start and end coordinates as ints.
     * @author dkatzel
     *
     */
    private static final class IntRange extends Range{
        
		private static final long serialVersionUID = 6542145038027107374L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient int start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  int end;
        
<span class="fc" id="L1457">    	private IntRange(int start, int end){</span>
<span class="fc" id="L1458">    		 this.start = start;</span>
<span class="fc" id="L1459">	        this.end = end;</span>
<span class="fc" id="L1460">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1472">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L1483">            return end;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L1488">			final int prime = 31;</span>
<span class="fc" id="L1489">			int result = 1;</span>
<span class="fc" id="L1490">			result = prime * result + end;</span>
<span class="fc" id="L1491">			result = prime * result + start;</span>
<span class="fc" id="L1492">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1497" title="All 2 branches covered.">			if (this == obj){</span>
<span class="fc" id="L1498">				return true;</span>
			}
<span class="fc bfc" id="L1500" title="All 2 branches covered.">			if (obj == null){</span>
<span class="fc" id="L1501">				return false;</span>
			}
<span class="fc bfc" id="L1503" title="All 2 branches covered.">			if (getClass() != obj.getClass()){</span>
<span class="fc" id="L1504">				return false;</span>
			}
<span class="fc" id="L1506">			IntRange other = (IntRange) obj;</span>
<span class="fc bfc" id="L1507" title="All 2 branches covered.">			if (end != other.end){</span>
<span class="fc" id="L1508">				return false;</span>
			}
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">			if (start != other.start){</span>
<span class="nc" id="L1511">				return false;</span>
			}
<span class="fc" id="L1513">			return true;</span>
		}
		
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1519">			readObjectTemplate(stream);</span>
<span class="nc" id="L1520">		}</span>
    }
    
   
    /**
     * Range implementation that stores the 
     * start and end coordinates as shorts.
     * @author dkatzel
     *
     */
    private static final class ShortRange extends Range{

		private static final long serialVersionUID = 8067459912024393712L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient short start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  short end;
        
<span class="fc" id="L1546">    	private ShortRange(short start, short end){</span>
<span class="fc" id="L1547">    		 this.start = start;</span>
<span class="fc" id="L1548">	        this.end = end;</span>
<span class="fc" id="L1549">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1561">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L1572">            return end;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L1577">			final int prime = 31;</span>
<span class="fc" id="L1578">			int result = 1;</span>
<span class="fc" id="L1579">			result = prime * result + end;</span>
<span class="fc" id="L1580">			result = prime * result + start;</span>
<span class="fc" id="L1581">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1586" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L1587">				return true;</span>
			}
<span class="fc bfc" id="L1589" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L1590">				return false;</span>
			}
<span class="fc bfc" id="L1592" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L1593">				return false;</span>
			}
<span class="fc" id="L1595">			ShortRange other = (ShortRange) obj;</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">			if (end != other.end) {</span>
<span class="fc" id="L1597">				return false;</span>
			}
<span class="fc bfc" id="L1599" title="All 2 branches covered.">			if (start != other.start) {</span>
<span class="fc" id="L1600">				return false;</span>
			}
<span class="fc" id="L1602">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1607">			readObjectTemplate(stream);</span>
<span class="nc" id="L1608">		}</span>
    }
    
   
    /**
     * Range implementation that stores the 
     * start and end coordinates as bytes.
     * @author dkatzel
     *
     */
    private static final class ByteRange extends Range{
    	
		private static final long serialVersionUID = 4169626247473789826L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  byte end;
        
<span class="fc" id="L1634">    	private ByteRange(byte start, byte end){</span>
<span class="fc" id="L1635">    		 this.start = start;</span>
<span class="fc" id="L1636">	        this.end = end;</span>
<span class="fc" id="L1637">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1649">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L1660">            return end;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L1665">			final int prime = 31;</span>
<span class="fc" id="L1666">			int result = 1;</span>
<span class="fc" id="L1667">			result = prime * result + end;</span>
<span class="fc" id="L1668">			result = prime * result + start;</span>
<span class="fc" id="L1669">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1674" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L1675">				return true;</span>
			}
<span class="fc bfc" id="L1677" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L1678">				return false;</span>
			}
<span class="fc bfc" id="L1680" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L1681">				return false;</span>
			}
<span class="fc" id="L1683">			ByteRange other = (ByteRange) obj;</span>
<span class="fc bfc" id="L1684" title="All 2 branches covered.">			if (end != other.end) {</span>
<span class="fc" id="L1685">				return false;</span>
			}
<span class="fc bfc" id="L1687" title="All 2 branches covered.">			if (start != other.start) {</span>
<span class="fc" id="L1688">				return false;</span>
			}
<span class="fc" id="L1690">			return true;</span>
		}
    	
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1695">			readObjectTemplate(stream);</span>
<span class="nc" id="L1696">		}</span>
    }
    
    
    
    /**
     * Range implementation that stores the 
     * start coordinates as an unsigned byte
     * and the length as an unsigned short.
     * This is commonly used for next-gen length
     * valid ranges or next-gen reads placed in the beginning
     * of contigs/scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedByteStartShortLengthRange extends Range{
    	
		private static final long serialVersionUID = 8988060061626955851L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  short length;
        
<span class="fc" id="L1727">    	private UnsignedByteStartShortLengthRange(short start, int length){</span>
<span class="fc" id="L1728">    		this.start = IOUtil.toSignedByte(start);</span>
<span class="fc" id="L1729">	        this.length = IOUtil.toSignedShort(length);</span>
	       
<span class="fc" id="L1731">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1743">            return IOUtil.toUnsignedByte(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getLength() {
<span class="fc" id="L1754">            return IOUtil.toUnsignedShort(length);</span>
        }

    	@Override
    	public long getEnd(){
<span class="fc" id="L1759">    		return getBegin() + getLength() -1;</span>
    	}
		@Override
		public int hashCode() {
<span class="fc" id="L1763">			final int prime = 31;</span>
<span class="fc" id="L1764">			int result = 1;</span>
<span class="fc" id="L1765">			result = prime * result + length;</span>
<span class="fc" id="L1766">			result = prime * result + start;</span>
<span class="fc" id="L1767">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1772" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L1773">				return true;</span>
			}
<span class="fc bfc" id="L1775" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L1776">				return false;</span>
			}
<span class="fc bfc" id="L1778" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L1779">				return false;</span>
			}
<span class="fc" id="L1781">			UnsignedByteStartShortLengthRange other = (UnsignedByteStartShortLengthRange) obj;</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L1783">				return false;</span>
			}
<span class="fc bfc" id="L1785" title="All 2 branches covered.">			if (start != other.start) {</span>
<span class="fc" id="L1786">				return false;</span>
			}
<span class="fc" id="L1788">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1793">			readObjectTemplate(stream);</span>
<span class="nc" id="L1794">		}</span>
    }
    
   
    
    /**
     * Range implementation that stores the 
     * start coordinates as an unsigned byte
     * and the length as an unsigned int.
     * This is commonly used for contigs
     * placed in the beginning
     * of scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedByteStartIntLengthRange extends Range{

		private static final long serialVersionUID = -8157832996658862640L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  int length;
        
<span class="fc" id="L1825">    	private UnsignedByteStartIntLengthRange(short start, long length){</span>
<span class="fc" id="L1826">    		this.start = IOUtil.toSignedByte(start);</span>
<span class="fc" id="L1827">	        this.length = IOUtil.toSignedInt(length);</span>
	       
<span class="fc" id="L1829">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1841">            return IOUtil.toUnsignedByte(start);</span>
        }

    	@Override
        public long getLength() {
<span class="fc" id="L1846">            return IOUtil.toUnsignedInt(length);</span>
        }

    	@Override
    	public long getEnd(){
<span class="fc" id="L1851">    		return getBegin() + getLength() -1;</span>
    	}
		@Override
		public int hashCode() {
<span class="fc" id="L1855">			final int prime = 31;</span>
<span class="fc" id="L1856">			int result = 1;</span>
<span class="fc" id="L1857">			result = prime * result + length;</span>
<span class="fc" id="L1858">			result = prime * result + start;</span>
<span class="fc" id="L1859">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1864" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L1865">				return true;</span>
			}
<span class="fc bfc" id="L1867" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L1868">				return false;</span>
			}
<span class="fc bfc" id="L1870" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L1871">				return false;</span>
			}
<span class="fc" id="L1873">			UnsignedByteStartIntLengthRange other = (UnsignedByteStartIntLengthRange) obj;</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L1875">				return false;</span>
			}
<span class="pc bpc" id="L1877" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1878">				return false;</span>
			}
<span class="fc" id="L1880">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1885">			readObjectTemplate(stream);</span>
<span class="nc" id="L1886">		}</span>
    }
    
    /**
     * Range implementation that stores the 
     * start coordinates as an unsigned byte
     * and the length as a long.
     * This is commonly used for large contig
     * or scaffold ranges.
     * @author dkatzel
     *
     */
    private static final class UnsignedByteStartLongLengthRange extends Range{

		private static final long serialVersionUID = 7162925703817321503L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  long length;
        
<span class="fc" id="L1914">    	private UnsignedByteStartLongLengthRange(short start, long length){</span>
<span class="fc" id="L1915">    		this.start = IOUtil.toSignedByte(start);</span>
<span class="fc" id="L1916">	        this.length = length;</span>
	       
<span class="fc" id="L1918">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1930">            return IOUtil.toUnsignedByte(start);</span>
        }

    	@Override
        public long getLength() {
<span class="fc" id="L1935">            return length;</span>
        }

    	@Override
    	public long getEnd(){
<span class="fc" id="L1940">    		return getBegin() + getLength() -1;</span>
    	}

		@Override
		public int hashCode() {
<span class="fc" id="L1945">			final int prime = 31;</span>
<span class="fc" id="L1946">			int result = 1;</span>
<span class="fc" id="L1947">			result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="fc" id="L1948">			result = prime * result + start;</span>
<span class="fc" id="L1949">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1954" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L1955">				return true;</span>
			}
<span class="fc bfc" id="L1957" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L1958">				return false;</span>
			}
<span class="fc bfc" id="L1960" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L1961">				return false;</span>
			}
<span class="fc" id="L1963">			UnsignedByteStartLongLengthRange other = (UnsignedByteStartLongLengthRange) obj;</span>
<span class="fc bfc" id="L1964" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L1965">				return false;</span>
			}
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1968">				return false;</span>
			}
<span class="fc" id="L1970">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L1975">			readObjectTemplate(stream);</span>
<span class="nc" id="L1976">		}</span>
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned shorts
     * and the length as an unsigned byte.
     * This is probably the most common read valid
     * range for next-gen sequencing.
     * @author dkatzel
     *
     */
    private static final class UnsignedShortStartShortLengthRange extends Range{

		private static final long serialVersionUID = -3396601756878334868L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient short start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  short length;
        
<span class="fc" id="L2004">    	private UnsignedShortStartShortLengthRange(int start, int length){</span>
<span class="fc" id="L2005">    		 this.start = IOUtil.toSignedShort(start);</span>
<span class="fc" id="L2006">	        this.length = IOUtil.toSignedShort(length);</span>
<span class="fc" id="L2007">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L2011">			return IOUtil.toUnsignedShort(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L2024">            return IOUtil.toUnsignedShort(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L2035">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L2040">			final int prime = 31;</span>
<span class="fc" id="L2041">			int result = 1;</span>
<span class="fc" id="L2042">			result = prime * result + length;</span>
<span class="fc" id="L2043">			result = prime * result + start;</span>
<span class="fc" id="L2044">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2049" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2050">				return true;</span>
			}
<span class="fc bfc" id="L2052" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2053">				return false;</span>
			}
<span class="fc bfc" id="L2055" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2056">				return false;</span>
			}
<span class="fc" id="L2058">			UnsignedShortStartShortLengthRange other = (UnsignedShortStartShortLengthRange) obj;</span>
<span class="fc bfc" id="L2059" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L2060">				return false;</span>
			}
<span class="fc bfc" id="L2062" title="All 2 branches covered.">			if (start != other.start) {</span>
<span class="fc" id="L2063">				return false;</span>
			}
<span class="fc" id="L2065">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2070">			readObjectTemplate(stream);</span>
<span class="nc" id="L2071">		}</span>
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned shorts
     * and the length as an unsigned byte.
     * This is probably the most common read valid
     * range for next-gen sequencing.
     * @author dkatzel
     *
     */
    private static final class UnsignedShortStartIntLengthRange extends Range{

		private static final long serialVersionUID = -7100338012680013390L;

		/**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  int length;
        
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient short start;
        
<span class="fc" id="L2099">    	private UnsignedShortStartIntLengthRange(int start, long length){</span>
<span class="fc" id="L2100">    		 this.start = IOUtil.toSignedShort(start);</span>
<span class="fc" id="L2101">	        this.length = IOUtil.toSignedInt(length);</span>
<span class="fc" id="L2102">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L2106">			return IOUtil.toUnsignedInt(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L2119">            return IOUtil.toUnsignedShort(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L2130">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L2135">			final int prime = 31;</span>
<span class="fc" id="L2136">			int result = 1;</span>
<span class="fc" id="L2137">			result = prime * result + length;</span>
<span class="fc" id="L2138">			result = prime * result + start;</span>
<span class="fc" id="L2139">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2144" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2145">				return true;</span>
			}
<span class="fc bfc" id="L2147" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2148">				return false;</span>
			}
<span class="fc bfc" id="L2150" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2151">				return false;</span>
			}
<span class="fc" id="L2153">			UnsignedShortStartIntLengthRange other = (UnsignedShortStartIntLengthRange) obj;</span>
<span class="fc bfc" id="L2154" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L2155">				return false;</span>
			}
<span class="pc bpc" id="L2157" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2158">				return false;</span>
			}
<span class="fc" id="L2160">			return true;</span>
		}
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2164">			readObjectTemplate(stream);</span>
<span class="nc" id="L2165">		}</span>
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned shorts
     * and the length as an long.
     * This is often used to placed
     * contigs in scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedShortStartLongLengthRange extends Range{

		private static final long serialVersionUID = -1165486112049464271L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient short start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  long length;
        
<span class="fc" id="L2193">    	private UnsignedShortStartLongLengthRange(int start, long length){</span>
<span class="fc" id="L2194">    		 this.start = IOUtil.toSignedShort(start);</span>
<span class="fc" id="L2195">	        this.length = length;</span>
<span class="fc" id="L2196">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L2200">			return length;</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L2213">            return IOUtil.toUnsignedShort(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L2224">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L2229">			final int prime = 31;</span>
<span class="fc" id="L2230">			int result = 1;</span>
<span class="fc" id="L2231">			result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="fc" id="L2232">			result = prime * result + start;</span>
<span class="fc" id="L2233">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2238" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2239">				return true;</span>
			}
<span class="fc bfc" id="L2241" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2242">				return false;</span>
			}
<span class="fc bfc" id="L2244" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2245">				return false;</span>
			}
<span class="fc" id="L2247">			UnsignedShortStartLongLengthRange other = (UnsignedShortStartLongLengthRange) obj;</span>
<span class="fc bfc" id="L2248" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L2249">				return false;</span>
			}
<span class="pc bpc" id="L2251" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2252">				return false;</span>
			}
<span class="fc" id="L2254">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2259">			readObjectTemplate(stream);</span>
<span class="nc" id="L2260">		}</span>
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned int
     * and the length as an unsigned byte.
     * This is often used for placing contigs
     * at the middle/ends of scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedIntStartIntLengthRange extends Range{

		private static final long serialVersionUID = 6452717883182530834L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient int start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  int length;
        
<span class="fc" id="L2288">    	private UnsignedIntStartIntLengthRange(long start, long length){</span>
<span class="fc" id="L2289">    		 this.start = IOUtil.toSignedInt(start);</span>
<span class="fc" id="L2290">	        this.length = IOUtil.toSignedInt(length);</span>
<span class="fc" id="L2291">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L2295">			return IOUtil.toUnsignedInt(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L2308">            return IOUtil.toUnsignedInt(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L2319">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L2324">			final int prime = 31;</span>
<span class="fc" id="L2325">			int result = 1;</span>
<span class="fc" id="L2326">			result = prime * result + length;</span>
<span class="fc" id="L2327">			result = prime * result + start;</span>
<span class="fc" id="L2328">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2333" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2334">				return true;</span>
			}
<span class="fc bfc" id="L2336" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2337">				return false;</span>
			}
<span class="fc bfc" id="L2339" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2340">				return false;</span>
			}
<span class="fc" id="L2342">			UnsignedIntStartIntLengthRange other = (UnsignedIntStartIntLengthRange) obj;</span>
<span class="fc bfc" id="L2343" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L2344">				return false;</span>
			}
<span class="pc bpc" id="L2346" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2347">				return false;</span>
			}
<span class="fc" id="L2349">			return true;</span>
		}
		
	
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2355">			readObjectTemplate(stream);</span>
<span class="nc" id="L2356">		}</span>
    }
    
    /**
     * Range implementation that stores the 
     * start as an unsigned int
     * and the length as an long.
     * This is often used to placed
     * contigs in scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedIntStartLongLengthRange extends Range{

		private static final long serialVersionUID = -117640702327997461L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient int start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  long length;
        
<span class="fc" id="L2384">    	private UnsignedIntStartLongLengthRange(long start, long length){</span>
<span class="fc" id="L2385">    		 this.start = IOUtil.toSignedInt(start);</span>
<span class="fc" id="L2386">	        this.length = length;</span>
<span class="fc" id="L2387">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L2391">			return length;</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L2404">            return IOUtil.toUnsignedInt(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L2415">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L2420">			final int prime = 31;</span>
<span class="fc" id="L2421">			int result = 1;</span>
<span class="fc" id="L2422">			result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="fc" id="L2423">			result = prime * result + start;</span>
<span class="fc" id="L2424">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2429" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2430">				return true;</span>
			}
<span class="fc bfc" id="L2432" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2433">				return false;</span>
			}
<span class="fc bfc" id="L2435" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2436">				return false;</span>
			}
<span class="fc" id="L2438">			UnsignedIntStartLongLengthRange other = (UnsignedIntStartLongLengthRange) obj;</span>
<span class="fc bfc" id="L2439" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L2440">				return false;</span>
			}
<span class="pc bpc" id="L2442" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2443">				return false;</span>
			}
<span class="fc" id="L2445">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2450">			readObjectTemplate(stream);</span>
<span class="nc" id="L2451">		}</span>
    }
    /**
     * Range implementation that stores the 
     * start as signed long
     * and the length as an unsigned byte.
     * This is often used for placing contigs
     * at the middle/ends of scaffolds.
     * @author dkatzel
     *
     */
    private static final class LongStartIntLengthRange extends Range{
    	
		private static final long serialVersionUID = -8753338879553066878L;

		/**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient long start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final transient  int length;
        
<span class="fc" id="L2478">    	private LongStartIntLengthRange(long start, long length){</span>
<span class="fc" id="L2479">    		 this.start = start;</span>
<span class="fc" id="L2480">	        this.length = IOUtil.toSignedInt(length);</span>
<span class="fc" id="L2481">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L2485">			return IOUtil.toUnsignedInt(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L2498">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L2509">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="fc" id="L2514">			final int prime = 31;</span>
<span class="fc" id="L2515">			int result = 1;</span>
<span class="fc" id="L2516">			result = prime * result + length;</span>
<span class="fc" id="L2517">			result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="fc" id="L2518">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2523" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2524">				return true;</span>
			}
<span class="fc bfc" id="L2526" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2527">				return false;</span>
			}
<span class="fc bfc" id="L2529" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2530">				return false;</span>
			}
<span class="fc" id="L2532">			LongStartIntLengthRange other = (LongStartIntLengthRange) obj;</span>
<span class="fc bfc" id="L2533" title="All 2 branches covered.">			if (length != other.length) {</span>
<span class="fc" id="L2534">				return false;</span>
			}
<span class="pc bpc" id="L2536" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2537">				return false;</span>
			}
<span class="fc" id="L2539">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2544">			readObjectTemplate(stream);</span>
<span class="nc" id="L2545">		}</span>

		
    }
  
    
    
    private static final class EmptyByteRange extends Range{

		private static final long serialVersionUID = 6052661929330419290L;
		
		private final transient byte coordinate;
    	
<span class="fc" id="L2558">    	EmptyByteRange(byte coordinate){</span>
<span class="fc" id="L2559">    		this.coordinate = coordinate;</span>
<span class="fc" id="L2560">    	}</span>

		@Override
		public long getBegin() {
<span class="fc" id="L2564">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="fc" id="L2569">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L2574">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L2579">			final int prime = 31;</span>
<span class="fc" id="L2580">			int result = 1;</span>
<span class="fc" id="L2581">			result = prime * result + coordinate;</span>
<span class="fc" id="L2582">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2587" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2588">				return true;</span>
			}
<span class="fc bfc" id="L2590" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2591">				return false;</span>
			}
<span class="fc bfc" id="L2593" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2594">				return false;</span>
			}
<span class="fc" id="L2596">			EmptyByteRange other = (EmptyByteRange) obj;</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">			if (coordinate != other.coordinate) {</span>
<span class="fc" id="L2598">				return false;</span>
			}
<span class="fc" id="L2600">			return true;</span>
		}
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2604">			readObjectTemplate(stream);</span>
<span class="nc" id="L2605">		}</span>
    	
    }
    
    private static final class EmptyShortRange extends Range{

		private static final long serialVersionUID = 3993935906380566318L;
		private final transient short coordinate;
    	
<span class="fc" id="L2614">    	EmptyShortRange(short coordinate){</span>
<span class="fc" id="L2615">    		this.coordinate = coordinate;</span>
<span class="fc" id="L2616">    	}</span>

		@Override
		public long getBegin() {
<span class="fc" id="L2620">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="fc" id="L2625">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L2630">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L2635">			final int prime = 31;</span>
<span class="fc" id="L2636">			int result = 1;</span>
<span class="fc" id="L2637">			result = prime * result + coordinate;</span>
<span class="fc" id="L2638">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2643" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2644">				return true;</span>
			}
<span class="fc bfc" id="L2646" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2647">				return false;</span>
			}
<span class="fc bfc" id="L2649" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2650">				return false;</span>
			}
<span class="fc" id="L2652">			EmptyShortRange other = (EmptyShortRange) obj;</span>
<span class="fc bfc" id="L2653" title="All 2 branches covered.">			if (coordinate != other.coordinate) {</span>
<span class="fc" id="L2654">				return false;</span>
			}
<span class="fc" id="L2656">			return true;</span>
		}
	
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2661">			readObjectTemplate(stream);</span>
<span class="nc" id="L2662">		}</span>
    }
    
    private static final class EmptyIntRange extends Range{

		private static final long serialVersionUID = -2154880669709555228L;
		private final transient int coordinate;
    	
<span class="fc" id="L2670">    	EmptyIntRange(int coordinate){</span>
<span class="fc" id="L2671">    		this.coordinate = coordinate;</span>
<span class="fc" id="L2672">    	}</span>

		@Override
		public long getBegin() {
<span class="fc" id="L2676">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="fc" id="L2681">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L2686">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L2691">			final int prime = 31;</span>
<span class="fc" id="L2692">			int result = 1;</span>
<span class="fc" id="L2693">			result = prime * result + coordinate;</span>
<span class="fc" id="L2694">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2699" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2700">				return true;</span>
			}
<span class="fc bfc" id="L2702" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2703">				return false;</span>
			}
<span class="fc bfc" id="L2705" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2706">				return false;</span>
			}
<span class="fc" id="L2708">			EmptyIntRange other = (EmptyIntRange) obj;</span>
<span class="fc bfc" id="L2709" title="All 2 branches covered.">			if (coordinate != other.coordinate) {</span>
<span class="fc" id="L2710">				return false;</span>
			}
<span class="fc" id="L2712">			return true;</span>
		}
		
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2717">			readObjectTemplate(stream);</span>
<span class="nc" id="L2718">		}</span>
    }
    
    private static final class EmptyLongRange extends Range{

		private static final long serialVersionUID = -5311954556848083143L;
		private final transient long coordinate;
    	
<span class="fc" id="L2726">    	EmptyLongRange(long coordinate){</span>
<span class="fc" id="L2727">    		this.coordinate = coordinate;</span>
<span class="fc" id="L2728">    	}</span>

		@Override
		public long getBegin() {
<span class="fc" id="L2732">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="fc" id="L2737">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L2742">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L2747">			final int prime = 31;</span>
<span class="fc" id="L2748">			int result = 1;</span>
<span class="fc" id="L2749">			result = prime * result + (int) (coordinate ^ (coordinate &gt;&gt;&gt; 32));</span>
<span class="fc" id="L2750">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L2755" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L2756">				return true;</span>
			}
<span class="fc bfc" id="L2758" title="All 2 branches covered.">			if (obj == null) {</span>
<span class="fc" id="L2759">				return false;</span>
			}
<span class="fc bfc" id="L2761" title="All 2 branches covered.">			if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L2762">				return false;</span>
			}
<span class="fc" id="L2764">			EmptyLongRange other = (EmptyLongRange) obj;</span>
<span class="fc bfc" id="L2765" title="All 2 branches covered.">			if (coordinate != other.coordinate) {</span>
<span class="fc" id="L2766">				return false;</span>
			}
<span class="fc" id="L2768">			return true;</span>
		}
		
		private void readObject(ObjectInputStream stream) throws java.io.InvalidObjectException{
<span class="nc" id="L2772">			readObjectTemplate(stream);</span>
<span class="nc" id="L2773">		}</span>
		
    }
    
    /**
     * {@code Builder} is a mutable object
     * that allows clients to create a 
     * {@link Range} object using the current
     * specification.  
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; {@link Builder#build()} is not guaranteed to return new instances and may return
     * a cached instance instead (flyweight pattern).
     * &lt;p&gt;
     * This class is not thread-safe.
     * @author dkatzel
     *
     */
    public static final class Builder implements Rangeable{
    	
    	private long begin;
    	private long end;
    	private final CoordinateSystem inputCoordinateSystem;
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to an 
    	 * empty range with a coordinate at the
    	 * origin (zero for {@link CoordinateSystem#ZERO_BASED}).
    	 */
    	public Builder(){
<span class="fc" id="L2802">    		this(0);</span>
<span class="fc" id="L2803">    	}</span>
    	public Builder(Builder copy){
<span class="fc" id="L2805">    		this(copy.inputCoordinateSystem, copy.begin, copy.end);</span>
<span class="fc" id="L2806">    	}</span>
    	
    	
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to the given
    	 * begin and end coordinates in zero-based
    	 * coordinate space.
    	 * This is equivalent to 
    	 * {@link Builder#Builder(CoordinateSystem, long, long)
    	 * new Builder(CoordinateSystem.ZERO_BASED, begin,end)}.
    	 * @param begin the initial  inclusive begin coordinate of the range in zero based coordinates. 
    	 * @param end the initial inclusive end coordinate in zero based coordinates. 
    	 * 
    	 *  @throws IllegalArgumentException if the given
    	 * begin and end coordiantes cause the
    	 * length to be negative.
    	 */
    	public Builder(long begin, long end){
<span class="fc" id="L2825">    		this(CoordinateSystem.ZERO_BASED, begin,end);</span>
<span class="fc" id="L2826">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to the given
    	 * begin and end coordinates in the
    	 * given coordinate space.
    	 * @param cs the {@link CoordinateSystem} these coordinates are
    	 * given in; can not be null.
    	 * @param begin the initial  begin coordinate of the range in the given
    	 * {@link CoordinateSystem}. 
    	 * @param end the initial end coordinate of the range in the given
    	 * {@link CoordinateSystem}.  
    	 * @throws NullPointerException if cs is null.
    	 * @throws IllegalArgumentException if the given
    	 * begin and end coordiantes cause the
    	 * length to be negative.
    	 */
<span class="fc" id="L2843">    	public Builder(CoordinateSystem cs,long begin, long end){</span>
<span class="fc bfc" id="L2844" title="All 2 branches covered.">    		if(cs ==null){</span>
<span class="fc" id="L2845">    			throw new NullPointerException(&quot;CoordinateSystem can not be null&quot;);</span>
    		}
<span class="fc" id="L2847">    		assertValidCoordinates(begin,end);</span>
<span class="fc" id="L2848">    		this.begin = cs.getStart(begin);</span>
<span class="fc" id="L2849">    		this.end = cs.getEnd(end);</span>
<span class="fc" id="L2850">    		this.inputCoordinateSystem = cs;</span>
    		
<span class="fc" id="L2852">    	}</span>
    	private void assertValidCoordinates(long begin, long end){
<span class="fc" id="L2854">    		long length = end-begin+1;</span>
<span class="fc bfc" id="L2855" title="All 2 branches covered.">    		if(length&lt;0){</span>
<span class="fc" id="L2856">    			throw new IllegalArgumentException(&quot;length can not be negative&quot;);</span>
    		}
<span class="fc" id="L2858">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to an 
    	 * range with a coordinate at the
    	 * origin (zero for {@link CoordinateSystem#ZERO_BASED})
    	 * and a length of the given length.
    	 * @param length the initial length of the range;
    	 * can not be {@literal &lt;0}.
    	 * @throws IllegalArgumentException if length {@literal &lt;0}.
    	 */
<span class="fc" id="L2869">    	public Builder(long length){</span>
<span class="fc bfc" id="L2870" title="All 2 branches covered.">    		if(length &lt;0){</span>
<span class="fc" id="L2871">    			throw new IllegalArgumentException(&quot;must be &gt;=0&quot;);</span>
    		}
<span class="fc" id="L2873">    		begin=0;</span>
<span class="fc" id="L2874">    		end = length-1;</span>
<span class="fc" id="L2875">    		inputCoordinateSystem = CoordinateSystem.ZERO_BASED;</span>
<span class="fc" id="L2876">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to have the same
    	 * begin and end coordinates as the given {@link Range}.
    	 * @param range the range to copy;
    	 * can not be null.
    	 * @throws NullPointerException if range is null.
    	 */
<span class="fc" id="L2885">    	public Builder(Range range){</span>
<span class="fc bfc" id="L2886" title="All 2 branches covered.">    		if(range ==null){</span>
<span class="fc" id="L2887">    			throw new NullPointerException(&quot;range can not be null&quot;);</span>
    		}
<span class="fc" id="L2889">    		begin=range.getBegin();</span>
<span class="fc" id="L2890">    		end = range.getEnd();</span>
<span class="fc" id="L2891">    		inputCoordinateSystem = CoordinateSystem.ZERO_BASED;</span>
<span class="fc" id="L2892">    	}</span>

    	/**
    	 * Shift the entire range by the given
    	 * amount of units. Both the begin and end coordinates
    	 * will be adjusted by the given value.  The length 
    	 * will remain the same. 
    	 * @param units the amount to shift. If this number
    	 * is positive, then the begin and end coordinates
    	 * will be increased; if this number is negative, 
    	 * then the begin and end coordinates will be decreased.
    	 * A value of 0 will cause no changes.
    	 * @return this.
    	 */
    	public Builder shift(long units){
<span class="fc" id="L2907">    		begin+=units;</span>
<span class="fc" id="L2908">    		end+=units;</span>
<span class="fc" id="L2909">    		return this;</span>
    	}
    	/**
    	 * Shrink the begin value by the given
    	 * amount of units.  This will add the given number
    	 * of  units to the begin coordinate which will also cause
    	 * the range's length to be shrunk by the given amount.
    	 * @param units the amount to shrink to the left. If this number
    	 * is negative, then that is the equivalent of growing
    	 * to the left by the given number of units
    	 * @return this.
    	 * @see #expandBegin(long)
    	 * @throws IllegalArgumentException if shrinking the begin
    	 * coordinate by the given amount causes the range's
    	 * length to be negative.
    	 */
    	public Builder contractBegin(long units){
<span class="fc" id="L2926">    		long newBegin = begin+units;</span>
<span class="fc" id="L2927">    		assertValidCoordinates(newBegin,end);</span>
<span class="fc" id="L2928">    		begin = newBegin;</span>
<span class="fc" id="L2929">    		return this;</span>
    	}
    	/**
    	 * Shrink the end value by the given
    	 * amount of units.  This will subtract the given number
    	 * of  units to the end coordinate which will also cause
    	 * the range's length to be shrunk by the given amount.
    	 * @param units the amount to shrink to the right. If this number
    	 * is negative, then that is the equivalent of growing
    	 * to the right by the given number of units
    	 * @return this.
    	 * @see #expandEnd(long)
    	 * @throws IllegalArgumentException if shrinking the end
    	 * coordinate by the given amount causes the range's
    	 * length to be negative.
    	 */
    	public Builder contractEnd(long units){
<span class="fc" id="L2946">    		long newEnd = end-units;</span>
<span class="fc" id="L2947">    		assertValidCoordinates(begin,newEnd);</span>
<span class="fc" id="L2948">    		end -=units;</span>
<span class="fc" id="L2949">    		return this;</span>
    	}
    	/**
    	 * Grows the begin value by the given
    	 * amount of units.  This will subtract the given number
    	 * of  units to the begin coordinate which will also cause
    	 * the range's length to be grown by the given amount.
    	 * @param units the amount to grow to the left. If this number
    	 * is negative, then that is the equivalent of shrinking
    	 * to the left by the given number of units
    	 * @return this.
    	 * @see #contractBegin(long)
    	 */
    	public Builder expandBegin(long units){
<span class="fc" id="L2963">    		begin-=units;</span>
<span class="fc" id="L2964">    		return this;</span>
    	}
    	/**
    	 * Grows the end value by the given
    	 * amount of units.  This will subtract the given number
    	 * of  units to the end coordinate which will also cause
    	 * the range's length to be grown by the given amount.
    	 * @param units the amount to grow to the right. If this number
    	 * is negative, then that is the equivalent of shrinking
    	 * to the right by the given number of units
    	 * @return this.
    	 * @see #contractEnd(long)
    	 */
    	public Builder expandEnd(long units){
<span class="fc" id="L2978">    		end +=units;</span>
<span class="fc" id="L2979">    		return this;</span>
    	}
    	
    	
    	/**
    	 * Get the current begin value.
    	 * @return the begin value in 0-based coordinate system.
    	 */
    	@Override
        public long getBegin() {
<span class="fc" id="L2989">			return begin;</span>
		}
    	/**
    	 * Explicitly set the begin value
    	 * in 0-based coordinate system.
    	 * Warning: this method does not check
    	 * that changing the begin
    	 * value won't cause an invalid range
    	 * based on the end value. (which won't get checked
    	 * until {@link #build()}).
    	 * 
    	 * @param begin the new begin coordinate to use.
    	 * 
    	 * @return this
    	 */
		public Builder setBegin(long begin) {
<span class="fc" id="L3005">			this.begin = begin;</span>
<span class="fc" id="L3006">			return this;</span>
		}
		/**
    	 * Get the current end value.
    	 * @return the end value in 0-based coordinate system.
    	 */
		@Override
        public long getEnd() {
<span class="fc" id="L3014">			return end;</span>
		}
		/**
    	 * Explicitly set the end value
    	 * in 0-based coordinate system.
    	 * Warning: this method does not check
    	 * that changing the end
    	 * value won't cause an invalid range
    	 * based on the begin value. (which won't get checked
    	 * until {@link #build()}).
    	 * 
    	 * @param end the new end coordinate to use.
    	 * 
    	 * @return this
    	 * 
    	 */
		public Builder setEnd(long end) {
<span class="fc" id="L3031">			this.end = end;</span>
<span class="fc" id="L3032">			return this;</span>
		}
		/**
		 * Get the current length of this Range.
		 * 
		 * @return the length; will never be negative.
		 * 
		 */
		@Override
        public long getLength(){
<span class="fc" id="L3042">			return end-begin+1;</span>
		}
		/**
    	 * Create a copy of this Builder using the current values.
    	 * Any futher modifications to either the original Builder
    	 * or the copy will not affect the other.
    	 * @return a new instance.
    	 */
    	public Builder copy(){
<span class="fc" id="L3051">    		return new Builder(this);</span>
    	}
    	/**
    	 * Use the current begin, end and length
    	 * values of this Builder to return an instance
    	 * of a {@link Range} object with the same values.
    	 * This method is not guaranteed to return new instances and may return
	     * a cached instance instead (flyweight pattern).
	     * @return a {@link Range}; never null but might 
	     * not be a new instance.
	     * @throws IllegalArgumentException if {@code end &amp;lt; begin -1} 
	     * or if the resulting range length &amp;gt; {@link Long#MAX_VALUE}.
    	 */
    	public Range build(){
<span class="fc" id="L3065">    		long length = end-begin+1;</span>
<span class="fc bfc" id="L3066" title="All 2 branches covered.">    		if(length&lt;0){</span>
<span class="fc" id="L3067">    			throw new IllegalArgumentException(&quot;length can not be negative&quot;);</span>
    		}
<span class="fc bfc" id="L3069" title="All 2 branches covered.">    		if(begin &gt;0){</span>
<span class="fc" id="L3070">        		long maxLength = Long.MAX_VALUE - begin+1;</span>
<span class="fc bfc" id="L3071" title="All 2 branches covered.">        		if(maxLength &lt; length){</span>
<span class="fc" id="L3072">        			throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L3073">        					String.format(&quot;given length %d would make range [%d - ? ] beyond max allowed end offset&quot;,</span>
<span class="fc" id="L3074">        							end, begin));</span>
        		}
        	}
    		
    		
<span class="fc" id="L3079">    		CacheKey cacheKey = CacheKey.createCacheKeyFor(begin, end);</span>
    		
<span class="fc bfc" id="L3081" title="All 2 branches covered.">    		if(cacheKey!=null){</span>
<span class="fc" id="L3082">    		    return CACHE.computeIfAbsent(cacheKey, k-&gt;{ </span>
<span class="fc bfc" id="L3083" title="All 2 branches covered.">    		        if(k.end &gt;= k.begin) {</span>
<span class="fc" id="L3084">    		            return buildNewRange(k.begin,k.end); </span>
    		        }
<span class="fc" id="L3086">    		        return buildNewEmptyRange(k.begin);</span>
    		    });
    		}
    		
<span class="fc bfc" id="L3090" title="All 2 branches covered.">            if(end &gt;= begin) {</span>
<span class="fc" id="L3091">                return buildNewRange(begin,end);            </span>
            }
<span class="fc" id="L3093">            return buildNewEmptyRange(begin);</span>
            
    	}
		@Override
		public String toString() {
<span class="nc" id="L3098">			return &quot;Builder [begin=&quot; + begin + &quot;, end=&quot; + end</span>
					+ &quot;, inputCoordinateSystem=&quot; + inputCoordinateSystem + &quot;]&quot;;
		}
		
	/**
	 * Intersect the current begin and end coordinates
	 * with another Range, the resulting intersection
	 * coordinates are now this Builder's begin and end.
	 * 
	 * @param other the other Range to intersect with;
	 * can not be null.
	 * 
	 * @return this
	 * 
	 * @throws NullPointerException if other is null.
	 * 
	 * @see Range#intersection(Range)
	 * @since 5.2
	 */
        public Builder intersect(Range other) {
            //performing an intersection is actually complicated
            //for now just build a temp range then do an intersection
<span class="fc" id="L3120">            Range temp = new LongRange(begin, end);</span>
<span class="fc" id="L3121">            Range result = temp.intersection(other);</span>
<span class="fc" id="L3122">            this.begin = result.getBegin();</span>
<span class="fc" id="L3123">            this.end = result.getEnd();</span>
<span class="fc" id="L3124">            return this;</span>
        }
        
        /**
         * Intersect the current begin and end coordinates
         * with another Range, the resulting intersection
         * coordinates are now this Builder's begin and end.
         * 
         * @param other the other Range to intersect with;
         * can not be null.
         * 
         * @return this
         * 
         * @throws NullPointerException if other is null.
         * 
         * @see Range#intersection(Range)
         * @since 5.2
         */
        public Builder intersect(Builder other) {
<span class="fc" id="L3143">           return intersect(other.asRange());</span>
        }
        
        @Override
        public Range asRange() {
            //for speed make a new Long Range
<span class="fc" id="L3149">            return new LongRange(begin, end);</span>
        }
        @Override
        public boolean isEmpty() {
<span class="nc bnc" id="L3153" title="All 2 branches missed.">            return end-begin &lt; 0;</span>
        }
        public boolean startsAfter(Range other) {
<span class="nc bnc" id="L3156" title="All 2 branches missed.">            return begin &gt; other.getEnd();</span>
        }
        public boolean startsBefore(Range other) {
<span class="nc bnc" id="L3159" title="All 2 branches missed.">            return begin &lt; other.getBegin();</span>
        }
        public boolean endsAfter(Range other) {
<span class="nc bnc" id="L3162" title="All 2 branches missed.">            return end &gt; other.getEnd();</span>
        }
        public boolean endsBefore(Range other) {
<span class="nc bnc" id="L3165" title="All 2 branches missed.">            return end &gt; other.getBegin();</span>
        }
    }
    
    private static final class CacheKey{
        private final int begin,end;
        
<span class="fc" id="L3172">        public CacheKey(int begin, int end) {</span>
<span class="fc" id="L3173">            this.begin = begin;</span>
<span class="fc" id="L3174">            this.end = end;</span>
<span class="fc" id="L3175">        }</span>
        
        public static CacheKey createCacheKeyFor(Range range){
<span class="fc" id="L3178">           return createCacheKeyFor(range.getBegin(), range.getEnd());</span>
        }
        
        public static CacheKey createCacheKeyFor(long begin, long end){
<span class="fc bfc" id="L3182" title="All 8 branches covered.">           if(begin &lt;0 || begin &gt; Integer.MAX_VALUE || end &lt;0 || end &gt; Integer.MAX_VALUE){</span>
<span class="fc" id="L3183">               return null;</span>
           }
<span class="fc" id="L3185">           return new CacheKey( (int)begin, (int)end);</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L3190">            final int prime = 31;</span>
<span class="fc" id="L3191">            int result = 1;</span>
<span class="fc" id="L3192">            result = prime * result + begin;</span>
<span class="fc" id="L3193">            result = prime * result + end;</span>
<span class="fc" id="L3194">            return result;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L3199" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L3200">                return true;</span>
            }
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L3203">                return false;</span>
            }
<span class="pc bpc" id="L3205" title="1 of 2 branches missed.">            if (!(obj instanceof CacheKey)) {</span>
<span class="nc" id="L3206">                return false;</span>
            }
<span class="fc" id="L3208">            CacheKey other = (CacheKey) obj;</span>
<span class="fc bfc" id="L3209" title="All 2 branches covered.">            if (begin != other.begin) {</span>
<span class="fc" id="L3210">                return false;</span>
            }
<span class="pc bpc" id="L3212" title="1 of 2 branches missed.">            if (end != other.end) {</span>
<span class="nc" id="L3213">                return false;</span>
            }
<span class="fc" id="L3215">            return true;</span>
        }
        
        
        
        
    }
    /**
     * Create a new Range.Builder instance
     * initialized to this Range's values.
     * 
     * @return a new Range.Builder will never be null.
     * 
     * @since 5.3
     */
    public Builder toBuilder() {
<span class="nc" id="L3231">        return new Range.Builder(this);</span>
    }

 
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>