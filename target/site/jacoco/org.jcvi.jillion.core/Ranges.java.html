<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Ranges.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core</a> &gt; <span class="el_source">Ranges.java</span></div><h1>Ranges.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;

import org.jcvi.jillion.core.util.iter.IteratorUtil;
/**
 * {@code Ranges} is a helper class
 * for operating on a collection
 * of Range objects.
 * @author dkatzel
 *
 */
public final class Ranges {
	//private constructor.
<span class="nc" id="L42">	private Ranges(){}</span>
	/**
     * Combine the given Ranges into fewer ranges that cover the same region.
     * This is the same as {@link #merge(Collection, int) merge(rangesToMerge,0)} 
     * @param rangesToMerge the collection of Ranges to merge;
     * 
     * @return a new list of merged Ranges.
     * @see #merge(Collection, int)
     */
    public static List&lt;Range&gt; merge(Collection&lt;Range&gt; rangesToMerge){
<span class="fc" id="L52">        return merge(rangesToMerge,0);</span>
    }
    /**
     * Combine the given Ranges into fewer ranges that cover the same region.
     * For example 2 ranges [0-2] and [1-4] could be merged into a single
     * range [0-4].
     * @param rangesToMerge the ranges to be merged together.
     * @param maxDistanceBetweenAdjacentRanges the maximum distance between the end of one range
     * and the start of another in order
     * to be merged.
     * @return a new list of merged Ranges.
     * @throws IllegalArgumentException if maxDistanceBetweenAdjacentRanges &amp;lt; 0.
     */
    public static List&lt;Range&gt; merge(Collection&lt;Range&gt; rangesToMerge, int maxDistanceBetweenAdjacentRanges){
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if(maxDistanceBetweenAdjacentRanges &lt;0){</span>
<span class="fc" id="L67">            throw new IllegalArgumentException(&quot;cluster distance can not be negative&quot;);</span>
        }
<span class="fc" id="L69">        List&lt;Range&gt; sortedCopy = new ArrayList&lt;Range&gt;(rangesToMerge);</span>
<span class="fc" id="L70">        Collections.sort(sortedCopy, Range.Comparators.ARRIVAL);</span>

<span class="fc" id="L72">        mergeAnyRangesThatCanBeCombined(sortedCopy, maxDistanceBetweenAdjacentRanges);</span>
<span class="fc" id="L73">        return sortedCopy;</span>
    }
    
    /**
     * Convert all the set bits in the given BitSet into contiguous ranges.
     * For example if there are set bits at offsets 0,1,2 and 4,5 then 
     * the Ranges [0-2] and [4-5] will be returned.
     * 
     * @apiNote This is the same as {@link #asRanges(BitSet, int) asRanges(bits, 0)}.
     * 
     * @param bits the {@link BitSet} to convert into Ranges; can not be null but may have no bits set.
     * 
     * @return a new list of Ranges; will never be null but may be empty.
     * 
     * @throws NullPointerException if bits is null
     * 
     * @see #asRanges(BitSet, int)
     * @since 5.3
     */
    public static List&lt;Range&gt; asRanges(BitSet bits){
<span class="fc" id="L93">        return asRanges(bits, 0);</span>
    }
    /**
     * Convert all the set bits in the given BitSet into contiguous ranges.
     * For example if there are set bits at offsets 0,1,2 and 4,5 then:
     * &lt;ol&gt;
     * &lt;li&gt;if maxDistanceBetweenAdjacentRanges &lt;2, then the Ranges [0-2] and [4-5] will be returned&lt;/li&gt;
     * &lt;li&gt;if maxDistanceBetweenAdjacentRanges &gt;=2 then one Range [0-5] is returned&lt;/li&gt;
     * &lt;/ol&gt;
     * 
     * @param bits the {@link BitSet} to convert into Ranges; can not be null but may have no bits set.
     * @param maxDistance the maximum distance between the end of one range
     * and the start of another in order to be merged.
     * 
     * @return a new list of Ranges; will never be null but may be empty.
     * 
     * @throws IllegalArgumentException if maxDistance &amp;lt; 0.
     * @throws NullPointerException if bits is null
     * 
     * @since 5.3
     */
    public static List&lt;Range&gt; asRanges(BitSet bits, int maxDistance){
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if(maxDistance &lt; 0){</span>
<span class="nc" id="L116">            throw new IllegalArgumentException(&quot;maxDistance can not be negative: &quot; + maxDistance);</span>
        }
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if(bits.isEmpty()){</span>
<span class="fc" id="L119">            return Collections.emptyList();</span>
        }
<span class="fc" id="L121">        int i = bits.nextSetBit(0);</span>
<span class="fc" id="L122">        Range.Builder currentBuilder = new Range.Builder(i,i);</span>
        
<span class="fc" id="L124">        List&lt;Range&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (; i &gt;= 0; i = bits.nextSetBit(i+1)) {</span>
            // operate on index i here
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            if (i == Integer.MAX_VALUE) {</span>
<span class="nc" id="L128">                break; // or (i+1) would overflow</span>
            }
<span class="fc" id="L130">            int delta = i - (int) currentBuilder.getEnd();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if( delta -1 &gt; maxDistance){</span>
<span class="fc" id="L132">                ret.add(currentBuilder.build());</span>
<span class="fc" id="L133">                currentBuilder = new Range.Builder(i,i);</span>
            }else{
<span class="fc" id="L135">                currentBuilder.expandEnd(delta);</span>
            }
        }
<span class="fc" id="L138">        ret.add(currentBuilder.build());</span>
<span class="fc" id="L139">        return ret;</span>
    }
    /**
     * Convert all offsets in the &lt;strong&gt;sorted&lt;/strong&gt; array into contiguous ranges.
     * For example if the array is &lt;tt&gt; {0,1,2,4,5}&lt;/tt&gt; then 
     * the Ranges [0-2] and [4-5] will be returned.
     * 
     * @apiNote This is the same as {@link #asRanges(int[], int) asRanges(sortedOffsets, 0)}.
     * 
     * @param sortedOffsets the array of SORTED values to convert into Ranges; can not be null but may be empty.
     * The array must be sorted from smallest to largest.
     * 
     * @return a new list of Ranges; will never be null but may be empty.
     * 
     * @throws NullPointerException if bits is null
     * @throws IllegalArgumentException if sortedOffsets is not sorted from smallest to largest.
     * 
     * @see #asRanges(int[], int)
     * @since 5.3
     */
    public static List&lt;Range&gt; asRanges(int[] sortedOffsets){
<span class="fc" id="L160">        return asRanges(sortedOffsets, 0);</span>
    }
    /**
     * Convert all offsets in the &lt;strong&gt;sorted&lt;/strong&gt; array into contiguous ranges.
     * For example if the array is &lt;tt&gt; {0,1,2,4,5}&lt;/tt&gt; then:
     * &lt;ol&gt;
     * &lt;li&gt;if maxDistanceBetweenAdjacentRanges &lt;2, then the Ranges [0-2] and [4-5] will be returned&lt;/li&gt;
     * &lt;li&gt;if maxDistanceBetweenAdjacentRanges &gt;=2 then one Range [0-5] is returned&lt;/li&gt;
     * &lt;/ol&gt;
     * 
     * @param sortedOffsets the array of SORTED values to convert into Ranges; can not be null but may be empty.
     * The array must be sorted from smallest to largest.
     * 
     * @param maxDistance the maximum distance between the end of one range
     * and the start of another in order to be merged.
     * 
     * @return a new list of Ranges; will never be null but may be empty.
     * 
     * @throws IllegalArgumentException if maxDistance &amp;lt; 0.
     * @throws NullPointerException if array is null
     * @throws IllegalArgumentException if sortedOffsets is not sorted from smallest to largest.
     * @since 5.3
     */
    public static List&lt;Range&gt; asRanges(int[] sortedOffsets, int maxDistance){
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if(maxDistance &lt; 0){</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;maxDistance can not be negative: &quot; + maxDistance);</span>
        }
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if(sortedOffsets.length ==0){</span>
<span class="nc" id="L188">            return Collections.emptyList();</span>
        }
<span class="fc" id="L190">        int lastOffset = sortedOffsets[0];</span>
<span class="fc" id="L191">        Range.Builder currentBuilder = new Range.Builder(lastOffset,lastOffset);</span>
        
<span class="fc" id="L193">        List&lt;Range&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for (int i=1; i&lt;sortedOffsets.length; i++) {</span>
<span class="fc" id="L195">            lastOffset = sortedOffsets[i];</span>
<span class="fc" id="L196">            int delta = lastOffset - (int) currentBuilder.getEnd();</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">            if(delta &lt;0){</span>
                //not sorted!
<span class="fc" id="L199">                throw new IllegalArgumentException(&quot;input array must be sorted from smallest to largest&quot;);</span>
            }
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if( delta -1 &gt; maxDistance){</span>
<span class="fc" id="L202">                ret.add(currentBuilder.build());</span>
<span class="fc" id="L203">                currentBuilder = new Range.Builder(lastOffset,lastOffset);</span>
            }else{
<span class="fc" id="L205">                currentBuilder.expandEnd(delta);</span>
            }
        }
<span class="fc" id="L208">        ret.add(currentBuilder.build());</span>
<span class="fc" id="L209">        return ret;</span>
    }
    
    /**
     * Combine the given Ranges into fewer ranges that cover the same region.
     * For example 2 ranges [0-2] and [1-4] could be merged into a single
     * range [0-4].
     * @param rangesToMerge the ranges to be merged together.
     * @param maxClusterDistance the maximum distance between the end of one range
     * and the start of another in order
     * to be merged.
     * @return a new list of merged Ranges.
     * @throws IllegalArgumentException if clusterDistance &amp;lt; 0.
     */
    public static List&lt;Range&gt; mergeIntoClusters(Collection&lt;Range&gt; rangesToMerge, int maxClusterDistance){
<span class="fc" id="L224">        List&lt;Range&gt; tempRanges = merge(rangesToMerge);</span>
<span class="fc" id="L225">        return privateMergeRangesIntoClusters(tempRanges,maxClusterDistance);</span>

    }
    private static List&lt;Range&gt; privateMergeRangesIntoClusters(List&lt;Range&gt; rangesToMerge, int maxClusterDistance){
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if(maxClusterDistance &lt;0){</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;max cluster distance can not be negative&quot;);</span>
        }
<span class="fc" id="L232">        List&lt;Range&gt; sortedSplitCopy = new ArrayList&lt;Range&gt;();</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for(Range range : rangesToMerge){</span>
<span class="fc" id="L234">            sortedSplitCopy.addAll(range.split(maxClusterDistance));</span>
<span class="fc" id="L235">        }        </span>
        
<span class="fc" id="L237">        privateMergeAnyRangesThatCanBeClustered(sortedSplitCopy, maxClusterDistance);</span>
<span class="fc" id="L238">        return sortedSplitCopy;</span>
    }
    
    private static void privateMergeAnyRangesThatCanBeClustered(List&lt;Range&gt; rangesToMerge, int maxClusterDistance) {
        boolean merged;
        do{
<span class="fc" id="L244">            merged = false;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            for(int i=0; i&lt;rangesToMerge.size()-1; i++){</span>
<span class="fc" id="L246">                Range range = rangesToMerge.get(i);</span>
<span class="fc" id="L247">                Range nextRange = rangesToMerge.get(i+1);</span>
<span class="fc" id="L248">                final Range combinedRange = createInclusiveRange(range,nextRange);</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                if(combinedRange.getLength()&lt;= maxClusterDistance){</span>
                    //can be combined
<span class="nc" id="L251">                    replaceWithCombined(rangesToMerge,range, nextRange);</span>
<span class="nc" id="L252">                    merged= true;</span>
<span class="nc" id="L253">                    break;</span>
                }                
            }            
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        }while(merged);</span>
<span class="fc" id="L257">    }</span>
    
    private static void mergeAnyRangesThatCanBeCombined(List&lt;Range&gt; rangesToMerge, int clusterDistance) {
        boolean merged;
        do{
<span class="fc" id="L262">            merged = false;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            for(int i=0; i&lt;rangesToMerge.size()-1; i++){</span>
<span class="fc" id="L264">                Range range = rangesToMerge.get(i);</span>
<span class="fc" id="L265">                Range clusteredRange = Range.of(range.getBegin()-clusterDistance, range.getEnd()+clusterDistance);</span>
<span class="fc" id="L266">                Range nextRange = rangesToMerge.get(i+1);</span>
<span class="fc bfc" id="L267" title="All 4 branches covered.">                if(clusteredRange.intersects(nextRange) || new Range.Builder(clusteredRange).shift(1).build().intersects(nextRange)){</span>
<span class="fc" id="L268">                    replaceWithCombined(rangesToMerge,range, nextRange);</span>
<span class="fc" id="L269">                    merged= true;</span>
<span class="fc" id="L270">                    break;</span>
                }
            }
<span class="fc bfc" id="L273" title="All 2 branches covered.">        }while(merged);</span>
<span class="fc" id="L274">    }</span>
    private static void replaceWithCombined(List&lt;Range&gt; rangeList, Range range, Range nextRange) {
<span class="fc" id="L276">        final Range combinedRange = createInclusiveRange(range,nextRange);</span>
<span class="fc" id="L277">        int index =rangeList.indexOf(range);</span>
<span class="fc" id="L278">        rangeList.remove(range);</span>
<span class="fc" id="L279">        rangeList.remove(nextRange);</span>
<span class="fc" id="L280">        rangeList.add(index, combinedRange);</span>
        
<span class="fc" id="L282">    }</span>
    
    /**
     * Return a single
     * Range that covers the entire span
     * of the given Ranges.
     * &lt;p&gt;
     * For example: passing in 2 Ranges [0,10] and [20,30]
     * will return [0,30]
     * @param ranges a collection of ranges
     * @return a new Range that covers the entire span of
     * input ranges.
     */
    public static Range createInclusiveRange(Collection&lt;Range&gt; ranges){       
<span class="fc" id="L296">        return createInclusiveRange(ranges.iterator());</span>
    }
    
    private static Range createInclusiveRange(Iterator&lt;Range&gt; iter){
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if(!iter.hasNext()){</span>
<span class="fc" id="L301">            return new Range.Builder().build();</span>
        }
        
<span class="fc" id="L304">        Range firstRange =iter.next();</span>
<span class="fc" id="L305">        long currentLeft = firstRange.getBegin();</span>
<span class="fc" id="L306">        long currentRight = firstRange.getEnd();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        while(iter.hasNext()){</span>
<span class="fc" id="L308">            Range range = iter.next();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if(range.getBegin() &lt; currentLeft){</span>
<span class="fc" id="L310">                currentLeft = range.getBegin();</span>
            }
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if(range.getEnd() &gt; currentRight){</span>
<span class="fc" id="L313">                currentRight = range.getEnd();</span>
            }
<span class="fc" id="L315">        }</span>
<span class="fc" id="L316">        return Range.of(currentLeft, currentRight);</span>
    }
    
    /**
     * Return a single
     * Range that covers the entire span
     * of the given Ranges.
     * &lt;p&gt;
     * For example: passing in 2 Ranges [0,10] and [20,30]
     * will return [0,30]
     * @param ranges a collection of ranges
     * @return a new Range that covers the entire span of
     * input ranges.
     */
    public static &lt;T&gt; Range createInclusiveRange(Collection&lt;T&gt; collection, Function&lt;T, Range&gt; mapper){
<span class="nc" id="L331">        return createInclusiveRange(IteratorUtil.map(collection.iterator(), mapper));</span>
    }
    
    private static Range createInclusiveRange(Range... ranges){
<span class="fc" id="L335">    	return createInclusiveRange(Arrays.asList(ranges));</span>
    }
    /**
     * Check if the target Range intersects any range in the given list.
     * 
     * @param ranges the list of Ranges to check; can not be null but may be empty.
     * @param target the intersection target Range.
     * 
     * @return {@code true} if the target intersects any Range; {@code false} otherwise.
     * 
     * @apiNote this is the same as:
     * &lt;pre&gt;
     * for(Range r : ranges){
     *     if(r.intersects(target)){
     *         return true;
     *     }
     * }
     * return false;
     * &lt;/pre&gt;
     * @since 5.3
     * 
     * @throws NullPointerException if any paramter is null or any Range in the given list is null.
     */
    public static boolean intersects(Collection&lt;Range&gt; ranges, Range target) {
<span class="nc bnc" id="L359" title="All 2 branches missed.">        for(Range r : ranges){</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if(r.intersects(target)){</span>
<span class="nc" id="L361">                return true;</span>
            }
<span class="nc" id="L363">        }</span>
<span class="nc" id="L364">        return false;</span>
    }
    
    /**
     * Check if the target Range intersects any range in the given list.
     * 
     * @param ts the collection of objects to check; can not be null but may be empty.
     * @param mapper the Mapper function to convert the type in the input collection into a Range.
     * if the mapper returns a null Range, then that element is skipped.
     * @param target the intersection target Range.
     * 
     * @return {@code true} if the target intersects any Range; {@code false} otherwise.
     * 
     * @since 5.3
     * 
     * @throws NullPointerException if any paramter is null or any Range in the given list is null.
     */
    public static &lt;T&gt; boolean intersects(Collection&lt;T&gt; ts, Function&lt;T, Range&gt; mapper, Range target) {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        for(T t : ts){</span>
<span class="nc" id="L383">            Range r = mapper.apply(t);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            if(r ==null){</span>
<span class="nc" id="L385">                continue;</span>
            }
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if(r.intersects(target)){</span>
<span class="nc" id="L388">                return true;</span>
            }
<span class="nc" id="L390">        }</span>
<span class="nc" id="L391">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>