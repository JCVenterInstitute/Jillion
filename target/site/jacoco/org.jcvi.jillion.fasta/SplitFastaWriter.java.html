<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SplitFastaWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.fasta</a> &gt; <span class="el_source">SplitFastaWriter.java</span></div><h1>SplitFastaWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.fasta;

import java.io.IOException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;

import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.io.IOUtil;
/**
 * Utility class that creates {@link FastaWriter} instances
 * that split the {@link FastaRecord} objects being written out
 * over several different output files.
 * &lt;p&gt;
 * The rules for how the records are split are determined
 * by the writer implementation chosen in each factory method.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Construction of the individual fasta writers used by the Split Writer
 * is delegated to a user supplied lambda function that is given the int i
 * for the ith file to be created and must return a non-null FastaWriter of the correct type.
 * &lt;/p&gt;
 * The returned FastaWriter implementations are not thread-safe.
 * 
 * 
 * @author dkatzel
 *
 * @since 5.0
 */
@SuppressWarnings(&quot;unchecked&quot;)
public final class SplitFastaWriter{
	
	/**
	 * Functional interface to create new FastaWriter
	 * instances.
	 * @author dkatzel
	 *
	 * @param &lt;T&gt; the type of {@link FastaRecord} that is to be created.
	 */
	@FunctionalInterface
	public interface FastaRecordWriterFactory&lt;T&gt;{
		/**
		 * Create a new FastaWriter for the ith
		 * fasta file.
		 * @param i the ith file to create, will start at value 1
		 * not zero.
		 * @return a new FastaWriter; can not be null.
		 * @throws IOException if there is a problem creating the writer.
		 */
		T create(int i) throws IOException;
	}
	
	/**
	 * Functional interface to create new FastaWriter
	 * instances.
	 * @author dkatzel
	 *
	 * @param &lt;K&gt; the type of object that will be used as a &quot;key&quot;
	 * to determine which of the output writers to write this record to.
	 * 
	 * @param &lt;T&gt; the type of {@link FastaRecord} that is to be created
	 */
	@FunctionalInterface
	public interface DeconvolveFastaRecordWriterFactory&lt;K,T&gt;{
		/**
		 * Create a new FastaWriter for the
		 * fasta file for the given deconvolution key.
		 * @param key the deconvolutionkey for the file to create, will never be null.
		 * @return a new FastaWriter; can not be null.
		 * @throws IOException if there is a problem creating the writer.
		 */
		T create(K key) throws IOException;
	}
	
	/**
	 * Creates a new {@link FastaWriter} instance that will spread out
	 * the {@link FastaRecord}s to be written to create several fasta files.  The
	 * first fasta record written will be written to the first output fasta, the second
	 * record written will be written to the second output fasta etc.  After all the output files
	 * have written a record, the next {@link FastaRecord} to be written will write to the first
	 * output file again.  This will continue until the SplitWriter is closed.
	 * 
	 * @param interfaceClass The &lt;strong&gt;interface&lt;/strong&gt; type the lambda function will be returning
	 * which is also going to be the return type for this Fasta Writer.
	 * 
	 * @param numberOfFiles the number of files to write to in a round robin fashion. Must be &gt;=1.
	 * 
	 * @param supplier a {@link FastqWriterFactory} instance that will create a new FastaWriter of type W for the
	 * ith file to be created.  The passed in value i will be in the range 1..N where N is the number of files
	 * created (will start at 1 not 0).  If no records are written, then supplier will never be called. Can not be null.
	 * 
	 * @return a new {@link FastaWriter} instance; will never be null. 
	 * The returned writer is not thread-safe.
	 * 
	 * @throws NullPointerException if supplier lambda is null.
	 * @throws IllegalArgumentException if max records per file is &lt; 1.
	 * 
	 * @apiNote for example, to make a Split Fasta Writer that will write out to 10 different fasta files
	 *  named &quot;1.fasta&quot; to &quot;10.fasta&quot; in a round robin fashion would look like this:
	 * &lt;pre&gt;
	 * 
	 * File outputDir = ...
	 * {@code Iterator&lt;NucleotideFastaRecord&gt;} iter = ...
	 * 
	 * try(NucleotideFastaWriter writer = SplitFastaWriter.roundRobin(NucleotideFastaWriter.class,
	 * 					10,
	 * 					i {@code -&gt;} new NucleotideFastaWriterBuilder(new File(outputDir, i +&quot;.fasta&quot;))
	 *										.build());
	*){
	*	while(iter.hasNext()){
	*		writer.write(iter.next());
	*	}
	*}
	 * &lt;/pre&gt;
	 * 
	 */
	
	public static &lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S,T,F&gt;&gt; W roundRobin(Class&lt;W&gt; interfaceClass, int numberOfFiles,
			FastaRecordWriterFactory&lt;W&gt; supplier){
<span class="fc" id="L144">		RoundRobinSplitFastaWriter&lt;S, T, F, W&gt; writer = new RoundRobinSplitFastaWriter&lt;S, T, F, W&gt;(numberOfFiles, supplier);</span>
		
<span class="fc" id="L146">		return (W) Proxy.newProxyInstance(writer.getClass().getClassLoader(), new Class[]{interfaceClass}, new InvocationHandlerImpl&lt;&gt;(writer) );</span>
	}
	
	
	/**
	 * Creates a new {@link FastaWriter} instance that will internally create several fasta files
	 * that will each contain only the given number of records.  Once the first fasta file written has reached
	 * the max number of records, a new output fasta file will be created to write out the next max number of records
	 * (the additional written records will be rolled over to the new writer).
	 * 
	 * 
	 * @param interfaceClass The &lt;strong&gt;interface&lt;/strong&gt; type the lambda function will be returning
	 * which is also going to be the return type for this Fasta Writer.
	 * 
	 * @param maxRecordsPerFile the max number of {@link FastaRecord}s to be written to a file
	 * before it should be closed and the next file created. Must be &gt;=1.
	 * 
	 * @param supplier a {@link FastqWriterFactory} instance that will create a new FastaWriter of type W for the
	 * ith file to be created.  The passed in value i will be in the range 1..N where N is the number of files
	 * created (will start at 1 not 0).  If no records are written, then supplier will never be called.  Can not be null.
	 * 
	 * @return a new {@link FastaWriter} instance; will never be null.
	 * The returned writer is not thread-safe.
	 * 
	 * @throws NullPointerException if supplier lambda is null.
	 * @throws IllegalArgumentException if max records per file is &lt; 1.
	 * 
	 *  @apiNote for example, to make a Split Fasta Writer that will write out to a new fasta file
	 *  every 1000 sequences
	 *  named &quot;1.fasta&quot;, &quot;2.fasta&quot;, etc where &quot;1.fasta&quot; will contain the first 1000 sequences
	 *  and &quot;2.fasta&quot; will contain the next 1000 sequences etc would look like this:
	 * &lt;pre&gt;
	 * 
	 * File outputDir = ...
	 * {@code Iterator&lt;NucleotideFastaRecord&gt;} iter = ...
	 * 
	 * try(NucleotideFastaWriter writer = SplitFastaWriter.rollover(NucleotideFastaWriter.class,
	 * 					1000,
	 * 					i {@code -&gt;} new NucleotideFastaWriterBuilder(new File(outputDir, i +&quot;.fasta&quot;))
	 *										.build());
	*){
	*	while(iter.hasNext()){
	*		writer.write(iter.next());
	*	}
	*}
	 * &lt;/pre&gt;
	 */
	
	public static &lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S,T,F&gt;&gt; W rollover(Class&lt;W&gt; interfaceClass, int maxRecordsPerFile,
			FastaRecordWriterFactory&lt;W&gt; supplier){
<span class="fc" id="L196">		RolloverSplitFastaWriter&lt;S, T, F, W&gt; writer = new RolloverSplitFastaWriter&lt;S, T, F, W&gt;(maxRecordsPerFile, supplier);</span>
		
<span class="fc" id="L198">		return (W) Proxy.newProxyInstance(writer.getClass().getClassLoader(), new Class[]{interfaceClass}, new InvocationHandlerImpl&lt;&gt;(writer) );</span>
	}
	
	
	/**
	 * Write out many fasta files where a &quot;deconvolution&quot; function determines which file
	 * each record is written to based on the contents of that record.  Deconvolution functions
	 * typically use the actual read sequence to find sequencing barcodes or bin by characteristics 
	 * in specially formatted record ids.  
	 * 
	 * @param interfaceClass The &lt;strong&gt;interface&lt;/strong&gt; type the supplier function will be returning
	 * which is also going to be the return type for this Fasta Writer.
	 * 
	 * 
	 * @param deconvolutionFunction the lambda expression that given a FastaRecord will
	 * determine the &quot;key&quot; that will be used to map to the output fasta writer to write the record to.
	 * The returned key object must correctly implement equals and hashcode.  Think of the key
	 * as the key in a {@code Map&lt;Key, FastaWriter&gt;}.  If the returned Key
	 * is {@code null} then the record should be skipped and not written out to any of the
	 * output files.  The lambda function itself can not be null.
	 *  
	 * @param supplier given the key returned by the deconvolutionFunction create a new FastaWriter of the
	 * type W.  The supplier will only be called when a key from the deconvolutionFunction is seen for the 
	 * first time (as determined by the key's equals() and hashcode() implementation)
	 * 
	 * @return a new FastaWriter; will never be null.  The returned writer is not thread-safe.
	 * 
	 * @param &lt;K&gt; The deconvolution key type that is returned from the deconvolution function and passed 
	 * to the supplier function.
	 * @param &lt;F&gt; The {@link FastaRecord} type that is being written out.
	 * 
	 * @param &lt;W&gt; the {@link FastaWriter} interface  type returned by this method.
	 * 
	 * @throw NullPointerException if any parameter is null (but the deconvolution function
	 * may return null values).
	 * 
	 * @apiNote For example to if there exists a method that given the read id, returns a Direction object
	 * of that read then the following code:
	 * 
	 * &lt;pre&gt;
	 * 
	 * File outputDir = ...
         * {@code Iterator&lt;NucleotideFastaRecord&gt;} iter = ...
         * 
         * try(NucleotideFastaWriter writer = SplitFastaWriter.deconvolve(NucleotideFastaWriter.class, 
					record {@code -&gt;} getSequenceDirectionFor(record.getId()),
					dir {@code -&gt;} new NucleotideFastaWriterBuilder(new File(outputDir, dir + &quot;.fasta&quot;))
											.build());
	){
        *       while(iter.hasNext()){
        *               writer.write(iter.next());
        *       }
        *}
        *
	 * &lt;/pre&gt;
	 * 
	 * Will write out all the fastas to 2 files, &quot;forward.fasta&quot; and &quot;reverse.fasta&quot; where the reads
	 * that were determined to be forward reads were written to &quot;forward.fasta&quot; and the reads that were
	 * determined to be reversed where written to &quot;reverse.fasta&quot;.
	 */
	
	public static &lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S,T,F&gt;, K&gt; W deconvolve(Class&lt;W&gt; interfaceClass, 
			Function&lt;FastaRecord&lt;S, T&gt;, K&gt; deconvolutionFunction,
			DeconvolveFastaRecordWriterFactory&lt;K, W&gt; supplier){
<span class="fc" id="L262">		DeconvolutionFastaWriter&lt;S, T, F, W, K&gt; writer = new DeconvolutionFastaWriter&lt;S, T, F, W, K&gt;(deconvolutionFunction, supplier);</span>
		
<span class="fc" id="L264">		return (W) Proxy.newProxyInstance(writer.getClass().getClassLoader(), new Class[]{interfaceClass}, new InvocationHandlerImpl&lt;&gt;(writer) );</span>
	} 
	
<span class="nc" id="L267">	private SplitFastaWriter(){</span>
		//can not instantiate
<span class="nc" id="L269">	}</span>
	
	private static final class FastaRecordImpl&lt;S, T extends Sequence&lt;S&gt;&gt; implements FastaRecord&lt;S,T&gt;{
		private final String id, comment;
		private final T sequence;
		
		
<span class="fc" id="L276">		public FastaRecordImpl(String id, String comment, T sequence) {</span>
<span class="fc" id="L277">			this.id = id;</span>
<span class="fc" id="L278">			this.comment = comment;</span>
<span class="fc" id="L279">			this.sequence = sequence;</span>
<span class="fc" id="L280">		}</span>

		@Override
		public String getId() {
<span class="fc" id="L284">			return id;</span>
		}

		@Override
		public String getComment() {
<span class="fc" id="L289">			return comment;</span>
		}

		@Override
		public T getSequence() {
<span class="fc" id="L294">			return sequence;</span>
		}
		
	}
	
	
	private static final class InvocationHandlerImpl&lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S,T,F&gt;&gt; implements InvocationHandler{

		private final FastaWriter&lt;S,T,F&gt; delegate;
		
		
		@Override
		public Object invoke(Object proxy, Method method, Object[] args)
				throws Throwable {
			
<span class="fc" id="L309">			String name = method.getName();</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">			if(&quot;write&quot;.equals(name)){</span>
				//special handling of write method calls
				//subclasses override with more specific subtypes
				//which causes reflection problems so need to do explicit casting
<span class="fc bfc" id="L314" title="All 2 branches covered.">				if(args.length ==1){</span>
					//write full record
<span class="fc" id="L316">					delegate.write((F) args[0]);</span>
<span class="fc" id="L317">					return null;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">				}else if(args.length ==2){</span>
<span class="fc" id="L319">					delegate.write((String) args[0], (T) args[1]);</span>
<span class="fc" id="L320">					return null;</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">				}else if(args.length ==3){</span>
<span class="fc" id="L322">					delegate.write((String) args[0], (T) args[1], (String) args[2]);</span>
<span class="fc" id="L323">					return null;</span>
				}
			}
			
<span class="fc" id="L327">			return method.invoke(delegate, args);</span>
			
		}

<span class="fc" id="L331">		public InvocationHandlerImpl(FastaWriter&lt;S,T,F&gt; delegate) {</span>
<span class="fc" id="L332">			this.delegate = delegate;</span>
<span class="fc" id="L333">		}</span>
		
	}
	
	private static final class 	DeconvolutionFastaWriter&lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S, T, F&gt;, K&gt;
	implements FastaWriter&lt;S, T, F&gt; {

<span class="fc" id="L340">		private volatile boolean closed = false;</span>
		
<span class="fc" id="L342">		private final Map&lt;K, W&gt; writers = new HashMap&lt;&gt;();</span>
		
		private final Function&lt;FastaRecord&lt;S, T&gt;, K&gt; deconvolutionFunction;
		private final DeconvolveFastaRecordWriterFactory&lt;K, W&gt; supplier;
		
		
<span class="fc" id="L348">		public DeconvolutionFastaWriter(Function&lt;FastaRecord&lt;S, T&gt;, K&gt; deconvolutionFunction, DeconvolveFastaRecordWriterFactory&lt;K, W&gt; supplier) {</span>
<span class="fc" id="L349">			Objects.requireNonNull(deconvolutionFunction);</span>
<span class="fc" id="L350">			Objects.requireNonNull(supplier);</span>
			
<span class="fc" id="L352">			this.deconvolutionFunction = deconvolutionFunction;</span>
<span class="fc" id="L353">			this.supplier = supplier;</span>
<span class="fc" id="L354">		}</span>

		@Override
		public void close() throws IOException {
<span class="fc bfc" id="L358" title="All 2 branches covered.">			if(closed){</span>
<span class="fc" id="L359">				return;</span>
			}
<span class="fc" id="L361">			closed=true;</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">			for(W writer : writers.values()){</span>
<span class="fc" id="L363">				IOUtil.closeAndIgnoreErrors(writer);</span>
<span class="fc" id="L364">			}</span>
					
			
<span class="fc" id="L367">		}</span>
		private void checkNotClosed() throws IOException {
<span class="fc bfc" id="L369" title="All 2 branches covered.">			if (closed) {</span>
<span class="fc" id="L370">				throw new IOException(&quot;already closed&quot;);</span>
			}
<span class="fc" id="L372">		}</span>
		
		@Override
		public void write(F record) throws IOException {
<span class="fc" id="L376">			privateWrite(record);</span>
<span class="fc" id="L377">		}</span>

		private void privateWrite(FastaRecord&lt;S,T&gt; record) throws IOException {
<span class="fc" id="L380">			checkNotClosed();</span>
<span class="fc" id="L381">			Objects.requireNonNull(record);</span>
<span class="fc" id="L382">			K key = deconvolutionFunction.apply(record);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">			if(key ==null){</span>
			    //skip record
<span class="fc" id="L385">			    return;</span>
			}
			//since we might throw an IOException
			//if we call the supplier
			//we do a check then act
			//which is not threadsafe
			//but this writer isn't threadsafe anyway
			//so I don't think it matters.
			//if we used computIfAbsent(key, supplier)
			//we would have to wrap any exception thrown by supplier
			//in a runtime exception
<span class="fc" id="L396">			W writer = writers.get(key);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">			if(writer==null){</span>
<span class="fc" id="L398">			    writer = supplier.create(key);</span>
<span class="fc" id="L399">			    writers.put(key, writer);</span>
			}
			//use this version of write()
			//so we don't have to create a mock
			//implementation of fastaRecord type F
			//which adds a lot of  by requiring
			//Proxy classes and reflection calls
<span class="fc" id="L406">			writer.write(record.getId(), record.getSequence(), record.getComment());</span>
<span class="fc" id="L407">		}</span>
		
	

		@Override
		public void write(String id, T sequence) throws IOException {
<span class="fc" id="L413">			write(id, sequence, null);</span>
			
<span class="fc" id="L415">		}</span>

		@Override
		public void write(String id, T sequence, String optionalComment)
				throws IOException {
<span class="fc" id="L420">			Objects.requireNonNull(id, &quot;id can not be null&quot;);</span>
<span class="fc" id="L421">			Objects.requireNonNull(sequence, &quot;sequence can not be null&quot;);</span>
			
<span class="fc" id="L423">			FastaRecordImpl&lt;S, T&gt; record = new FastaRecordImpl&lt;&gt;(id, optionalComment, sequence);</span>
			
<span class="fc" id="L425">			privateWrite(record);</span>
<span class="fc" id="L426">		}</span>
		
	}
	private static final class RolloverSplitFastaWriter&lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S, T, F&gt;&gt;
			implements FastaWriter&lt;S, T, F&gt; {

		private final FastaRecordWriterFactory&lt;W&gt; supplier;

		private final int recordsPerFile;
		//initialized to 0 because we will increment it to 1
		//the first time something is written
<span class="fc" id="L437">		private int splitFileNumber = 0;</span>
		private int currentRecordCount;
		private W currentWriter;

<span class="fc" id="L441">		private volatile boolean closed = false;</span>

		private RolloverSplitFastaWriter(int recordsPerFile,
<span class="fc" id="L444">				FastaRecordWriterFactory&lt;W&gt; supplier) {</span>

<span class="fc" id="L446">			Objects.requireNonNull(supplier);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">			if (recordsPerFile &lt; 1) {</span>
<span class="fc" id="L448">				throw new IllegalArgumentException(</span>
						&quot;records per File must be &gt;=1&quot;);
			}
<span class="fc" id="L451">			this.supplier = supplier;</span>
<span class="fc" id="L452">			this.recordsPerFile = recordsPerFile;</span>
			//initialized to max records per file so initial write creates a new writer
<span class="fc" id="L454">			this.currentRecordCount = recordsPerFile;</span>
<span class="fc" id="L455">		}</span>

		private void checkNotClosed() throws IOException {
<span class="fc bfc" id="L458" title="All 2 branches covered.">			if (closed) {</span>
<span class="fc" id="L459">				throw new IOException(&quot;already closed&quot;);</span>
			}
<span class="fc" id="L461">		}</span>

		@Override
		public void close() throws IOException {
<span class="fc bfc" id="L465" title="All 4 branches covered.">			if (!closed &amp;&amp; currentWriter !=null) {</span>
<span class="fc" id="L466">				currentWriter.close();</span>
			}
<span class="fc" id="L468">			closed = true;</span>
<span class="fc" id="L469">		}</span>

		@Override
		public void write(F record) throws IOException {
<span class="fc" id="L473">			updateCurrentWriterIfNeeded();</span>
<span class="fc" id="L474">			currentWriter.write(record);</span>
<span class="fc" id="L475">			currentRecordCount++;</span>
<span class="fc" id="L476">		}</span>

		private void updateCurrentWriterIfNeeded() throws IOException {
<span class="fc" id="L479">			checkNotClosed();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">			if (currentRecordCount == recordsPerFile) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">				if(currentWriter !=null){</span>
<span class="fc" id="L482">					currentWriter.close();</span>
				}
<span class="fc" id="L484">				splitFileNumber++;</span>
<span class="fc" id="L485">				currentRecordCount = 0;</span>
<span class="fc" id="L486">				currentWriter = supplier.create(splitFileNumber);</span>
			}
<span class="fc" id="L488">		}</span>

		@Override
		public void write(String id, T sequence) throws IOException {
<span class="fc" id="L492">			updateCurrentWriterIfNeeded();</span>
<span class="fc" id="L493">			currentWriter.write(id, sequence);</span>
<span class="fc" id="L494">			currentRecordCount++;</span>

<span class="fc" id="L496">		}</span>

		@Override
		public void write(String id, T sequence, String optionalComment)
				throws IOException {
<span class="fc" id="L501">			updateCurrentWriterIfNeeded();</span>
<span class="fc" id="L502">			currentWriter.write(id, sequence, optionalComment);</span>
<span class="fc" id="L503">			currentRecordCount++;</span>
<span class="fc" id="L504">		}</span>
	}
	
	private static final class RoundRobinSplitFastaWriter&lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S, T&gt;, W extends FastaWriter&lt;S, T, F&gt;&gt;
			implements FastaWriter&lt;S, T, F&gt; {

		private final FastaRecordWriterFactory&lt;W&gt; supplier;

<span class="fc" id="L512">		private int currentIndex=0;</span>
		

<span class="fc" id="L515">		private volatile boolean closed = false;</span>

		
		private final FastaWriter&lt;S, T, F&gt;[] writers;
		
		
		private RoundRobinSplitFastaWriter(int numberOfFiles,
<span class="fc" id="L522">				FastaRecordWriterFactory&lt;W&gt; supplier) {</span>

<span class="fc" id="L524">			Objects.requireNonNull(supplier);</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">			if (numberOfFiles &lt; 1) {</span>
<span class="fc" id="L526">				throw new IllegalArgumentException(</span>
						&quot;records per File must be &gt;=1&quot;);
			}
<span class="fc" id="L529">			writers = new FastaWriter[numberOfFiles];</span>
			
<span class="fc" id="L531">			this.supplier = supplier;</span>
			
<span class="fc" id="L533">		}</span>

		private void checkNotClosed() throws IOException {
<span class="fc bfc" id="L536" title="All 2 branches covered.">			if (closed) {</span>
<span class="fc" id="L537">				throw new IOException(&quot;already closed&quot;);</span>
			}
<span class="fc" id="L539">		}</span>
		
		private W getCurrentWriter() throws IOException{
<span class="fc" id="L542">			checkNotClosed();</span>
			
<span class="fc" id="L544">			W writer=  (W)writers[currentIndex];</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">			if(writer ==null){</span>
				// supplied index always goes from 1..N not 0..n-1
<span class="fc" id="L547">				writer = supplier.create(currentIndex +1);</span>
<span class="fc" id="L548">				writers[currentIndex] = writer;</span>
			}
<span class="fc" id="L550">			currentIndex = (currentIndex +1) % writers.length;</span>
<span class="fc" id="L551">			return writer;</span>
			
		}

		@Override
		public void close() throws IOException {
<span class="fc bfc" id="L557" title="All 2 branches covered.">			if (!closed) {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">				for(FastaWriter&lt;S, T, F&gt; writer : writers){</span>
<span class="fc" id="L559">					IOUtil.closeAndIgnoreErrors(writer);</span>
				}
			}
<span class="fc" id="L562">			closed = true;</span>
<span class="fc" id="L563">		}</span>

		@Override
		public void write(F record) throws IOException {
<span class="fc" id="L567">			getCurrentWriter().write(record);</span>
<span class="fc" id="L568">		}</span>

		

		@Override
		public void write(String id, T sequence) throws IOException {
<span class="fc" id="L574">			getCurrentWriter().write(id, sequence);</span>

<span class="fc" id="L576">		}</span>

		@Override
		public void write(String id, T sequence, String optionalComment)
				throws IOException {
<span class="fc" id="L581">			getCurrentWriter().write(id, sequence, optionalComment);</span>
<span class="fc" id="L582">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>