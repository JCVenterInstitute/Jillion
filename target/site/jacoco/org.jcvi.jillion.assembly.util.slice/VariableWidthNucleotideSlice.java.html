<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VariableWidthNucleotideSlice.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util.slice</a> &gt; <span class="el_source">VariableWidthNucleotideSlice.java</span></div><h1>VariableWidthNucleotideSlice.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.util.slice;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.JoinedStringBuilder;

final class VariableWidthNucleotideSlice implements VariableWidthSlice&lt;Nucleotide, NucleotideSequence&gt;{

	
<span class="fc" id="L45">	private final List&lt;VariableWidthSliceElement&lt;Nucleotide&gt;&gt; list = new ArrayList&lt;VariableWidthSliceElement&lt;Nucleotide&gt;&gt;();</span>
	private final NucleotideSequence gappedReference;
<span class="fc" id="L47">	private VariableWidthNucleotideSlice(Builder builder){</span>
		
<span class="fc bfc" id="L49" title="All 2 branches covered.">		for(Entry&lt;List&lt;Nucleotide&gt;, LongAdder&gt; entry : builder.countMap.entrySet()){</span>
<span class="fc" id="L50">			list.add(new VariableWidthNucleotideSliceElement(entry.getKey(), entry.getValue().intValue()));</span>
<span class="fc" id="L51">		}</span>
		//sort them
<span class="fc" id="L53">		Collections.sort(list);</span>
		
<span class="fc" id="L55">		this.gappedReference = builder.gappedReference;</span>
		
<span class="fc" id="L57">	}</span>
	
	
	@Override
	public NucleotideSequence getGappedReferenceSequence() {
<span class="nc" id="L62">		return gappedReference;</span>
	}



	@Override
	public int getSliceLength() {
<span class="nc" id="L69">		return list.stream().mapToInt(e-&gt; e.getLength()).max().orElse(0);</span>
	}



	@Override
	public int getCoverageDepth() {
<span class="nc" id="L76">		int coverage=0;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">		for(VariableWidthSliceElement&lt;Nucleotide&gt; e : list){</span>
<span class="nc" id="L78">			coverage +=e.getCount();</span>
<span class="nc" id="L79">		}</span>
<span class="nc" id="L80">		return coverage;</span>
	}


	public int getCountFor(List&lt;Nucleotide&gt; sliceElementSeq){
<span class="nc" id="L85">		Objects.requireNonNull(sliceElementSeq);</span>
<span class="nc" id="L86">		Optional&lt;VariableWidthSliceElement&lt;Nucleotide&gt;&gt; ret =list.stream()</span>
<span class="nc" id="L87">															.filter(e -&gt; sliceElementSeq.equals(e.get()))</span>
<span class="nc" id="L88">															.findFirst();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if(ret.isPresent()){</span>
<span class="nc" id="L90">			return ret.get().getCount();</span>
		}
<span class="nc" id="L92">		return 0;</span>
	}

	@Override
	public Stream&lt;? extends VariableWidthSliceElement&lt;Nucleotide&gt;&gt; elements() {
<span class="nc" id="L97">		return list.stream();</span>
	}
	
	@Override
	public int hashCode() {
<span class="nc" id="L102">		final int prime = 31;</span>
<span class="nc" id="L103">		int result = 1;</span>
<span class="nc" id="L104">		result = prime * result + list.hashCode();</span>
<span class="nc" id="L105">		return result;</span>
	}
	@Override
	public boolean equals(Object obj) {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (this == obj) {</span>
<span class="nc" id="L110">			return true;</span>
		}
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L113">			return false;</span>
		}
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">		if( !(obj instanceof VariableWidthSlice)){</span>
<span class="nc" id="L116">			return false;</span>
		}
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">		if (obj instanceof VariableWidthNucleotideSlice) {</span>
<span class="fc" id="L119">			VariableWidthNucleotideSlice other = (VariableWidthNucleotideSlice) obj;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">			if (!list.equals(other.list)) {</span>
<span class="nc" id="L121">				return false;</span>
			}
<span class="fc" id="L123">			return true;</span>
		}
<span class="nc" id="L125">		VariableWidthSlice&lt;?,?&gt; other = (VariableWidthSlice&lt;?,?&gt;) obj;</span>
<span class="nc" id="L126">		return list.equals(other.elements()</span>
<span class="nc" id="L127">								.map(o-&gt; (VariableWidthSlice&lt;?,?&gt;)o)</span>
<span class="nc" id="L128">								.collect(Collectors.toList()));</span>
	}

	public static class Builder{
		private final int width;
		private final int startOffset;
		private final NucleotideSequence gappedReference;
		
<span class="fc" id="L136">		private final Map&lt;List&lt;Nucleotide&gt;, LongAdder&gt; countMap = new ConcurrentHashMap&lt;&gt;();</span>
		
		public Builder(NucleotideSequence gappedReference) {
<span class="fc" id="L139">			this(gappedReference, 0);</span>
<span class="fc" id="L140">		}</span>
<span class="fc" id="L141">		public Builder(NucleotideSequence gappedReference, int startOffset) {</span>
<span class="fc" id="L142">			Objects.requireNonNull(gappedReference);</span>

<span class="pc bpc" id="L144" title="1 of 2 branches missed.">			if(gappedReference.getUngappedLength() &lt;0){</span>
<span class="nc" id="L145">				throw new IllegalArgumentException(&quot;ungappedWidth must be &gt;=1&quot;);</span>
			}
			
<span class="fc" id="L148">			this.width = (int)gappedReference.getLength();</span>
<span class="fc" id="L149">			this.gappedReference = gappedReference;</span>
<span class="fc" id="L150">			this.startOffset = startOffset;</span>
<span class="fc" id="L151">		}</span>

		private void assertNoElementsNull(List&lt;Nucleotide&gt; list){
<span class="fc bfc" id="L154" title="All 2 branches covered.">			for(Nucleotide n : list){</span>
<span class="fc" id="L155">				Objects.requireNonNull(n);</span>
<span class="fc" id="L156">			}</span>
<span class="fc" id="L157">		}</span>
		public Builder add(Iterator&lt;Nucleotide&gt; iter){
<span class="fc" id="L159">			int count=0;</span>
<span class="fc" id="L160">			List&lt;Nucleotide&gt; list = new ArrayList&lt;&gt;(width);</span>
<span class="fc bfc" id="L161" title="All 4 branches covered.">			while(iter.hasNext() &amp;&amp; count &lt; width){</span>
<span class="fc" id="L162">				list.add(iter.next());</span>
<span class="fc" id="L163">				count++;</span>
			}
<span class="fc bfc" id="L165" title="All 2 branches covered.">			if(count == width){</span>
<span class="fc" id="L166">				return add(list);</span>
			}
			//else skip
<span class="fc" id="L169">			return this;</span>
		}
		public Builder add(Nucleotide...nucleotides){
<span class="nc" id="L172">			return add(Arrays.asList(nucleotides));</span>
		}
		public Builder add(List&lt;Nucleotide&gt; list){
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">			if(list.size() != width){</span>
<span class="nc" id="L176">				throw new IllegalArgumentException(&quot;width is not length &quot; + width + &quot; : &quot; + list);</span>
			}			
<span class="fc" id="L178">			assertNoElementsNull(list);</span>
<span class="fc" id="L179">			countMap.computeIfAbsent(list, k -&gt; new LongAdder()).increment();</span>
			
<span class="fc" id="L181">			return this;</span>
		}
		
		public VariableWidthNucleotideSlice build(){
<span class="fc" id="L185">			return new VariableWidthNucleotideSlice(this);</span>
		}

		public Builder addMultiple(int i, NucleotideSequence seq) {
<span class="nc" id="L189">			List&lt;Nucleotide&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">			for(Nucleotide n : seq){</span>
<span class="nc" id="L191">				list.add(n);</span>
<span class="nc" id="L192">			}</span>
<span class="nc" id="L193">			countMap.computeIfAbsent(list, k -&gt; new LongAdder()).add(i);</span>
<span class="nc" id="L194">			return this;</span>
		}

		public void skipBases(int gappedOffset, Iterator&lt;Nucleotide&gt; iter) {
<span class="fc" id="L198">			int numberOfBasesToSkip = width - (gappedOffset - startOffset);</span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">			for(int i=0; iter.hasNext() &amp;&amp; i&lt;numberOfBasesToSkip; i++){</span>
<span class="fc" id="L200">				iter.next();</span>
			}
			
<span class="fc" id="L203">		}</span>

		public void addBeginningOfRead(int gappedStartOffset,
				Iterator&lt;Nucleotide&gt; iter) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if(startOffset == gappedStartOffset){</span>
<span class="fc" id="L208">				add(iter);</span>
			}else{
<span class="fc" id="L210">				skipBases(gappedStartOffset, iter);</span>
			}
			
<span class="fc" id="L213">		}</span>
	}

	@Override
	public String toString() {
<span class="nc" id="L218">		return JoinedStringBuilder.create(list)</span>
<span class="nc" id="L219">									.prefix(&quot;[ &quot;)</span>
<span class="nc" id="L220">									.glue(&quot;, &quot;)</span>
<span class="nc" id="L221">									.suffix(&quot; ]&quot;)</span>
<span class="nc" id="L222">									.build();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>