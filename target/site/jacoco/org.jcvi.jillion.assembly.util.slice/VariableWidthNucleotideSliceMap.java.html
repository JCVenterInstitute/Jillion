<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VariableWidthNucleotideSliceMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util.slice</a> &gt; <span class="el_source">VariableWidthNucleotideSliceMap.java</span></div><h1>VariableWidthNucleotideSliceMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.util.slice;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.core.DirectedRange;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;

public final class VariableWidthNucleotideSliceMap implements VariableWidthSliceMap&lt;Nucleotide, NucleotideSequence&gt;{

	private final VariableWidthNucleotideSlice[] slices;
	private final int widthPerSlice;

	private final NucleotideSequence gappedReferenceSequence;
	
<span class="fc" id="L48">	private VariableWidthNucleotideSliceMap(Builder builder){</span>
<span class="fc" id="L49">		this.widthPerSlice = builder.widthPerSlice;</span>
<span class="fc" id="L50">		this.gappedReferenceSequence = builder.trimmedGappedReferenceSequence;</span>
		
<span class="fc" id="L52">		slices = new VariableWidthNucleotideSlice[builder.builders.length];</span>
		
<span class="fc bfc" id="L54" title="All 2 branches covered.">		for(int i=0; i&lt;slices.length; i++){</span>
<span class="fc" id="L55">			slices[i] = builder.builders[i].build();</span>
		}
<span class="fc" id="L57">	}</span>
	
	@Override
	public VariableWidthSlice&lt;Nucleotide, NucleotideSequence&gt; getSlice(int offset) {
<span class="fc" id="L61">		return slices[offset];</span>
	}

	@Override
	public int getConsensusLength() {
<span class="fc" id="L66">		return (int) gappedReferenceSequence.getLength();</span>
	}
	
	public Stream&lt;VariableWidthSlice&lt;Nucleotide, NucleotideSequence&gt;&gt; getSlicesThatIntersectGapped(Range gappedRange){
		
<span class="nc" id="L71">		int startSliceOffset = gappedReferenceSequence.getUngappedOffsetFor((int)gappedRange.getBegin()) /widthPerSlice;</span>
<span class="nc" id="L72">		int endSliceOffset = gappedReferenceSequence.getUngappedOffsetFor((int)gappedRange.getEnd()) /widthPerSlice;</span>
		
<span class="nc" id="L74">		List&lt;VariableWidthSlice&lt;Nucleotide, NucleotideSequence&gt;&gt; list = new ArrayList&lt;&gt;(endSliceOffset-startSliceOffset +1);</span>
<span class="nc bnc" id="L75" title="All 4 branches missed.">		for(int i= Math.max(0, startSliceOffset); i&lt; slices.length &amp;&amp; i &lt;=endSliceOffset; i++){</span>
<span class="nc" id="L76">			list.add(slices[i]);</span>
		}
<span class="nc" id="L78">		return list.stream();</span>
	}
	
	public Stream&lt;VariableWidthSlice&lt;Nucleotide, NucleotideSequence&gt;&gt; getSlicesThatIntersectUngapped(Range ungappedRange){
		
<span class="nc" id="L83">		int startSliceOffset = (int) (ungappedRange.getBegin() /widthPerSlice);</span>
<span class="nc" id="L84">		int endSliceOffset = (int) (ungappedRange.getEnd() /widthPerSlice);</span>
		
<span class="nc" id="L86">		List&lt;VariableWidthSlice&lt;Nucleotide, NucleotideSequence&gt;&gt; list = new ArrayList&lt;&gt;(endSliceOffset-startSliceOffset +1);</span>
<span class="nc bnc" id="L87" title="All 4 branches missed.">		for(int i= Math.max(0, startSliceOffset); i&lt; slices.length &amp;&amp; i &lt;=endSliceOffset; i++){</span>
<span class="nc" id="L88">			list.add(slices[i]);</span>
		}
<span class="nc" id="L90">		return list.stream();</span>
	}
	
	
	@Override
	public int getNumberOfSlices() {
<span class="fc" id="L96">		return slices.length;</span>
	}
	
	
	public static class Builder{
		private final VariableWidthNucleotideSlice.Builder[] builders;
		private final int widthPerSlice;
		private final NucleotideSequence trimmedGappedReferenceSequence;

		private final List&lt;DirectedRange&gt; gappedExons;
		
		
		public Builder(NucleotideSequence gappedReferenceSequence, int ungappedWidthPerSlice){
<span class="fc" id="L109">			this(gappedReferenceSequence, ungappedWidthPerSlice, DirectedRange.create(Range.ofLength(gappedReferenceSequence.getLength())));</span>
<span class="fc" id="L110">		}</span>
		public Builder(NucleotideSequence gappedReferenceSequence, int ungappedWidthPerSlice, Range...gappedExons){
<span class="fc" id="L112">		    this(gappedReferenceSequence, ungappedWidthPerSlice, Arrays.stream(gappedExons)</span>
<span class="fc" id="L113">		            .map(DirectedRange::create)</span>
<span class="fc" id="L114">		            .collect(Collectors.toList()));</span>
<span class="fc" id="L115">		}</span>
		
		public Builder(NucleotideSequence gappedReferenceSequence, int ungappedWidthPerSlice, DirectedRange...gappedExons){
<span class="fc" id="L118">		    this(gappedReferenceSequence, ungappedWidthPerSlice, Arrays.asList(gappedExons));</span>
<span class="fc" id="L119">		}</span>
<span class="fc" id="L120">		private Builder(NucleotideSequence gappedReferenceSequence, int ungappedWidthPerSlice, List&lt;DirectedRange&gt; gappedExons){</span>
<span class="fc" id="L121">		    this.gappedExons = gappedExons;</span>
			//sort list incase it's out of order
<span class="fc" id="L123">			Collections.sort(this.gappedExons, Comparator.comparing(DirectedRange::asRange, Range.Comparators.ARRIVAL));</span>
			
<span class="fc" id="L125">			this.trimmedGappedReferenceSequence = getSplicedSequenceFor(gappedReferenceSequence, 0);</span>

			
<span class="fc" id="L128">			long ungappedLength = this.trimmedGappedReferenceSequence.getUngappedLength();</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">			if(ungappedWidthPerSlice &gt; ungappedLength){</span>
<span class="nc" id="L130">				throw new IllegalArgumentException(&quot;width per slice must be less than ungapped length&quot;);</span>
			}
<span class="fc" id="L132">			long rem = ungappedLength % ungappedWidthPerSlice;</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">			if(rem !=0){</span>
<span class="nc" id="L134">				throw new IllegalArgumentException(&quot;ungapped width per slice (&quot; +ungappedWidthPerSlice + </span>
						&quot;) must be a factor of the ungapped sequence length &quot; + ungappedLength);
			}
<span class="fc" id="L137">			int numberOfSlices = (int) (ungappedLength/ungappedWidthPerSlice);</span>

<span class="fc" id="L139">			this.widthPerSlice = ungappedWidthPerSlice;</span>
<span class="fc" id="L140">			builders = new VariableWidthNucleotideSlice.Builder[numberOfSlices];</span>
			
<span class="fc" id="L142">			Iterator&lt;Nucleotide&gt; iter = this.trimmedGappedReferenceSequence.iterator();</span>
<span class="fc" id="L143">			int i=0;</span>
<span class="fc" id="L144">			int currentGappedOffset=0;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">			while(iter.hasNext()){</span>
<span class="fc" id="L146">				NucleotideSequence gappedRefSubSeq = computeNumberOfGappedBasesReferenceSlice(ungappedWidthPerSlice, iter);</span>
<span class="fc" id="L147">				builders[i++] =  new VariableWidthNucleotideSlice.Builder(gappedRefSubSeq,currentGappedOffset);</span>
<span class="fc" id="L148">				currentGappedOffset += (int) gappedRefSubSeq.getLength();</span>
<span class="fc" id="L149">			}</span>
			
<span class="fc" id="L151">		}</span>
		private NucleotideSequence getSplicedSequenceFor(
				NucleotideSequence gappedReferenceSequence,
				int startOffset) {
			
<span class="fc" id="L156">			Range gappedFullReferenceRange = new Range.Builder(gappedReferenceSequence.getLength())</span>
<span class="fc" id="L157">														.shift(startOffset)</span>
<span class="fc" id="L158">														.build();</span>
			//check to make sure we intersect the exons somewhere...
<span class="fc" id="L160">			Optional&lt;DirectedRange&gt; intersect =gappedExons.stream()</span>
<span class="fc" id="L161">											.filter(exon -&gt; exon.asRange().intersects(gappedFullReferenceRange))</span>
<span class="fc" id="L162">											.findAny();</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">			if(!intersect.isPresent()){</span>
				//sequence doesn't intersect any exons 
<span class="fc" id="L165">				return new NucleotideSequenceBuilder().build();</span>
				
			}
<span class="fc" id="L168">			long seqLength = gappedReferenceSequence.getLength();</span>
<span class="fc" id="L169">			Range fullSeqRange = Range.ofLength(seqLength);</span>
<span class="fc" id="L170">			NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder((int) seqLength);</span>
			//gappedExons should be sorted
<span class="fc bfc" id="L172" title="All 2 branches covered.">			for(DirectedRange dr : gappedExons){</span>
<span class="fc" id="L173">			    Range seqRange = new Range.Builder(dr.asRange())</span>
<span class="fc" id="L174">                                                                  .shift(-startOffset)</span>
<span class="fc" id="L175">                                                                  .build();</span>
<span class="fc" id="L176">			    Range seqRangeToKeep = seqRange.intersection(fullSeqRange);</span>
			    
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">			    if(seqRangeToKeep.isEmpty()){</span>
<span class="nc" id="L179">			        continue;</span>
			    }
<span class="fc" id="L181">			    NucleotideSequenceBuilder exon = gappedReferenceSequence.toBuilder(seqRangeToKeep);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">			    if(dr.getDirection() == Direction.REVERSE){</span>
<span class="nc" id="L183">			        exon.reverseComplement();</span>
			    }
<span class="fc" id="L185">			    builder.append(exon);</span>
<span class="fc" id="L186">			}</span>
<span class="fc" id="L187">			return builder.build();</span>
			
//			List&lt;Range&gt; gappedIntrons = gappedFullReferenceRange.complementOf(this.gappedExons);
//			
//			NucleotideSequenceBuilder trimmedGappedReferenceBuilder =new NucleotideSequenceBuilder(gappedReferenceSequence);
//			//iterate backwards to avoid having to shift coordinates
//			for(int i= gappedIntrons.size()-1; i&gt;=0; i--){
//				//have to re-shift by start offset to get into read coord space
//				Range refRangeToDelete = gappedIntrons.get(i);
//				Range seqRangeToDelete = new Range.Builder(refRangeToDelete)
//													.shift(-startOffset)
//													.build();
//				trimmedGappedReferenceBuilder.delete(seqRangeToDelete);
//			}
//			
//			return trimmedGappedReferenceBuilder.build();
		}
		private NucleotideSequence computeNumberOfGappedBasesReferenceSlice(int ungappedWidthPerSlice, Iterator&lt;Nucleotide&gt; iter){
<span class="fc" id="L205">			NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder(ungappedWidthPerSlice *2);</span>

<span class="fc bfc" id="L207" title="All 4 branches covered.">			while(iter.hasNext() &amp;&amp; builder.getUngappedLength() &lt; ungappedWidthPerSlice ){</span>
<span class="fc" id="L208">				builder.append(iter.next());</span>
			}
<span class="fc" id="L210">			return builder.build();</span>
		}
		
		public Builder add(int offset, NucleotideSequence seq){
			
			
<span class="fc" id="L216">			NucleotideSequence splicedSequence = getSplicedSequenceFor(seq, offset);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">			if(splicedSequence.getLength() ==0){</span>
				//read entirely spliced out or doesn't intersect
				//with CDS so skip it
<span class="fc" id="L220">				return this;</span>
			}
<span class="fc" id="L222">			int splicedStartOffset = getSplicedStartOffsetFor(offset);</span>
			
			//because our slices may start with gaps, we need to get the right flanking non-gap
			//offset to find the correct first builder bin to use
<span class="fc" id="L226">			int flankingGappedRefOffset =	AssemblyUtil.getRightFlankingNonGapIndex(trimmedGappedReferenceSequence, splicedStartOffset);</span>

<span class="fc" id="L228">			int ungappedStartOffset = trimmedGappedReferenceSequence.getUngappedOffsetFor(flankingGappedRefOffset);</span>
<span class="fc" id="L229">			int currentOffset = ungappedStartOffset/widthPerSlice;</span>
			
<span class="fc" id="L231">			Iterator&lt;Nucleotide&gt; iter = splicedSequence.iterator();</span>
			//handle initial specially to check for leading gaps
			
			
<span class="fc" id="L235">			builders[currentOffset++].addBeginningOfRead(splicedStartOffset, iter);</span>
			
			//handle the rest
<span class="pc bpc" id="L238" title="1 of 4 branches missed.">			while(iter.hasNext() &amp;&amp; currentOffset &lt; builders.length){			</span>
<span class="fc" id="L239">				builders[currentOffset++].add(iter);</span>
				
			}
			
			
			
<span class="fc" id="L245">			return this;</span>
		}
		private int getSplicedStartOffsetFor(int offset) {
			//we need to subtract the gapped length of our introns
			
<span class="fc" id="L250">			Range upstreamOfRead = 	Range.ofLength(offset);</span>
<span class="fc" id="L251">			List&lt;Range&gt; upstreamIntrons = upstreamOfRead.complementOf(gappedExons);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">			if(upstreamIntrons.isEmpty()){</span>
				//the splicedStartOffset doesn't take into account any bases 
				//BEFORE THE exons so we have to still adjust it to get it into
				//exon coordinate space
				//this should be safe since we should always have at least 1 exon
				
<span class="fc" id="L258">				int exonStart = (int) gappedExons.get(0).getBegin();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">				if(offset &lt; exonStart){</span>
					//adjust our offset to be the start of the exon
					//our spliced sequence should fix the string length
<span class="fc" id="L262">					return 0;</span>
				}
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">				else if(exonStart &lt;= offset){</span>
<span class="fc" id="L265">					return offset - exonStart;</span>
				}
<span class="nc" id="L267">				return offset;</span>
			}
			
<span class="fc" id="L270">			long intronLength = 0;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">			for(Range r : upstreamIntrons){</span>
<span class="fc" id="L272">				intronLength+= r.getLength();</span>
<span class="fc" id="L273">			}</span>
<span class="fc" id="L274">			return offset - (int) intronLength;</span>
		}
		
		public VariableWidthNucleotideSliceMap build(){
<span class="fc" id="L278">			return new VariableWidthNucleotideSliceMap(this);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>