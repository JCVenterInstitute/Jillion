<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VulgarProtein2Genome2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.align.exonerate.vulgar</a> &gt; <span class="el_source">VulgarProtein2Genome2.java</span></div><h1>VulgarProtein2Genome2.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.align.exonerate.vulgar;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.ToIntFunction;

import org.jcvi.jillion.core.DirectedRange;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Ranges;
import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.residue.Frame;
import org.jcvi.jillion.core.residue.aa.AminoAcid;
import org.jcvi.jillion.core.residue.aa.IupacTranslationTables;
import org.jcvi.jillion.core.residue.aa.ProteinSequence;
import org.jcvi.jillion.core.residue.aa.ProteinSequenceBuilder;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;

public class VulgarProtein2Genome2 {

    private final List&lt;VulgarElement&gt; elements;

    private final List&lt;Range&gt; targetExons, targetGaps;
    private final List&lt;Range&gt; queryRanges, queryGaps;
    
    private final String queryId, targetId;
    
    private final float score;
    
    private Direction queryStrand, targetStrand;
    private final DirectedRange queryRange, targetRange;
    
    private List&lt;AlignmentFragment&gt; fragments ;
    

    public static class AlignmentFragment{
        private final Direction direction;
        private final Range proteinSeqRange;
        private final Range nucleotideSeqRange;
        private final Frame frame;
        protected AlignmentFragment(Direction direction, Range proteinSeqRange,
<span class="nc" id="L73">                Range nucleotideSeqRange, Frame frame) {</span>
<span class="nc" id="L74">            this.direction = direction;</span>
<span class="nc" id="L75">            this.proteinSeqRange = proteinSeqRange;</span>
<span class="nc" id="L76">            this.nucleotideSeqRange = nucleotideSeqRange;</span>
<span class="nc" id="L77">            this.frame = frame;</span>
<span class="nc" id="L78">        }</span>
        public Direction getDirection() {
<span class="nc" id="L80">            return direction;</span>
        }
        public Range getProteinSeqRange() {
<span class="nc" id="L83">            return proteinSeqRange;</span>
        }
        public Range getNucleotideSeqRange() {
<span class="nc" id="L86">            return nucleotideSeqRange;</span>
        }
        public Frame getFrame() {
<span class="nc" id="L89">            return frame;</span>
        }
        
        private static class Builder{
            private final Frame frame;
            private final Direction direction;
            
            Range.Builder nucleotideRangeBuilder, proteinRangeBuilder;
            
<span class="nc" id="L98">            protected Builder(Frame frame, Direction direction, long startNucleotideOffset, long startProteinOffset) {</span>
<span class="nc" id="L99">                this.frame = frame;</span>
<span class="nc" id="L100">                this.direction = direction;</span>
                
<span class="nc" id="L102">                nucleotideRangeBuilder = new Range.Builder(0).shift(startNucleotideOffset);</span>
<span class="nc" id="L103">                proteinRangeBuilder = new Range.Builder(0).shift(startProteinOffset);</span>
<span class="nc" id="L104">            }</span>
            
            public Builder add(long nucleotideLength, long queryLength){
<span class="nc" id="L107">                nucleotideRangeBuilder.expandEnd(nucleotideLength);</span>
<span class="nc" id="L108">                proteinRangeBuilder.expandEnd(queryLength);</span>
                
                
<span class="nc" id="L111">                return this;</span>
            }
            
            public AlignmentFragment build(){
<span class="nc" id="L115">                return new AlignmentFragment(direction, proteinRangeBuilder.build(), nucleotideRangeBuilder.build(), frame);</span>
            }
        }
        
        
    }
    
    
    public VulgarProtein2Genome2(String queryId, String targetId, List&lt;VulgarElement&gt; elements, float score,
<span class="nc" id="L124">            String queryStrand, DirectedRange queryRange, String targetStrand, DirectedRange targetRange) {</span>
<span class="nc" id="L125">        this.elements = elements;</span>
<span class="nc" id="L126">        this.queryId = Objects.requireNonNull(queryId);</span>
<span class="nc" id="L127">        this.targetId = Objects.requireNonNull(targetId);</span>
<span class="nc" id="L128">        this.score = score;</span>
<span class="nc" id="L129">        this.queryRange = Objects.requireNonNull(queryRange);</span>
<span class="nc" id="L130">        this.targetRange = Objects.requireNonNull(targetRange);</span>
        
<span class="nc" id="L132">        targetExons = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L133">        targetGaps = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L135">        queryRanges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L136">        queryGaps = new ArrayList&lt;&gt;();</span>
        
//        BiConsumer&lt;Long, VulgarElement&gt; insertionConsumer = (offset, e) -&gt; queryGaps.add(new Range.Builder(e.getTargetLength() /3).shift(offset - queryRange.getBegin()).build());
//        BiConsumer&lt;Long, VulgarElement&gt; deletionConsumer = (offset, e) -&gt; targetGaps.add(new Range.Builder(e.getQueryLength() *3).shift(offset - targetRange.getBegin() + queryRange.getBegin()).build());
//        
//        
//        computeRanges(queryRange.getBegin(), VulgarElement::getQueryLength, queryRanges, insertionConsumer);
//        computeRanges(targetRange.getBegin(), VulgarElement::getTargetLength, targetExons, deletionConsumer);
//        
<span class="nc" id="L145">        long queryOffset = 0;</span>
<span class="nc" id="L146">        long targetOffset = 0;</span>
<span class="nc" id="L147">        this.queryStrand = parseStrand(queryStrand);</span>
<span class="nc" id="L148">        this.targetStrand = parseStrand(targetStrand);</span>
<span class="nc" id="L149">        Frame currentFrame= Frame.ONE;</span>
        
<span class="nc" id="L151">        fragments = new ArrayList&lt;&gt;();</span>
        //query = aa
        //target = nuc
<span class="nc" id="L154">        AlignmentFragment.Builder currentBuilder = new AlignmentFragment.Builder(Frame.ONE,</span>
<span class="nc" id="L155">                this.targetStrand , targetRange.getBegin(), queryRange.getBegin());</span>
<span class="nc" id="L156">        boolean spliced=false;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        for(VulgarElement e : elements){</span>
<span class="nc" id="L158">        	queryOffset+=e.getQueryLength();</span>
<span class="nc" id="L159">            targetOffset+=e.getTargetLength();</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">            if(e.getOp() == VulgarOperation.Match || e.getOp() == VulgarOperation.Split_Codon){</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            	if(spliced){</span>
<span class="nc" id="L162">            		currentFrame = currentFrame.shift(e.getTargetLength());</span>
<span class="nc" id="L163">            		spliced=false;</span>
            	}
<span class="nc bnc" id="L165" title="All 2 branches missed.">                if(currentBuilder ==null){</span>
<span class="nc" id="L166">                    currentBuilder = new AlignmentFragment.Builder(currentFrame,</span>
<span class="nc" id="L167">                            this.targetStrand , targetRange.getBegin()+ targetOffset - e.getTargetLength(), queryRange.getBegin()+queryOffset - e.getQueryLength());</span>
                }
                    
<span class="nc" id="L170">                currentBuilder.add(e.getTargetLength(), e.getQueryLength());</span>
                               
                
<span class="nc bnc" id="L173" title="All 2 branches missed.">                if(e.getOp() == VulgarOperation.Gap){</span>
<span class="nc" id="L174">                    queryGaps.add(new Range.Builder(e.getTargetLength()/3).shift(queryOffset).build());</span>
<span class="nc" id="L175">                    targetGaps.add(new Range.Builder(e.getQueryLength()*3).shift(targetOffset).build());</span>
                }
             
                
<span class="nc bnc" id="L179" title="All 2 branches missed.">            }else if(e.getOp() == VulgarOperation.Gap){</span>
<span class="nc" id="L180">                fragments.add(currentBuilder.build());</span>
              
<span class="nc" id="L182">                currentBuilder = new AlignmentFragment.Builder(currentFrame,</span>
<span class="nc" id="L183">                        this.targetStrand , targetRange.getBegin()+ targetOffset, queryRange.getBegin()+queryOffset);</span>
                
<span class="nc bnc" id="L185" title="All 4 branches missed.">            }else if(e.getOp() == VulgarOperation.Splice_5 || e.getOp() == VulgarOperation.Splice_3){</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            	if(e.getOp() == VulgarOperation.Splice_3){</span>
<span class="nc" id="L187">            		spliced=true;</span>
            	}
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if(currentBuilder !=null){</span>
<span class="nc" id="L190">                    fragments.add(currentBuilder.build());</span>
<span class="nc" id="L191">                    currentBuilder =null;</span>
<span class="nc" id="L192">                    spliced=false;</span>
<span class="nc" id="L193">                    currentFrame = Frame.ONE;</span>
                }
<span class="nc bnc" id="L195" title="All 2 branches missed.">            }else if(e.getOp() == VulgarOperation.Frameshift){</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if(currentBuilder !=null){</span>
<span class="nc" id="L197">                    fragments.add(currentBuilder.build());</span>
                }
<span class="nc" id="L199">                currentBuilder = new AlignmentFragment.Builder(currentFrame,</span>
<span class="nc" id="L200">                        this.targetStrand , targetRange.getBegin()+ targetOffset, queryRange.getBegin()+queryOffset);</span>
            }       
<span class="nc" id="L202">        }</span>
<span class="nc" id="L203">        fragments.add(currentBuilder.build());</span>
             
<span class="nc" id="L205">    }</span>
    
    public List&lt;AlignmentFragment&gt; getAlignmentFragments(){
<span class="nc" id="L208">        return fragments;</span>
    }
    
    private Direction parseStrand(String strand){
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if(&quot;.&quot;.equals(strand)){</span>
<span class="nc" id="L213">            return null;</span>
        }
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if(&quot;+&quot;.equals(strand)){</span>
<span class="nc" id="L216">            return Direction.FORWARD;</span>
        }
<span class="nc" id="L218">        return Direction.REVERSE;</span>
    }
    
    public Optional&lt;Direction&gt; getQueryStrand(){
<span class="nc" id="L222">        return Optional.ofNullable(queryStrand);</span>
    }
    
    public Optional&lt;Direction&gt; getTargetStrand(){
<span class="nc" id="L226">        return Optional.ofNullable(targetStrand);</span>
    }
    
    public float getScore() {
<span class="nc" id="L230">        return score;</span>
    }




    public String getQueryId() {
<span class="nc" id="L237">        return queryId;</span>
    }




    public String getTargetId() {
<span class="nc" id="L244">        return targetId;</span>
    }




    public List&lt;VulgarElement&gt; getElements() {
<span class="nc" id="L251">        return elements;</span>
    }




    public List&lt;Range&gt; getTargetExons() {
<span class="nc" id="L258">        return targetExons;</span>
    }




    public List&lt;Range&gt; getQueryRanges() {
<span class="nc" id="L265">        return queryRanges;</span>
    }




    private void computeRanges(long startOffset, ToIntFunction&lt;VulgarElement&gt; function,
            List&lt;Range&gt; exons, BiConsumer&lt;Long, VulgarElement&gt; gapConsumer) {

<span class="nc" id="L274">        long currentOffset=startOffset;</span>
        
<span class="nc bnc" id="L276" title="All 2 branches missed.">        for(VulgarElement e : elements){</span>
<span class="nc" id="L277">            int len = function.applyAsInt(e);</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">            if(e.getOp() == VulgarOperation.Match || e.getOp() == VulgarOperation.Split_Codon){</span>
<span class="nc" id="L279">                exons.add(new Range.Builder(len).shift(currentOffset).build());</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            }else if(e.getOp() == VulgarOperation.Gap){</span>
<span class="nc" id="L281">                gapConsumer.accept(currentOffset, e);</span>
<span class="nc" id="L282">                exons.add(new Range.Builder(len).shift(currentOffset).build());</span>
            }
<span class="nc" id="L284">            currentOffset+=len;</span>
<span class="nc" id="L285">        }</span>

        
<span class="nc" id="L288">        mergeInPlace(exons);</span>
<span class="nc" id="L289">    }</span>
   
    private static void mergeInPlace(List&lt;Range&gt; ranges){
<span class="nc" id="L292">        List&lt;Range&gt; merged = Ranges.merge(ranges);</span>
<span class="nc" id="L293">        ranges.clear();</span>
<span class="nc" id="L294">        ranges.addAll(merged);</span>
<span class="nc" id="L295">    }</span>
    //this functional interface is created and used
    //instead of Function&lt;String, Sequence&gt;
    //because we will most often use DataStore::get
    //which throws exceptions
    //so we have to make our own version that can also throw an Exception.
    @FunctionalInterface
    public interface ToSequenceFunction&lt;T extends Sequence&lt;?&gt;, E extends Exception&gt;{

         T apply(String t) throws E;
        
    }
    
    
    public &lt;E extends Exception, E2 extends Exception&gt; AlignmentResult align(ToSequenceFunction&lt;NucleotideSequence, E&gt; targetFunction,
                                 ToSequenceFunction&lt;ProteinSequence, E2&gt; queryFunction) throws E, E2{
<span class="nc" id="L311">        return align(targetFunction.apply(targetId), queryFunction.apply(queryId));</span>
    }
    public AlignmentResult align(NucleotideSequence target, ProteinSequence query){
        
       
<span class="nc" id="L316">        NucleotideSequence cds =getExonSequence(target, targetExons, targetGaps);</span>
<span class="nc" id="L317">        ProteinSequence translated = IupacTranslationTables.STANDARD.translate(cds);</span>
        
<span class="nc" id="L319">        ProteinSequenceBuilder queryBuilder = query.toBuilder(queryRange.asRange());</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        for(int i= queryGaps.size()-1; i&gt;=0; i--){</span>
<span class="nc" id="L321">            Range gap = queryGaps.get(i);</span>
<span class="nc" id="L322">            char[] gaps = new char[(int) gap.getLength()];</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if(gaps.length &gt; 1){</span>
<span class="nc" id="L324">                System.out.println(&quot;here&quot;);</span>
            }
<span class="nc" id="L326">            Arrays.fill(gaps, AminoAcid.Gap.asChar());</span>
<span class="nc" id="L327">            queryBuilder.insert((int)gap.getBegin(), new String(gaps));</span>
        }
       
<span class="nc" id="L330">        ProteinSequence querySeq = queryBuilder.build();</span>
<span class="nc" id="L331">        String queryAlignment = querySeq.toString(AminoAcid::get3LetterAbbreviation).replaceAll(&quot;(.{62})&quot;, &quot;$1\n&quot;);</span>
<span class="nc" id="L332">        String translatedAlignment = translated.toString(AminoAcid::get3LetterAbbreviation).replaceAll(&quot;(.{62})&quot;, &quot;$1\n&quot;);</span>
<span class="nc" id="L333">        String cdsAlignment = cds.toString().replaceAll(&quot;(.{62})&quot;, &quot;$1\n&quot;);</span>
        
<span class="nc" id="L335">        try(BufferedReader qr = new BufferedReader(new StringReader(queryAlignment));</span>
<span class="nc" id="L336">            BufferedReader tr = new BufferedReader(new StringReader(translatedAlignment));</span>
<span class="nc" id="L337">                BufferedReader cdsr = new BufferedReader(new StringReader(cdsAlignment))){</span>
            String qLine, tLine;
<span class="nc bnc" id="L339" title="All 4 branches missed.">            while( (qLine = qr.readLine()) !=null &amp;&amp; (tLine = tr.readLine()) !=null){</span>
<span class="nc" id="L340">                System.out.println(qLine);</span>
<span class="nc" id="L341">                System.out.println(tLine);</span>
<span class="nc" id="L342">                System.out.println(cdsr.readLine()+&quot;\n&quot;);</span>
            }
<span class="nc" id="L344">            System.out.println(&quot;======&quot;);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            while((qLine = qr.readLine()) !=null){</span>
<span class="nc" id="L346">                System.out.println(&quot; QLINE REMAINING = &quot; +qLine);</span>
            }
<span class="nc bnc" id="L348" title="All 2 branches missed.">            while((tLine = tr.readLine()) !=null){</span>
<span class="nc" id="L349">                System.out.println(&quot; T_LINE REMAINING = &quot; +tLine);</span>
            }
            
<span class="nc bnc" id="L352" title="All 24 branches missed.">        }catch(IOException impossible){</span>
<span class="nc" id="L353">            impossible.printStackTrace();</span>
<span class="nc" id="L354">        }</span>
        
        
        
       
        
<span class="nc" id="L360">        Iterator&lt;AminoAcid&gt; queryIter = querySeq.iterator();</span>
<span class="nc" id="L361">        Iterator&lt;AminoAcid&gt; subIter = translated.iterator();</span>
<span class="nc" id="L362">        int matches=0, misMatches=0;</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">        while(queryIter.hasNext() &amp;&amp; subIter.hasNext()){</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if(queryIter.next() == subIter.next()){</span>
<span class="nc" id="L365">                matches++;</span>
            }else{
<span class="nc" id="L367">                misMatches++;</span>
            }
        }
<span class="nc bnc" id="L370" title="All 2 branches missed.">        while(queryIter.hasNext()){</span>
<span class="nc" id="L371">            queryIter.next();</span>
<span class="nc" id="L372">            misMatches++;</span>
        }
        
<span class="nc bnc" id="L375" title="All 2 branches missed.">        while(subIter.hasNext()){</span>
<span class="nc" id="L376">            subIter.next();</span>
<span class="nc" id="L377">            misMatches++;</span>
        }
<span class="nc" id="L379">        System.out.println(&quot;matches = &quot; + matches);</span>
<span class="nc" id="L380">        System.out.println(&quot;misMatches = &quot; + misMatches);</span>
<span class="nc" id="L381">        double ident = matches /(double)(matches + misMatches) *100;</span>
<span class="nc" id="L382">        System.out.println(&quot;percent ident = &quot; + ident);</span>
<span class="nc" id="L383">        return new AlignmentResult(queryId, targetId, ident, matches, misMatches);</span>
    }
    
    
    public static class AlignmentResult{
        private final double percentIdentity;
        private final int matches, misMatches;
        private final String queryId, targetId;
        
        protected AlignmentResult(String queryId, String targetId, double percentIdentity, int matches,
<span class="nc" id="L393">                int misMatches) {</span>
<span class="nc" id="L394">            this.percentIdentity = percentIdentity;</span>
<span class="nc" id="L395">            this.matches = matches;</span>
<span class="nc" id="L396">            this.misMatches = misMatches;</span>
<span class="nc" id="L397">            this.queryId = queryId;</span>
<span class="nc" id="L398">            this.targetId = targetId;</span>
<span class="nc" id="L399">        }</span>

        public String getQueryId() {
<span class="nc" id="L402">            return queryId;</span>
        }

        public String getTargetId() {
<span class="nc" id="L406">            return targetId;</span>
        }

        public double getPercentIdentity() {
<span class="nc" id="L410">            return percentIdentity;</span>
        }

        public int getMatches() {
<span class="nc" id="L414">            return matches;</span>
        }

        public int getMisMatches() {
<span class="nc" id="L418">            return misMatches;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L423">            return &quot;AlignmentResult [percentIdentity=&quot; + percentIdentity</span>
                    + &quot;, matches=&quot; + matches + &quot;, misMatches=&quot; + misMatches
                    + &quot;]&quot;;
        }

        @Override
        public int hashCode() {
<span class="nc" id="L430">            final int prime = 31;</span>
<span class="nc" id="L431">            int result = 1;</span>
<span class="nc" id="L432">            result = prime * result + matches;</span>
<span class="nc" id="L433">            result = prime * result + misMatches;</span>
            long temp;
<span class="nc" id="L435">            temp = Double.doubleToLongBits(percentIdentity);</span>
<span class="nc" id="L436">            result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            result = prime * result</span>
<span class="nc" id="L438">                    + ((queryId == null) ? 0 : queryId.hashCode());</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            result = prime * result</span>
<span class="nc" id="L440">                    + ((targetId == null) ? 0 : targetId.hashCode());</span>
<span class="nc" id="L441">            return result;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L447">                return true;</span>
            }
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L450">                return false;</span>
            }
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (!(obj instanceof AlignmentResult)) {</span>
<span class="nc" id="L453">                return false;</span>
            }
<span class="nc" id="L455">            AlignmentResult other = (AlignmentResult) obj;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (matches != other.matches) {</span>
<span class="nc" id="L457">                return false;</span>
            }
<span class="nc bnc" id="L459" title="All 2 branches missed.">            if (misMatches != other.misMatches) {</span>
<span class="nc" id="L460">                return false;</span>
            }
<span class="nc" id="L462">            if (Double.doubleToLongBits(percentIdentity) != Double</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                    .doubleToLongBits(other.percentIdentity)) {</span>
<span class="nc" id="L464">                return false;</span>
            }
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (queryId == null) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                if (other.queryId != null) {</span>
<span class="nc" id="L468">                    return false;</span>
                }
<span class="nc bnc" id="L470" title="All 2 branches missed.">            } else if (!queryId.equals(other.queryId)) {</span>
<span class="nc" id="L471">                return false;</span>
            }
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (targetId == null) {</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                if (other.targetId != null) {</span>
<span class="nc" id="L475">                    return false;</span>
                }
<span class="nc bnc" id="L477" title="All 2 branches missed.">            } else if (!targetId.equals(other.targetId)) {</span>
<span class="nc" id="L478">                return false;</span>
            }
<span class="nc" id="L480">            return true;</span>
        }
        
        
    }

    private NucleotideSequence getExonSequence(NucleotideSequence t,
            List&lt;Range&gt; rangesToKeep, List&lt;Range&gt; gaps) {
       //ranges To keep should be in gapped coords
        
<span class="nc" id="L490">        NucleotideSequenceBuilder builder = t.toBuilder(targetRange.asRange());</span>
<span class="nc" id="L491">        ListIterator&lt;Range&gt; iter = gaps.listIterator(gaps.size());</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        while(iter.hasPrevious()){</span>
//        for(Range g : gaps){
<span class="nc" id="L494">            Range g = iter.previous();</span>
<span class="nc" id="L495">            int offset = (int) g.getBegin();</span>
<span class="nc" id="L496">            Nucleotide[] array = new Nucleotide[(int) g.getLength()];</span>
            
<span class="nc" id="L498">            Arrays.fill(array, Nucleotide.Gap);</span>
            
<span class="nc" id="L500">            builder.insert(offset, array);</span>
<span class="nc" id="L501">        }</span>
        
<span class="nc" id="L503">        List&lt;Range.Builder&gt; gappedRangesToKeep = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        for (Range r : rangesToKeep) {</span>
<span class="nc" id="L505">            gappedRangesToKeep.add(r.toBuilder());</span>
<span class="nc" id="L506">        }</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        for (Range gap : gaps) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            for (Range.Builder b : gappedRangesToKeep) {</span>

<span class="nc bnc" id="L510" title="All 2 branches missed.">                if (b.startsAfter(gap)) {</span>
<span class="nc" id="L511">                    b.shift(gap.getLength());</span>
                }
<span class="nc" id="L513">            }</span>
<span class="nc" id="L514">        }</span>
//       
//        List&lt;Range&gt; allRangesToKeep = gappedRangesToKeep.stream().map(Range.Builder::build).collect(Collectors.toList());
//        allRangesToKeep.addAll(gaps);
//        
//        mergeInPlace(allRangesToKeep);
//        
//        NucleotideSequenceBuilder builder = t.toBuilder();
//        ListIterator&lt;Range&gt; iter = gaps.listIterator(gaps.size());
//        while(iter.hasPrevious()){
//            Range r = iter.previous();
//            int offset = (int) r.getBegin();
//            Nucleotide[] array = new Nucleotide[(int) r.getLength()];
//            
//            Arrays.fill(array, Nucleotide.Gap);
//            
//            builder.insert(offset, array);
//        }
        
//        
//        List&lt;Range&gt; complement = Range.ofLength(builder.getLength()).complement(allRangesToKeep);
////        List&lt;Range&gt; complement = Range.ofLength(builder.getLength()).complement(rangesToKeep);
//        for(int i = complement.size()-1; i &gt;=0; i--){
//            builder.delete(complement.get(i));
//        }
       
<span class="nc" id="L540">        return builder.build();</span>
    }
    
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>