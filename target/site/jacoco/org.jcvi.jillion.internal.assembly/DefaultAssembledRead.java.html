<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultAssembledRead.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.assembly</a> &gt; <span class="el_source">DefaultAssembledRead.java</span></div><h1>DefaultAssembledRead.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Sep 4, 2008
 *
 * @author dkatzel
 */
package org.jcvi.jillion.internal.assembly;

import java.util.Map;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.AssembledReadBuilder;
import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.assembly.ReadInfo;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.residue.nt.ReferenceMappedNucleotideSequence;


public final class DefaultAssembledRead implements AssembledRead {

    private final long start;
    private final byte directionOrdinal;
    private final ReferenceMappedNucleotideSequence sequence;
    private final String id;
    private final ReadInfo readInfo;

    
    public static AssembledReadBuilder&lt;AssembledRead&gt; createBuilder(String readId, 
            NucleotideSequence validBases,int offset,
            Direction dir, Range clearRange, int ungappedFullLength){
<span class="fc" id="L54">        return new Builder(readId, validBases, offset, dir, clearRange, </span>
                ungappedFullLength);
    }
    
    public static AssembledReadBuilder&lt;AssembledRead&gt; createBuilder(String readId, 
            String validBases,int offset,
            Direction dir, Range clearRange, int ungappedFullLength){
<span class="fc" id="L61">    	 return createBuilder(readId, new NucleotideSequenceBuilder(validBases).build(), offset, dir, clearRange, </span>
                 ungappedFullLength);
    }
    
    public DefaultAssembledRead(String id, ReferenceMappedNucleotideSequence sequence, 
<span class="fc" id="L66">    		long start, Direction sequenceDirection, int ungappedFullLength, Range validRange){</span>
<span class="fc" id="L67">       this.id = id;</span>
<span class="fc" id="L68">       this.sequence = sequence;</span>
<span class="fc" id="L69">        this.start= start;</span>
<span class="fc" id="L70">        this.directionOrdinal = (byte)sequenceDirection.ordinal();</span>
<span class="fc" id="L71">        this.readInfo = new ReadInfo(validRange, ungappedFullLength);</span>
<span class="fc" id="L72">    }</span>
    
    
    @Override
	public ReadInfo getReadInfo() {
<span class="fc" id="L77">		return readInfo;</span>
	}

	@Override
    public long getGappedLength() {
<span class="fc" id="L82">        return sequence.getLength();</span>
    }

    @Override
    public long getGappedStartOffset() {
<span class="fc" id="L87">        return start;</span>
    }
    
    
    @Override
	public String toString() {
<span class="nc" id="L93">		return &quot;DefaultPlacedRead [start=&quot; + start + &quot;, directionOrdinal=&quot;</span>
				+ directionOrdinal + &quot;, id=&quot; + id + &quot;]&quot;;
	}

	@Override
    public int hashCode() {
<span class="fc" id="L99">        final int prime = 31;</span>
<span class="fc" id="L100">        int result = 1;</span>
<span class="fc" id="L101">        result = prime * result + id.hashCode();</span>
<span class="fc" id="L102">        result = prime * result + sequence.hashCode();</span>
<span class="fc" id="L103">        result = prime * result + directionOrdinal;</span>
<span class="fc" id="L104">        result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="fc" id="L105">        return result;</span>
    }
    /**
     * Two PlacedReads are equal if they have the same start value
     * and they have their reads are equal.
     */
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (this == obj){</span>
<span class="fc" id="L114">            return true;</span>
        }
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (obj instanceof AssembledRead){           </span>
<span class="fc" id="L117">        	AssembledRead other = (AssembledRead) obj;</span>
<span class="pc bpc" id="L118" title="3 of 4 branches missed.">        	if(getId()==null &amp;&amp; other.getId() !=null){</span>
<span class="nc" id="L119">        		return false;</span>
        	}
<span class="fc bfc" id="L121" title="All 2 branches covered.">        	if(!getId().equals(other.getId())){</span>
<span class="fc" id="L122">        		return false;</span>
        	}
<span class="pc bpc" id="L124" title="3 of 4 branches missed.">        	if(getNucleotideSequence()==null &amp;&amp; other.getNucleotideSequence() !=null){</span>
<span class="nc" id="L125">        		return false;</span>
        	}
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        	if(other.getNucleotideSequence() ==null){</span>
<span class="nc" id="L128">        		return false;</span>
        	}
<span class="fc bfc" id="L130" title="All 2 branches covered.">        	if(!getNucleotideSequence().equals(other.getNucleotideSequence())){</span>
<span class="fc" id="L131">        		return false;</span>
        	}
        	
<span class="fc bfc" id="L134" title="All 2 branches covered.">            return start== other.getGappedStartOffset() </span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            &amp;&amp; getDirection() == other.getDirection();</span>
        }
<span class="fc" id="L137">        return false;</span>
        
    }
    
    @Override
    public Direction getDirection() {
<span class="fc" id="L143">        return Direction.values()[directionOrdinal];</span>
    }
  
    @Override
    public long getGappedEndOffset() {
<span class="fc" id="L148">        return getGappedStartOffset()+getGappedLength()-1;</span>
    }

    public Map&lt;Integer, Nucleotide&gt; getDifferenceMap(){
<span class="nc" id="L152">       return getNucleotideSequence().getDifferenceMap();</span>
        
    }
    @Override
    public ReferenceMappedNucleotideSequence getNucleotideSequence() {
<span class="fc" id="L157">        return sequence;</span>
    }
    @Override
    public String getId() {
<span class="fc" id="L161">        return id;</span>
    }
    @Override
    public long toGappedValidRangeOffset(long referenceIndex) {
        
<span class="fc" id="L166">        long validRangeIndex= referenceIndex - getGappedStartOffset();</span>
<span class="fc" id="L167">        checkValidRange(validRangeIndex);</span>
<span class="fc" id="L168">        return validRangeIndex;</span>
    }
    @Override
    public long toReferenceOffset(long validRangeIndex) {
<span class="fc" id="L172">        checkValidRange(validRangeIndex);</span>
<span class="fc" id="L173">        return getGappedStartOffset() +validRangeIndex;</span>
    }
    private void checkValidRange(long validRangeIndex) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if(validRangeIndex &lt;0){</span>
<span class="fc" id="L177">            throw new IndexOutOfBoundsException(&quot;reference index refers to index before valid range &quot; + validRangeIndex);</span>
        }
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if(validRangeIndex &gt; getGappedLength()-1){</span>
<span class="fc" id="L180">            throw new IndexOutOfBoundsException(&quot;reference index refers to index after valid range&quot;);</span>
        }
<span class="fc" id="L182">    }</span>

    /**
    * {@inheritDoc}
    */
    @Override
    public Range asRange() {
<span class="fc" id="L189">        return getGappedContigRange();</span>
    }
    
    @Override
	public Range getGappedContigRange() {
<span class="fc" id="L194">		return Range.of(getGappedStartOffset(), getGappedEndOffset());</span>
	}

	private static class Builder implements AssembledReadBuilder&lt;AssembledRead&gt;{
        private final String readId;
        /**
         * Our original encoded sequence.  If we 
         * edit the basecalls, this will get set to null
         * and we use {@link #basesBuilder} instead.
         */
        private NucleotideSequence originalSequence;
        /**
         * Our edited sequence, only used if needed
         * since it takes up more memory.
         */
<span class="fc" id="L209">        private NucleotideSequenceBuilder basesBuilder=null;</span>
        private int offset;
        private Range clearRange;
        private final Direction dir;
        private int ungappedFullLength;
        
<span class="fc" id="L215">        private Builder( Builder copy){</span>
<span class="fc" id="L216">        	this.readId = copy.readId;</span>
<span class="fc" id="L217">            this.dir =copy.dir;</span>
<span class="fc" id="L218">            this.clearRange = copy.clearRange;</span>
<span class="fc" id="L219">            this.offset = copy.offset;</span>
<span class="fc" id="L220">            this.originalSequence = copy.originalSequence;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            this.basesBuilder =copy.basesBuilder==null? null: copy.basesBuilder.copy();</span>
<span class="fc" id="L222">            this.ungappedFullLength = copy.ungappedFullLength;</span>
<span class="fc" id="L223">        }</span>
        
        public Builder(String readId, NucleotideSequence validBases, int offset,
<span class="fc" id="L226">                            Direction dir, Range clearRange, int ungappedFullLength){</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        	if(readId ==null){</span>
<span class="nc" id="L228">        		throw new NullPointerException(&quot;read id can not be null&quot;);</span>
        	}
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        	if(dir ==null){</span>
<span class="nc" id="L231">        		throw new NullPointerException(&quot;direction can not be null&quot;);</span>
        	}
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        	if(validBases == null){</span>
<span class="nc" id="L234">        		throw new NullPointerException(&quot;basecalls can not be null&quot;);</span>
        	}
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        	if(clearRange == null){</span>
<span class="nc" id="L237">        		throw new NullPointerException(&quot;clearRange can not be null&quot;);</span>
        	}
<span class="fc" id="L239">            this.readId = readId;</span>
<span class="fc" id="L240">            this.dir =dir;</span>
<span class="fc" id="L241">            this.clearRange = clearRange;</span>
<span class="fc" id="L242">            this.offset = offset;</span>
<span class="fc" id="L243">            this.originalSequence = validBases;</span>
<span class="fc" id="L244">            this.basesBuilder =null;</span>
            
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if(ungappedFullLength &lt; clearRange.getEnd()){</span>
<span class="nc" id="L247">            	throw new IllegalArgumentException(&quot;clear range extends beyond ungapped full length&quot;);</span>
            }
<span class="fc" id="L249">            this.ungappedFullLength = ungappedFullLength;</span>
<span class="fc" id="L250">        }</span>
        
        @Override
		public AssembledReadBuilder&lt;AssembledRead&gt; copy() {
<span class="fc" id="L254">			return new Builder(this);</span>
		}
        
        
        private void validateNewOffset(int newOffset){
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        	if(newOffset &lt;0){</span>
<span class="nc" id="L260">                throw new IllegalArgumentException(&quot;read can not have negative offset&quot;);</span>
            }
<span class="fc" id="L262">        }</span>
        /**
        * {@inheritDoc}
        */
        @Override
        public long getBegin(){
<span class="fc" id="L268">            return offset;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public String getId(){
<span class="fc" id="L275">            return readId;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public Builder setStartOffset(int newOffset){
<span class="fc" id="L282">        	validateNewOffset(newOffset);</span>
<span class="fc" id="L283">            this.offset = newOffset;</span>
<span class="fc" id="L284">            return this;</span>
        }
        
       
        /**
        * {@inheritDoc}
        */
        @Override
        public Builder shift(int numberOfBases){
<span class="fc" id="L293">            return setStartOffset(offset+numberOfBases);</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public Range getClearRange() {
<span class="fc" id="L300">            return clearRange;</span>
        }


        /**
        * {@inheritDoc}
        */
        @Override
        public Direction getDirection() {
<span class="fc" id="L309">            return dir;</span>
        }

        

        /**
        * {@inheritDoc}
        */
        @Override
        public int getUngappedFullLength() {
<span class="fc" id="L319">            return ungappedFullLength;</span>
        }


        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized AssembledRead build(NucleotideSequence reference){
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        	if(reference == null){</span>
<span class="nc" id="L329">        		throw new IllegalStateException(&quot;reference not set&quot;);</span>
        	}
<span class="fc" id="L331">            ReferenceMappedNucleotideSequence updatedEncodedBasecalls = createFinalBuilder()</span>
<span class="fc" id="L332">            																.setReferenceHint(reference, offset)</span>
<span class="fc" id="L333">            																.buildReferenceEncodedNucleotideSequence();</span>
<span class="fc" id="L334">            return new DefaultAssembledRead(readId, </span>
            		updatedEncodedBasecalls, 
            		offset, dir, 
            		ungappedFullLength,
            		clearRange);
        }

		protected NucleotideSequenceBuilder createFinalBuilder() {
			final NucleotideSequenceBuilder finalBuilder;
        
<span class="fc bfc" id="L344" title="All 2 branches covered.">        	if(originalSequence ==null){</span>
<span class="fc" id="L345">        		finalBuilder = basesBuilder;        		</span>
        	}else{
<span class="fc" id="L347">        		finalBuilder = new NucleotideSequenceBuilder(originalSequence);</span>
        	}
<span class="fc" id="L349">			return finalBuilder;</span>
		}

        /**
        * {@inheritDoc}
        */
         @Override
        public synchronized Builder reAbacus(Range gappedValidRangeToChange, NucleotideSequence newBasecalls){
        	
<span class="fc" id="L358">        	 NucleotideSequence newUngappedBasecalls = new NucleotideSequenceBuilder(newBasecalls)</span>
<span class="fc" id="L359">				.ungap()</span>
<span class="fc" id="L360">				.build();</span>
        	 
<span class="fc" id="L362">            NucleotideSequence oldUngappedBasecalls = getNucleotideSequenceBuilder()</span>
<span class="fc" id="L363">            										.copy()</span>
<span class="fc" id="L364">            										.trim(gappedValidRangeToChange)</span>
<span class="fc" id="L365">            										.ungap()</span>
<span class="fc" id="L366">            										.build();</span>
           
<span class="fc bfc" id="L368" title="All 2 branches covered.">            if(!oldUngappedBasecalls.equals(newUngappedBasecalls)){</span>
<span class="fc" id="L369">                throw new IllegalReAbacus(oldUngappedBasecalls,newUngappedBasecalls);</span>
            }
<span class="fc" id="L371">            basesBuilder.delete(gappedValidRangeToChange);</span>
<span class="fc" id="L372">            basesBuilder.insert((int)gappedValidRangeToChange.getBegin(), newBasecalls);</span>
<span class="fc" id="L373">            return this;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized long getLength(){
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if(basesBuilder !=null){</span>
<span class="fc" id="L381">                return basesBuilder.getLength();</span>
            }
<span class="fc" id="L383">            return originalSequence.getLength();</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public long getEnd(){
<span class="fc" id="L390">            return offset + getLength()-1;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public Range asRange(){
<span class="fc" id="L397">            return Range.of(offset,getEnd());</span>
        }

        private synchronized NucleotideSequenceBuilder getNucleotideSequenceBuilder() {
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if(basesBuilder==null){</span>
<span class="fc" id="L402">                this.basesBuilder = new NucleotideSequenceBuilder(originalSequence);</span>
<span class="fc" id="L403">                originalSequence=null;</span>
            }
<span class="fc" id="L405">            return basesBuilder;</span>
        }
        
        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized NucleotideSequence getCurrentNucleotideSequence(){
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if(originalSequence !=null){</span>
<span class="fc" id="L414">                return originalSequence;</span>
            }
<span class="fc" id="L416">            return basesBuilder.build();</span>
        }
       

        @Override
		public Builder append(Nucleotide base) {
<span class="nc" id="L422">        	getNucleotideSequenceBuilder().append(base);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        	if(base !=Nucleotide.Gap){</span>
<span class="nc" id="L424">        		expandValidRangeEnd(1);</span>
<span class="nc" id="L425">        		ungappedFullLength++;</span>
        	}
<span class="nc" id="L427">			return this;</span>
		}


		@Override
		public Builder append(Iterable&lt;Nucleotide&gt; sequence) {
<span class="fc" id="L433">			NucleotideSequenceBuilder validRangeBuilder =getNucleotideSequenceBuilder();</span>
			//have to get old and new length 
			//because we don't know how long iterable is
			//(there's no size method on iterable)
<span class="fc" id="L437">			long oldLength = validRangeBuilder.getUngappedLength();</span>
<span class="fc" id="L438">			validRangeBuilder.append(sequence);</span>
<span class="fc" id="L439">			long newLength = validRangeBuilder.getUngappedLength();</span>
<span class="fc" id="L440">			long numberUngappedBasesAdded = newLength-oldLength;</span>
			//expand valid range end by length of insert
<span class="fc" id="L442">			expandValidRangeEnd(numberUngappedBasesAdded);</span>
			//update ungapped full length accordingly
<span class="fc" id="L444">			ungappedFullLength+=numberUngappedBasesAdded;</span>
<span class="fc" id="L445">			return this;</span>
		}


		@Override
		public Builder append(String sequence) {
<span class="fc" id="L451">			return append(new NucleotideSequenceBuilder(sequence));</span>
		}


		@Override
		public Builder insert(int offset, String sequence) {
<span class="fc" id="L457">			return insert(offset, new NucleotideSequenceBuilder(sequence));</span>
		}


		@Override
		public AssembledReadBuilder&lt;AssembledRead&gt; trim(Range trimRange) {
<span class="fc" id="L463">			NucleotideSequence untrimmed = getCurrentNucleotideSequence();</span>
<span class="fc" id="L464">			int nonGapStart = AssemblyUtil.getRightFlankingNonGapIndex(untrimmed, (int)trimRange.getBegin());</span>
			
<span class="fc" id="L466">			int nonGapEnd =AssemblyUtil.getLeftFlankingNonGapIndex(untrimmed, (int)trimRange.getEnd());</span>
<span class="fc" id="L467">			int numLeft =untrimmed.getUngappedOffsetFor(nonGapStart);</span>
<span class="fc" id="L468">			int numRight =(int)(untrimmed.getUngappedLength()-1  -untrimmed.getUngappedOffsetFor(nonGapEnd));</span>
			
			
			//for now we are actually trimming the sequence
			//but future versions will only update
			//valid range when we start tracking
			//the full sequence...
<span class="fc" id="L475">			getNucleotideSequenceBuilder()</span>
<span class="fc" id="L476">				.trim(trimRange);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">			if(dir == Direction.FORWARD){</span>
<span class="fc" id="L478">				this.contractValidRangeBegin(numLeft);</span>
<span class="fc" id="L479">				this.contractValidRangeEnd(numRight);</span>
			}else{
<span class="fc" id="L481">				this.contractValidRangeBegin(numRight);</span>
<span class="fc" id="L482">				this.contractValidRangeEnd(numLeft);</span>
			}
			//shift this sequence the number of bases up
			//from its old start
<span class="fc" id="L486">			this.shift((int)trimRange.getBegin());</span>
<span class="fc" id="L487">			return this;</span>
		}

		@Override
		public Builder replace(int offset, Nucleotide replacement) {
			
<span class="fc" id="L493">			NucleotideSequenceBuilder sequenceBuilder = getNucleotideSequenceBuilder();</span>
<span class="fc" id="L494">			long oldLength = sequenceBuilder.getUngappedLength();</span>
<span class="fc" id="L495">			sequenceBuilder.replace(offset, replacement);</span>
<span class="fc" id="L496">			long newLength = sequenceBuilder.getUngappedLength();</span>
			//have to modify valid range
			//if number of gaps has changed
<span class="fc bfc" id="L499" title="All 2 branches covered.">			if(newLength &lt; oldLength){</span>
				//we replaced a nongap with a gap
<span class="fc" id="L501">				ungappedFullLength--;				</span>
<span class="fc" id="L502">				contractValidRangeEnd(1);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">			}else if(newLength &gt; oldLength){</span>
<span class="nc" id="L504">				ungappedFullLength++;</span>
<span class="nc" id="L505">				expandValidRangeEnd(1);</span>
			}
<span class="fc" id="L507">			return this;</span>
		}


		@Override
		public Builder delete(Range range) {
<span class="fc" id="L513">			NucleotideSequenceBuilder sequenceBuilder = getNucleotideSequenceBuilder();</span>
<span class="fc" id="L514">			long oldUngappedLength = sequenceBuilder.getUngappedLength();</span>
<span class="fc" id="L515">			sequenceBuilder.delete(range);</span>
<span class="fc" id="L516">			long newUngappedLength = sequenceBuilder.getUngappedLength();</span>
<span class="fc" id="L517">			long numberOfUngappedBasesDeleted = oldUngappedLength -newUngappedLength;</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">			if(numberOfUngappedBasesDeleted&gt;0){</span>
				//we only ever contract the end of the valid
				//range since the good part always starts
				//at the same place									
<span class="fc" id="L522">				contractValidRangeEnd(numberOfUngappedBasesDeleted);</span>
				//update ungapped full length accordingly
<span class="fc" id="L524">				ungappedFullLength-=numberOfUngappedBasesDeleted;</span>
			}
<span class="fc" id="L526">			return this;</span>
		}


		@Override
		public int getNumGaps() {
<span class="nc" id="L532">			return getNucleotideSequenceBuilder()</span>
<span class="nc" id="L533">					.getNumGaps();</span>
		}


		@Override
		public int getNumNs() {
<span class="nc" id="L539">			return getNucleotideSequenceBuilder()</span>
<span class="nc" id="L540">					.getNumNs();</span>
		}


		@Override
		public int getNumAmbiguities() {
<span class="nc" id="L546">			return getNucleotideSequenceBuilder()</span>
<span class="nc" id="L547">						.getNumAmbiguities();</span>
		}


		@Override
		public Builder prepend(String sequence) {
<span class="fc" id="L553">			return prepend(new NucleotideSequenceBuilder(sequence));</span>
		}


		@Override
		public Builder insert(int offset,
				Iterable&lt;Nucleotide&gt; sequence) {
<span class="fc" id="L560">			NucleotideSequenceBuilder validRangeBuilder =getNucleotideSequenceBuilder();</span>
			//have to get old and new length 
			//because we don't know how long iterable is
			//(there's no size method on iterable)
<span class="fc" id="L564">			long oldLength = validRangeBuilder.getUngappedLength();</span>
<span class="fc" id="L565">			validRangeBuilder.insert(offset, sequence);</span>
<span class="fc" id="L566">			long newLength = validRangeBuilder.getUngappedLength();</span>
<span class="fc" id="L567">			long numberOfNonGapsAdded = newLength-oldLength;</span>
			//expand valid range end by length of insert
<span class="fc" id="L569">			expandValidRangeEnd(numberOfNonGapsAdded);</span>
			
<span class="fc" id="L571">			ungappedFullLength+=numberOfNonGapsAdded;</span>
<span class="fc" id="L572">			return this;</span>
		}


		@Override
		public Builder insert(int offset, Nucleotide base) {
<span class="fc" id="L578">			NucleotideSequenceBuilder validRangeBuilder =getNucleotideSequenceBuilder();</span>
<span class="fc" id="L579">			validRangeBuilder.insert(offset, base);</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">			if(base !=Nucleotide.Gap){</span>
				//expand valid range end by 1 to include added base
<span class="nc" id="L582">				expandValidRangeEnd(1);</span>
<span class="nc" id="L583">				ungappedFullLength++;</span>
			}
<span class="fc" id="L585">			return this;</span>
		}


		@Override
		public Builder prepend(Iterable&lt;Nucleotide&gt; sequence) {
<span class="fc" id="L591">			return insert(0, sequence);</span>
		}

		

		private Builder expandValidRangeEnd(long units) {
<span class="fc" id="L597">			Range updatedClearRange = new Range.Builder(clearRange)</span>
<span class="fc" id="L598">											.expandEnd(units)</span>
<span class="fc" id="L599">											.build();</span>
<span class="fc" id="L600">			clearRange =updatedClearRange;</span>
<span class="fc" id="L601">			return this;</span>
		}

		private Builder contractValidRangeBegin(long units) {
<span class="fc" id="L605">			Range updatedClearRange = new Range.Builder(clearRange)</span>
<span class="fc" id="L606">											.contractBegin(units)</span>
<span class="fc" id="L607">											.build();</span>
<span class="fc" id="L608">			clearRange =updatedClearRange;</span>
<span class="fc" id="L609">			return this;</span>
		}

		private Builder contractValidRangeEnd(long units) {
<span class="fc" id="L613">			Range updatedClearRange = new Range.Builder(clearRange)</span>
<span class="fc" id="L614">											.contractEnd(units)</span>
<span class="fc" id="L615">											.build();</span>
<span class="fc" id="L616">			clearRange =updatedClearRange;</span>
<span class="fc" id="L617">			return this;</span>
		}


        
        /**
        * {@inheritDoc}
        */
        @Override
        public int hashCode() {
<span class="nc" id="L627">            final int prime = 31;</span>
<span class="nc" id="L628">            int result = 1;           </span>
<span class="nc" id="L629">            result = prime * result + readId.hashCode();</span>
<span class="nc" id="L630">            result = prime * result +  dir.hashCode();</span>
<span class="nc" id="L631">            return result;</span>
        }


        /**
        * {@inheritDoc}
        */
        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L641">                return true;</span>
            }
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L644">                return false;</span>
            }
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">            if (!(obj instanceof Builder)) {</span>
<span class="nc" id="L647">                return false;</span>
            }
<span class="fc" id="L649">            Builder other = (Builder) obj;</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">            if (!readId.equals(other.readId)) {</span>
<span class="fc" id="L651">                return false;</span>
            }
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (!dir.equals(other.dir)) {</span>
<span class="nc" id="L654">                return false;</span>
            }
            
<span class="nc" id="L657">            return true;</span>
        }


		
        
        
        
    }

    protected static final class IllegalReAbacus extends IllegalArgumentException{

        private static final long serialVersionUID = -8272559886165301526L;

        public IllegalReAbacus(NucleotideSequence  oldUngappedBasecalls, NucleotideSequence newUngappedBasecalls){
<span class="fc" id="L672">            super(String.format(&quot;reAbacusing must retain same ungapped basecalls! '%s' vs '%s'&quot;, </span>
                   oldUngappedBasecalls,
                    newUngappedBasecalls
                    ));
<span class="fc" id="L676">        }</span>
    
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>