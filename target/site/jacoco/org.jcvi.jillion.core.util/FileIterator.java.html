<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FileIterator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.util</a> &gt; <span class="el_source">FileIterator.java</span></div><h1>FileIterator.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Aug 6, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.util;

import java.io.File;
import java.io.FileFilter;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Queue;

import org.jcvi.jillion.core.util.iter.ArrayIterator;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.internal.core.util.FIFOQueue;
import org.jcvi.jillion.internal.core.util.LIFOQueue;

/**
 * {@code FileIterator} is an {@link Iterator} for File objects.
 * @author dkatzel
 *
 *
 */
public abstract class FileIterator implements Iterator&lt;File&gt;, Iterable&lt;File&gt;{
	
<span class="fc" id="L52">	private static final FileFilter  NON_DIRECTORY_FILTER = new NonDirectoryFileFilter();</span>
<span class="fc" id="L53">    private static final FileFilter  NON_HIDDEN_FILTER = new NonHiddenFileFilter();</span>
<span class="fc" id="L54">    private static final FileFilter  NULL_FILTER = new NullFileFilter();</span>
<span class="fc" id="L55">    private static final FileNameComparator FILE_NAME_SORTER = new FileNameComparator();</span>
    
   
    private Iterator&lt;File&gt; fileIterator;
    private final FileFilter fileFilter;
    private File nextFile;
    private final File rootDir;
    
    /**
     * Create a new {@link FileIteratorBuilder} instance that will create
     * a file iterator that will recursively iterate files in a depth
     * first manner. 
     * @param rootDir the root directory to start iterating from.
     * @return a new FileIteratorBuilder instance (will never be null)
     */
    public static FileIteratorBuilder createDepthFirstFileIteratorBuilder(File rootDir){
<span class="fc" id="L71">        return new DepthFirstFileIteratorBuilder(rootDir);</span>
    }
    /**
     * Create a new {@link FileIteratorBuilder} instance that will create
     * a file iterator that will recursively iterate files in a breadth
     * first manner. 
     * @param rootDir the root directory to start iterating from.
     * @return a new FileIteratorBuilder instance (will never be null)
     */
    public static FileIteratorBuilder createBreadthFirstFileIteratorBuilder(File rootDir){
<span class="fc" id="L81">        return new BreadthFirstFileIteratorBuilder(rootDir);</span>
    }
    /**
     * Create a new {@link FileIteratorBuilder} instance that will create
     * a file iterator that will only iterate files in the given directory
     * @param dir the directory iterate.
     * @return a new FileIteratorBuilder instance (will never be null)
     */
    public static FileIteratorBuilder createNonRecursiveFileIteratorBuilder(File dir){
<span class="fc" id="L90">        return new NonRecursiveFileIteratorBuilder(dir);</span>
    }
<span class="fc" id="L92">    private static final class FileNameComparator implements Comparator&lt;File&gt;, Serializable {</span>
		/**
         * 
         */
        private static final long serialVersionUID = 4585888483429023724L;

        @Override
		public int compare(File o1, File o2) {
<span class="fc" id="L100">		    return o1.getName().compareTo(o2.getName());</span>
		}
	}
	/**
     * A FileFilter that only accepts files that are not 
     * directories.
     * @author dkatzel
     */
<span class="fc" id="L108">    private static final class NonDirectoryFileFilter implements FileFilter {</span>
        @Override
        public boolean accept(File file) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">            return !file.isDirectory();</span>
        }
    }
<span class="fc" id="L114">    private static final class NonHiddenFileFilter implements FileFilter {</span>
        @Override
        public boolean accept(File file) {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            return !file.isHidden();</span>
        }
    }
<span class="fc" id="L120">    private static final class NullFileFilter implements FileFilter {</span>
        @Override
        public boolean accept(File file) {
<span class="nc" id="L123">            return true;</span>
        }
    }
    

<span class="fc" id="L128">    private FileIterator(File rootDir,FileFilter fileFilter){</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if(rootDir ==null){</span>
<span class="nc" id="L130">            throw new NullPointerException(&quot;rootDir can not be null&quot;);</span>
        }
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if(!rootDir.isDirectory()){</span>
<span class="nc" id="L133">            throw new IllegalArgumentException(&quot;rootDir must be a directory&quot;);</span>
        }
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if(fileFilter ==null){</span>
<span class="nc" id="L136">            throw new NullPointerException(&quot;fileFilter can not be null&quot;);</span>
        }
<span class="fc" id="L138">        this.fileFilter = fileFilter;</span>
<span class="fc" id="L139">        this.rootDir = rootDir;</span>
<span class="fc" id="L140">        setUpInitialState(rootDir);</span>
        
<span class="fc" id="L142">    }</span>
    protected void setUpInitialState(File rootDir){
<span class="fc" id="L144">        updateFileIterator(rootDir);</span>
<span class="fc" id="L145">        nextFile = getNextFile();</span>
<span class="fc" id="L146">    }</span>
    protected void updateFileIterator(File rootDir) {
<span class="fc" id="L148">        fileIterator = getFilesFor(rootDir);</span>
<span class="fc" id="L149">    }</span>
    
    private Iterator&lt;File&gt; getFilesFor(File dir){
<span class="fc" id="L152">        final File[] listFiles = dir.listFiles(fileFilter);</span>
       
       
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if(listFiles ==null){</span>
            //either no files or no files we have permission to see
<span class="nc" id="L157">            return IteratorUtil.createEmptyIterator();</span>
        }
        //sort files by name this makes
        //iterating deterministic
<span class="fc" id="L161">        Arrays.sort(listFiles, FILE_NAME_SORTER);</span>
<span class="fc" id="L162">        return new ArrayIterator&lt;&gt;(listFiles, false);</span>
    }
    /**
     * Returns a new iterator with the same
     * parameters as this.
     */
    @Override
    public Iterator&lt;File&gt; iterator() {
<span class="nc" id="L170">        return createNewInstance(this.rootDir, fileFilter);</span>
    }
    
    protected abstract Iterator&lt;File&gt; createNewInstance(File root, FileFilter fileFilter);
    protected File getNextFile(){
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if(fileIterator.hasNext()){</span>
<span class="fc" id="L176">            return fileIterator.next();</span>
        }        
<span class="fc" id="L178">        return null;        </span>
    }

   
    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        return nextFile !=null;</span>
    }

    @Override
    public File next() {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if(!hasNext()){</span>
<span class="fc" id="L190">            throw new NoSuchElementException(&quot;no more files&quot;);</span>
        }
<span class="fc" id="L192">        File fileToReturn = nextFile;</span>
<span class="fc" id="L193">        nextFile = getNextFile();</span>
<span class="fc" id="L194">        return fileToReturn;</span>
    }

    @Override
    public void remove() {
<span class="fc" id="L199">        throw new UnsupportedOperationException(&quot;can not remove&quot;);</span>
    }
    private static class NonRecursiveFileIterator extends FileIterator{

        protected NonRecursiveFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="fc" id="L205">            super(rootDir, fileFilter);</span>
<span class="fc" id="L206">        }</span>

        @Override
        protected Iterator&lt;File&gt; createNewInstance(File root,
                FileFilter fileFilter) {
<span class="nc" id="L211">            return new NonRecursiveFileIterator(root, fileFilter);</span>
        }
        
    }
    /**
     * RecursiveFileIterator adds recursive abilities to FileIterator.
     * @author dkatzel
     *
     *
     */
    private abstract static class RecursiveFileIterator extends FileIterator{
    	
<span class="fc" id="L223">    	 private static final DirectoryFileFilter  DIRECTORY_FILTER = new DirectoryFileFilter();</span>
         
         private Queue&lt;File&gt; dirIterator;
         
        /**
         * A FileFilter that only accepts files that ARE 
         * directories.
         * @author dkatzel
         */
<span class="fc" id="L232">        private static final class DirectoryFileFilter implements FileFilter {</span>
            @Override
            public boolean accept(File file) {
<span class="fc" id="L235">                return file.isDirectory();</span>
            }
        }
        
       
        protected RecursiveFileIterator(File rootDir,FileFilter fileFilter) {
<span class="fc" id="L241">            super(rootDir,fileFilter);</span>
<span class="fc" id="L242">        }</span>
        
        /**
         * Create an empty Queue of Files
         * that will be used to track the directories
         * to recursively iterate over.  The implementation
         * of the Queue returned will determine the order
         * the directories will be iterated.
         * @return a new empty Queue.
         */
        protected abstract Queue&lt;File&gt; createDirectoryIterator();
        
        private List&lt;File&gt; getSubdirectoriesFor(File dir){            
<span class="fc" id="L255">            final File[] listFiles = dir.listFiles(DIRECTORY_FILTER);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">            if(listFiles ==null){</span>
                //either no files or no files we have permission to see
<span class="nc" id="L258">                return Collections.emptyList();</span>
            }
<span class="fc" id="L260">            Arrays.sort(listFiles,FILE_NAME_SORTER);</span>
<span class="fc" id="L261">            return Arrays.asList(listFiles);</span>
            
        }
        @Override
        protected void setUpInitialState(File rootDir) {
<span class="fc" id="L266">            dirIterator = createDirectoryIterator();</span>
<span class="fc" id="L267">            dirIterator.addAll(getSubdirectoriesFor(rootDir));</span>
<span class="fc" id="L268">            super.setUpInitialState(rootDir);</span>
<span class="fc" id="L269">        }</span>
        @Override
        protected File getNextFile() {
<span class="fc" id="L272">            File nextFile = super.getNextFile();</span>
<span class="fc bfc" id="L273" title="All 4 branches covered.">            if(nextFile ==null &amp;&amp; hasMoreSubDirs()){            </span>
<span class="fc" id="L274">                return getNextFromSubDir();</span>
            }
            
<span class="fc" id="L277">            return nextFile;</span>
        }
        private boolean hasMoreSubDirs() {
<span class="fc bfc" id="L280" title="All 2 branches covered.">            return !dirIterator.isEmpty();</span>
        }

        private File getNextFromSubDir() {
<span class="fc" id="L284">            File newDir = dirIterator.poll();</span>
<span class="fc" id="L285">            updateFileIterator(newDir);</span>
<span class="fc" id="L286">            dirIterator.addAll(getSubdirectoriesFor(newDir));</span>
<span class="fc" id="L287">            return getNextFile();</span>
        }
        
    }
    private static class DepthFirstFileIterator extends RecursiveFileIterator{

        public DepthFirstFileIterator(File rootDir,FileFilter fileFilter) {
<span class="fc" id="L294">            super(rootDir,fileFilter);           </span>
<span class="fc" id="L295">        }</span>

        
        @Override
        protected Queue&lt;File&gt; createDirectoryIterator() {
<span class="fc" id="L300">            return new LIFOQueue&lt;File&gt;();</span>
        }


        @Override
        protected Iterator&lt;File&gt; createNewInstance(File root,
                FileFilter fileFilter) {
<span class="nc" id="L307">            return new DepthFirstFileIterator(root, fileFilter);</span>
        } 
    }
    private static class BreadthFirstFileIterator extends RecursiveFileIterator{

        public BreadthFirstFileIterator(File rootDir,FileFilter fileFilter) {
<span class="fc" id="L313">            super(rootDir,fileFilter);           </span>
<span class="fc" id="L314">        }</span>

        

        @Override
        protected Queue&lt;File&gt; createDirectoryIterator() {
<span class="fc" id="L320">            return new FIFOQueue&lt;File&gt;();</span>
        }  
        @Override
        protected Iterator&lt;File&gt; createNewInstance(File root,
                FileFilter fileFilter) {
<span class="nc" id="L325">            return new BreadthFirstFileIterator(root, fileFilter);</span>
        } 
    }
    
    /**
     * {@code FileIteratorBuilder} is used to build a new instance of a 
     * {@link FileIterator}.
     * @author dkatzel
     *
     *
     */
    public abstract static class FileIteratorBuilder implements Builder&lt;FileIterator&gt;{
        
<span class="fc" id="L338">        private boolean includeDirectories=false;</span>
<span class="fc" id="L339">        private boolean includeHiddenFiles=false;</span>
<span class="fc" id="L340">        private FileFilter userDefinedFileFilter=null;</span>
        private final File rootDir;
        
<span class="fc" id="L343">        public FileIteratorBuilder(File rootdir){</span>
<span class="fc" id="L344">            this.rootDir = rootdir;</span>
<span class="fc" id="L345">        }</span>
        /**
         * Should the iterator include the actual subdirectory directory files
         * during iteration.  Defaults to {@code false} if this method is not set.
         * &lt;p&gt;For Example:&lt;/p&gt;
         * If the File Directory structure looks like this:
         * &lt;pre&gt;
         * +root
         *  | file1
         *  | file2
         *  +subdir
         *    | file3
         * &lt;/pre&gt;
         * If this iterator is NOT recursive and if includeDirectories is
         * set to {@code true}, {@code file1}, {@code file2} and the file object
         * that represents {@code subdir} will be iterated over. If the iterator
         * is NOT recursive and if includeDirectories is set to {@code false}
         * then only {@code file1} and {@code file2} will be iterated over.
         * &lt;p&gt;
         * If this iterator IS recursive and if includeDirectories is
         * set to {@code true}, then {@code file1}, {@code file2} and the file object
         * that represents {@code subdir} and {@code file3} will be iterated over. 
         * 
         * If the iterator
         * IS recursive and if includeDirectories is set to {@code false}
         * then only {@code file1}, {@code file2} and {@code file3} will be iterated over.
         * 
         * @param includeDirectories should the iterator include 
         * the actual subdirectory directory files.
         * during iteration.
         * @return this.
         */
        public FileIteratorBuilder includeDirectories(boolean includeDirectories){
<span class="fc" id="L378">            this.includeDirectories = includeDirectories;</span>
<span class="fc" id="L379">            return this;</span>
        }
        /**
         * Should hidden files be included in the file iteration. 
         * Defaults to {@code false} if this method is not set.
         * @param includeHiddenFiles {@code true} if hidden files should be included;
         * {@code false} otherwise.
         * @return this.
         */
        public FileIteratorBuilder includeHiddenFiles(boolean includeHiddenFiles){
<span class="nc" id="L389">            this.includeHiddenFiles = includeHiddenFiles;</span>
<span class="nc" id="L390">            return this;</span>
        }
        /**
         * Add additional constraints to the fileIterator by specifying 
         * a {@link FileFilter} that will be used to further restrict what
         * files to iterate.  The given Filter (if any) is applied after
         * the constraints set by {@link #includeDirectories(boolean)}
         * and {@link #includeHiddenFiles(boolean)}.
         * @param fileFilter a {@link FileFilter} instance to further
         * filter the files to iterate; passing in {@code null}
         * means do not do any additional filtering.
         * @return this.
         */
        public FileIteratorBuilder fileFilter(FileFilter fileFilter){
<span class="fc" id="L404">            this.userDefinedFileFilter = fileFilter;</span>
<span class="fc" id="L405">            return this;</span>
        }
        protected abstract FileIterator createFileIterator(File rootDir, FileFilter fileFilter);
        /**
         * Constructs a new FileIterator using the options set so far.
         * @return a new FileIterator (never null).
         */
        public FileIterator build(){
            FileFilter fileFilter;
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if(includeHiddenFiles){</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                if(includeDirectories){</span>
<span class="nc" id="L416">                    fileFilter = NULL_FILTER;</span>
                }else{
<span class="nc" id="L418">                    fileFilter = NON_DIRECTORY_FILTER;</span>
                }
            }else{
<span class="fc bfc" id="L421" title="All 2 branches covered.">                if(includeDirectories){</span>
<span class="fc" id="L422">                    fileFilter =NON_HIDDEN_FILTER;</span>
                }else{
<span class="fc" id="L424">                    fileFilter =new MultipleFileFilter(</span>
<span class="fc" id="L425">                            NON_DIRECTORY_FILTER,NON_HIDDEN_FILTER);</span>
                    
                }
            }
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if(userDefinedFileFilter !=null){</span>
<span class="fc" id="L430">                fileFilter = new MultipleFileFilter(fileFilter, userDefinedFileFilter);</span>
            }
<span class="fc" id="L432">            return createFileIterator(rootDir, fileFilter);</span>
        }
    }
    
    private static final class BreadthFirstFileIteratorBuilder extends FileIteratorBuilder{
        
        public BreadthFirstFileIteratorBuilder(File rootdir) {
<span class="fc" id="L439">            super(rootdir);</span>
<span class="fc" id="L440">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        protected FileIterator createFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="fc" id="L448">            return new BreadthFirstFileIterator(rootDir, fileFilter);</span>
        }
        
    }
    private static final class DepthFirstFileIteratorBuilder extends FileIteratorBuilder{
       
        public DepthFirstFileIteratorBuilder(File rootdir) {
<span class="fc" id="L455">            super(rootdir);</span>
<span class="fc" id="L456">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        protected FileIterator createFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="fc" id="L464">            return new DepthFirstFileIterator(rootDir, fileFilter);</span>
        }
        
    }
    
    private static final class NonRecursiveFileIteratorBuilder extends FileIteratorBuilder{
        
        public NonRecursiveFileIteratorBuilder(File rootdir) {
<span class="fc" id="L472">            super(rootdir);</span>
<span class="fc" id="L473">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        protected FileIterator createFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="fc" id="L481">            return new NonRecursiveFileIterator(rootDir, fileFilter);</span>
        }
        
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>