<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JoinedStringBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.util</a> &gt; <span class="el_source">JoinedStringBuilder.java</span></div><h1>JoinedStringBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core.util;

import java.util.Arrays;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.Function;

/**
 * {@code JoinedStringBuilder}
 * is a Builder that builds a single String
 * object from a collection of Objects
 * that can optionally be concatenated with 
 * another &quot;glue&quot; Object and/or prefixed and suffixed
 * with other Objects. Objects
 * to be joined use their {@link Object#toString()}
 * method to get their String representation.
 * unless otherwise told to transform it differently 
 * using the {@link #transform(Function)}.
 * 
 * &lt;br/&gt;
 * &lt;strong&gt;This class is not thread-safe.&lt;/strong&gt;
 * @author dkatzel
 *
 *
 */
public final class JoinedStringBuilder&lt;T&gt; implements Builder&lt;String&gt;{
    private final Iterable&lt;T&gt; elements;
    private Object glue;
    private Object prefix;
    private Object suffix;
<span class="fc" id="L51">    private boolean includeEmptyStrings=false;</span>
    /**
     * Default transformation function, defaults to toString().
     */
<span class="fc" id="L55">    private Function&lt;T, String&gt; valueTransformer = Object::toString;</span>
    
    /**
     * Create a new {@link JoinedStringBuilder} instance
     * that will join the given elements together
     * in their iteration order.
     * @param elements the Objects to be joined.
     * If an element is null, then it will be skipped
     * during the join.
     * @param &lt;T&gt; The type of object being joined.
     */
    public static &lt;T&gt; JoinedStringBuilder&lt;T&gt; create(Iterable&lt;T&gt; elements){
<span class="fc" id="L67">    	return new JoinedStringBuilder&lt;T&gt;(elements);</span>
    }
    /**
     * Create a new {@link JoinedStringBuilder} instance
     * that will join the given elements together
     * in their iteration order.
     * @param elements the Objects to be joined.
     * If an element is null, then it will be skipped
     * during the join.
     * @param &lt;T&gt; The type of object being joined.
     * 
     * @return a new JoinedStringBuilder object; will never be null.
     */
    @SafeVarargs
    public static &lt;T&gt; JoinedStringBuilder&lt;T&gt; create(T... elements){
<span class="nc" id="L82">    	return new JoinedStringBuilder&lt;T&gt;(elements);</span>
    }
    
    /**
     * Join the given elements together
     * in their iteration order.
     * @param elements the Objects to be joined.
     * If an element is null, then it will be skipped
     * during the join.
     */
<span class="fc" id="L92">    JoinedStringBuilder(Iterable&lt;T&gt; elements){</span>
<span class="fc" id="L93">        this.elements = elements;</span>
<span class="fc" id="L94">    }</span>
    /**
     * Join the given elements together
     * in their iteration order.
     * @param elements the Objects to be joined.
     * If an element is null, then it will be skipped
     * during the join.
     */
    @SafeVarargs
	JoinedStringBuilder(T... elements){
<span class="fc" id="L104">        this(Arrays.asList(elements));</span>
<span class="fc" id="L105">    }</span>
    /**
     * The given glue's {@link Object#toString()} is what is concatenated
     * between the joined the elements.
     * @param glue the String to put between concatenated
     * elements, if glue is set to {@code null}
     * then no glue will be used.
     * @return this
     */
    public JoinedStringBuilder&lt;T&gt; glue(Object glue){
<span class="fc" id="L115">        this.glue = glue;</span>
<span class="fc" id="L116">        return this;</span>
    }
    /**
     * Prefix the objects to be joined with the given
     * prefix.
     * @param prefix the prefix that will
     * be in the resulting String
     * before the objects are joined;
     * or {@code null} if there should be no prefix.
     * @return this
     */
    public JoinedStringBuilder&lt;T&gt; prefix(Object prefix){
<span class="fc" id="L128">        this.prefix = prefix;</span>
<span class="fc" id="L129">        return this;</span>
    }  
    /**
     * Change the behavior of 
     * how inner empty strings are handled,
     * by default, empty strings will be skipped.
     * @param value  {@code true} if empty string should be included in the
     * final built string; {@code false} otherwise.
     * 
     * @return this
     */
    public JoinedStringBuilder&lt;T&gt; includeEmptyStrings(boolean value){
<span class="fc" id="L141">    	includeEmptyStrings = value;</span>
<span class="fc" id="L142">    	return this;</span>
    }
    /**
     * Suffix the objects to be joined with the given
     * suffix.
     * @param suffix the suffix that will
     * be in the resulting String
     * after the objects are joined;
     * or {@code null} if there should be no suffix.
     * @return this
     */
    public JoinedStringBuilder&lt;T&gt; suffix(Object suffix){
<span class="fc" id="L154">        this.suffix = suffix;</span>
<span class="fc" id="L155">        return this;</span>
    }  
    @Override
    public String toString(){
<span class="nc" id="L159">        return build();</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public String build() {
<span class="fc" id="L166">        final StringBuilder joined = new StringBuilder();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if(prefix!=null){</span>
<span class="fc" id="L168">            joined.append(prefix);</span>
        }
<span class="fc" id="L170">        Iterator&lt;T&gt; iter = elements.iterator();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if(iter.hasNext()){</span>
<span class="fc" id="L172">            T firstElement= iter.next();</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            if(firstElement!=null){</span>
<span class="fc" id="L174">                joined.append(valueTransformer.apply(firstElement));</span>
            }
        }
        
<span class="fc bfc" id="L178" title="All 2 branches covered.">        while(iter.hasNext()){</span>
            
<span class="fc" id="L180">            T item = iter.next();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if (item != null)</span>
            {   
<span class="fc" id="L183">                String itemString = valueTransformer.apply(item);</span>
<span class="pc bpc" id="L184" title="2 of 8 branches missed.">                if (glue != null &amp;&amp; joined.length() &gt; 0 &amp;&amp; (includeEmptyStrings || itemString.length() &gt; 0))</span>
                {
<span class="fc" id="L186">                    joined.append(glue.toString());</span>
                }
<span class="fc" id="L188">                joined.append(itemString);</span>
            }
<span class="fc" id="L190">        }</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if(suffix!=null){</span>
<span class="fc" id="L192">            joined.append(suffix);</span>
        }
<span class="fc" id="L194">        return joined.toString();</span>
    }
    /**
     * Apply the given Transformation function to each value
     * in the elements to join. If this method is not called,
     * then the default transformation just calls each element's
     * toString().
     * @param transformer the transformer to use; can not be null.
     * @return this.
     */
	public JoinedStringBuilder&lt;T&gt; transform(Function&lt;T, String&gt; transformer) {
<span class="fc" id="L205">		Objects.requireNonNull(transformer);</span>
<span class="fc" id="L206">		valueTransformer = transformer;</span>
<span class="fc" id="L207">		return this;</span>
	}
    
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>