<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SffFileParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.sff</a> &gt; <span class="el_source">SffFileParser.java</span></div><h1>SffFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trace.sff;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.atomic.AtomicBoolean;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
import org.jcvi.jillion.trace.sff.SffVisitorCallback.SffVisitorMemento;
/**
 * {@code SffFileParser} can parse an SFF
 * binary encoded
 * flowgram file.
 * @author dkatzel
 * @see &lt;a href =&quot;http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&amp;f=formats&amp;m=doc&amp;s=format#sff&quot;&gt;SFF file format spec from NCBI&lt;/a&gt;
 */
public abstract class SffFileParser implements SffParser{
	
	protected SffCommonHeader header;
	/**
	 * Create a new instance of {@link SffParser}
	 * that will parse the given sff encoded file.
	 * The file isn't actually parsed until
	 * one of the accept methods is called.
	 * @param sffFile the sff file to parse
	 * @throws NullPointerException if sffFile is null.
	 * @throws FileNotFoundException if sffFile does not exist.
	 */
	public static SffParser create(File sffFile) throws FileNotFoundException{
<span class="fc" id="L56">		return new FileBasesSffParser(sffFile);</span>
	}

	/**
	 * Create a new instance of {@link SffParser}
	 * that will parse the given sff encoded {@link InputStream}.
	 * Please Note that inputStream implementations
	 * of the FastaFileParser can not create {@link SffVisitorMemento}s
	 * or use {@link #accept(SffVisitor, SffVisitorMemento)}.
	 * The {@link InputStream} isn't actually parsed until
	 * one of the {@link SffFileParser#accept(SffVisitor)}
	 * is called.
	 * @param inputStream an {@link InputStream} that contains
	 * sff encoded data to be parsed; can not be null.
	 * @throws NullPointerException if sffFile is null.
	 * @throws FileNotFoundException if sffFile does not exist.
	 */
	public static SffParser create(InputStream inputStream) throws FileNotFoundException{
<span class="nc" id="L74">		return new InputStreamBasedSffParser(inputStream);</span>
	}
	
<span class="fc" id="L77">	private SffFileParser(){</span>
		//can not instantiate outside of this class file
<span class="fc" id="L79">	}</span>
		
	
    /**
     * Parse the given {@link InputStream} containing sff encoded
     * data and call the appropriate visitXXX methods on the given visitor.
     * @param in {@link InputStream} containing sff encoded
     * data
     * @param visitor the visitor to visit.
     * @throws SffDecoderException if there is a problem parsing the sff data.
     * @throws NullPointerException if the inputstream or visitor are null.
     */
    protected void accept(InputStream in, SffVisitor visitor) throws IOException{
<span class="fc" id="L92">        DataInputStream dataIn = new DataInputStream(in);</span>

<span class="fc" id="L94">        header =DefaultSFFCommonHeaderDecoder.INSTANCE.decodeHeader(dataIn);</span>
<span class="fc" id="L95">        ParserState parserState = new ParserState();</span>
<span class="fc" id="L96">        visitor.visitHeader(createCommonHeaderCallback(parserState), header);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if(!parserState.keepParsing()){</span>
<span class="fc" id="L98">        	return;</span>
        }
<span class="fc" id="L100">        parseReads(visitor, dataIn, header);</span>
<span class="fc" id="L101">        visitor.end();</span>
        
<span class="fc" id="L103">    }</span>
    
    protected abstract SffVisitorCallback createCommonHeaderCallback(final ParserState parserState);
    
	private  void parseReads(SffVisitor visitor,
			DataInputStream dataIn, SffCommonHeader commonHeader)
			throws IOException {
<span class="fc" id="L110">		final long numberOfReads = commonHeader.getNumberOfReads();</span>
		
<span class="fc" id="L112">		int keyLength = (int)commonHeader.getKeySequence().getLength();</span>
<span class="fc" id="L113">        int size = 31+commonHeader.getNumberOfFlowsPerRead()+ keyLength;</span>
<span class="fc" id="L114">        int padding =SffUtil.caclulatePaddedBytes(size);</span>
<span class="fc" id="L115">        int commonHeaderLength = size+padding;</span>
        
<span class="fc" id="L117">        ParserState parserState  = new ParserState(commonHeaderLength);</span>
<span class="fc bfc" id="L118" title="All 4 branches covered.">		for(int i=0;parserState.keepParsing() &amp;&amp; i&lt;numberOfReads; i++){</span>
<span class="fc" id="L119">			parserState = handleSingleRead(visitor, dataIn, parserState,</span>
					i);
		    
		}
<span class="fc" id="L123">	}</span>

	protected ParserState handleSingleRead(SffVisitor visitor,
			DataInputStream dataIn, ParserState parserState,
			int readCount) throws IOException {
<span class="fc" id="L128">		SffVisitorCallback readHeaderCallback = createReadHeaderCallback(parserState, readCount);</span>
<span class="fc" id="L129">		SffReadHeader readHeader = DefaultSffReadHeaderDecoder.INSTANCE.decodeReadHeader(dataIn);</span>
   
		
		
<span class="fc" id="L133">		SffFileReadVisitor readVisitor = visitor.visitRead(readHeaderCallback, readHeader);</span>
<span class="fc" id="L134">		int unpaddedHeaderLength = 16+readHeader.getId().length();</span>
<span class="fc" id="L135">		int readHeaderPadding = SffUtil.caclulatePaddedBytes(unpaddedHeaderLength);</span>
<span class="fc" id="L136">		int paddedHeaderLength = unpaddedHeaderLength+readHeaderPadding;</span>
<span class="fc" id="L137">		ParserState updatedParserState= parserState.incrementPosition(paddedHeaderLength);</span>
<span class="fc" id="L138">		int numberOfFlowsPerRead = header.getNumberOfFlowsPerRead();</span>
<span class="fc" id="L139">		int readDataLength = SffUtil.getReadDataLength(numberOfFlowsPerRead, readHeader.getNumberOfBases());</span>
<span class="fc" id="L140">		int readDataPadding =SffUtil.caclulatePaddedBytes(readDataLength);</span>
		
<span class="fc bfc" id="L142" title="All 2 branches covered.">		if(readVisitor==null){</span>
			//skip read data	    	
<span class="fc" id="L144">			IOUtil.blockingSkip(dataIn, readDataLength+readDataPadding);		    </span>
		}else{
<span class="fc" id="L146">			final int numberOfBases = readHeader.getNumberOfBases();</span>
<span class="fc" id="L147">			SffReadData readData = DefaultSffReadDataDecoder.INSTANCE.decode(dataIn, numberOfFlowsPerRead, numberOfBases);</span>
<span class="fc" id="L148">			readVisitor.visitReadData(readData);</span>
<span class="fc" id="L149">			readVisitor.visitEnd();</span>
		}
<span class="fc" id="L151">		updatedParserState= updatedParserState.incrementPosition(readDataLength+readDataPadding);</span>
<span class="fc" id="L152">		return updatedParserState;</span>
	}
	
	
	protected abstract SffVisitorCallback createReadHeaderCallback(final ParserState parserState,final int readCount);
	
	
	
	
	private abstract static class AbstractSffFileMemento implements SffVisitorMemento{
		private final long position;

<span class="fc" id="L164">		public AbstractSffFileMemento(long position) {</span>
<span class="fc" id="L165">			this.position = position;</span>
<span class="fc" id="L166">		}</span>

		public long getPosition() {
<span class="fc" id="L169">			return position;</span>
		}
		
		
	}
	
	private static class ReadRecordSffFileMemento extends AbstractSffFileMemento{
		private final int readCount;
		public ReadRecordSffFileMemento(long position, int readCount) {
<span class="fc" id="L178">			super(position);</span>
<span class="fc" id="L179">			this.readCount = readCount;</span>
<span class="fc" id="L180">		}</span>
		
	}
	
	private static class BeginningSffFileMomento extends AbstractSffFileMemento{

		public BeginningSffFileMomento() {
<span class="nc" id="L187">			super(0L);</span>
<span class="nc" id="L188">		}</span>
		
	}
	
	private static class ParserState{
		private final long position;
		//keepParsing is an object instead of a primitive
		//so we can pass around the same reference to each
		//ParserState object at increment call
<span class="fc" id="L197">		private AtomicBoolean keepParsing= new AtomicBoolean(true);</span>
		
		public ParserState(){
<span class="fc" id="L200">			this(0L);</span>
<span class="fc" id="L201">		}</span>
<span class="fc" id="L202">		public ParserState(long initialPosition){</span>
<span class="fc" id="L203">			this.position = initialPosition;</span>
<span class="fc" id="L204">		}</span>
<span class="fc" id="L205">		private ParserState(long position, AtomicBoolean keepParsing) {</span>
<span class="fc" id="L206">			this.position = position;</span>
<span class="fc" id="L207">			this.keepParsing = keepParsing;</span>
<span class="fc" id="L208">		}</span>

		public ParserState incrementPosition(long increment){
<span class="fc" id="L211">			return new ParserState(this.position +increment, keepParsing);</span>
		}
		
		public void stop(){
<span class="fc" id="L215">			keepParsing.set(false);</span>
<span class="fc" id="L216">		}</span>
		
		public boolean keepParsing(){
<span class="fc" id="L219">			return keepParsing.get();</span>
		}
	}
	

	/**
	 * InputStream implementation of sff parser
	 * that can not create mementos
	 * since we won't always be able to &quot;rewind&quot; the stream.
	 * @author dkatzel
	 *
	 */
	private static class InputStreamBasedSffParser extends SffFileParser{
		private final OpenAwareInputStream in;
		
<span class="nc" id="L234">		public InputStreamBasedSffParser(InputStream in) {</span>
<span class="nc" id="L235">			this.in = new OpenAwareInputStream(in);</span>
<span class="nc" id="L236">		}</span>

		@Override
		public void parse(SffVisitor visitor) throws IOException {
<span class="nc bnc" id="L240" title="All 2 branches missed.">			if(!canParse()){</span>
<span class="nc" id="L241">				throw new IllegalStateException(&quot;inputstream is not open&quot;);</span>
			}
<span class="nc" id="L243">			this.accept(in, visitor);			</span>
<span class="nc" id="L244">		}</span>

		@Override
		public boolean canParse() {
<span class="nc" id="L248">			return in.isOpen();</span>
		}

		@Override
		public void parse(SffVisitor visitor, SffVisitorMemento memento)
				throws IOException {
<span class="nc" id="L254">			throw new UnsupportedOperationException(&quot;can not accept mementos when inputStream is provided&quot;);</span>
			
		}

		@Override
		protected SffVisitorCallback createReadHeaderCallback(
				ParserState parserState, int readCount) {
<span class="nc" id="L261">			return createMementolessCallback(parserState);</span>
		}
		
		@Override
		protected SffVisitorCallback createCommonHeaderCallback(
				ParserState parserState) {
<span class="nc" id="L267">			return createMementolessCallback(parserState);</span>
		}

		private SffVisitorCallback createMementolessCallback(final ParserState parserState){
<span class="nc" id="L271">			return new SffVisitorCallback(){</span>

				@Override
				public boolean mementoSupported() {
<span class="nc" id="L275">					return false;</span>
				}

				@Override
				public SffVisitorMemento createMemento() {
<span class="nc" id="L280">					throw new UnsupportedOperationException(&quot;can not create mementos from inputstream&quot;);</span>
				}

				@Override
				public void haltParsing() {
<span class="nc" id="L285">					parserState.stop();				</span>
<span class="nc" id="L286">				}</span>
	    		
	    	};
		}
	}
	
	private static final class FileBasesSffParser extends SffFileParser{
		private final File sffFile;

		/**
		 * Create a new instance of {@link SffFileParser}
		 * that will parse the given sff encoded file.
		 * The file isn't actually parsed until
		 * one of the accept methods is called.
		 * @param sffFile the sff file to parse
		 * @throws NullPointerException if sffFile is null.
		 * @throws FileNotFoundException if sffFile does not exist.
		 */
<span class="fc" id="L304">		private FileBasesSffParser(File sffFile) throws FileNotFoundException{</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">			if(sffFile ==null){</span>
<span class="nc" id="L306">				throw new NullPointerException(&quot;sff file can not be null&quot;);</span>
			}
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">			if(!sffFile.exists()){</span>
<span class="nc" id="L309">				throw new FileNotFoundException(String.format(&quot;sff file %s does not exist&quot;, sffFile.getAbsolutePath()));</span>
			}
<span class="fc" id="L311">			this.sffFile = sffFile;</span>
<span class="fc" id="L312">		}</span>
		
		@Override
		public boolean canParse() {
<span class="nc" id="L316">			return true;</span>
		}

		/**
		 * Visit the sff file (starting from the beginning)
		 * and call the visit methods on the given visitor.
		 * @param visitor the visitor to call the visit methods on.
		 * @throws IOException if there is a problem parsing the file.
		 * @throws NullPointerException if visitor is null.
		 */
		@Override
		public void parse(SffVisitor visitor) throws IOException{
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">			if(visitor==null){</span>
<span class="nc" id="L329">				throw new NullPointerException(&quot;visitor can not be null&quot;);</span>
			}
<span class="fc" id="L331">			InputStream in = null;</span>
			try{
<span class="fc" id="L333">				in = new BufferedInputStream(new FileInputStream(sffFile));</span>
<span class="fc" id="L334">				accept(in, visitor);</span>
			}finally{
<span class="pc" id="L336">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L337">			}</span>
<span class="fc" id="L338">		}</span>
		/**
		 * Visit the sff file starting from the portion
		 * of the file specified by the given {@link SffFileMemento}.
		 * and call the visit methods on the given visitor.
		 * 
		 * @param visitor the visitor to call the visit methods on.
		 * @param memento the {@link SffFileMemento} instance which will
		 * tell the parser where to start parsing.  Only {@link SffFileMemento}s
		 * generated by this parser instance are valid.
		 * @throws IOException if there is a problem parsing the file.
		 * @throws NullPointerException if visitor is null.
		 */
		@Override
		public void parse(SffVisitor visitor, SffVisitorMemento memento) throws IOException{
			
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">			if(!(memento instanceof AbstractSffFileMemento)){</span>
<span class="nc" id="L355">				throw new IllegalArgumentException(&quot;don't know how to handle this memento&quot;);</span>
			}
			//if the header is null,
			//then we haven't yet parsed the file,
			//therefore we don't have a valid memento
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">			if(header ==null){</span>
<span class="nc" id="L361">				throw new IllegalStateException(&quot;parser has not yet been initialized, must call accept(visitor) method first&quot;);</span>
			}
<span class="fc" id="L363">			InputStream in = null;</span>
			try{
				
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">				if(memento instanceof ReadRecordSffFileMemento){</span>
					
<span class="fc" id="L368">					ReadRecordSffFileMemento readRecordSffFileMemento = (ReadRecordSffFileMemento)memento;</span>
<span class="fc" id="L369">					ParserState parserState = new ParserState(readRecordSffFileMemento.getPosition());</span>
<span class="fc" id="L370">					in = new BufferedInputStream(new RandomAccessFileInputStream(sffFile, parserState.position));</span>
<span class="fc" id="L371">					DataInputStream dataIn = new DataInputStream(in);</span>
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">					for(int i=readRecordSffFileMemento.readCount; parserState.keepParsing() &amp;&amp; i&lt;header.getNumberOfReads(); i++){</span>
<span class="fc" id="L373">						parserState = handleSingleRead(visitor, dataIn, parserState,</span>
								i);
					    
					}
<span class="fc" id="L377">				}else{</span>
<span class="nc" id="L378">					in = new BufferedInputStream(new FileInputStream(sffFile));</span>
<span class="nc" id="L379">					accept(in, visitor);</span>
				}
			}finally{
<span class="pc" id="L382">				IOUtil.closeAndIgnoreErrors(in);</span>
<span class="fc" id="L383">			}</span>
<span class="fc" id="L384">		}</span>
		
		@Override
		protected SffVisitorCallback createReadHeaderCallback(final ParserState parserState,final int readCount){
<span class="fc" id="L388">	    	return new SffVisitorCallback(){</span>

				@Override
				public boolean mementoSupported() {
<span class="nc" id="L392">					return true;</span>
				}

				@Override
				public SffVisitorMemento createMemento() {
<span class="fc" id="L397">					return new ReadRecordSffFileMemento(parserState.position, readCount);</span>
				}

				@Override
				public void haltParsing() {
<span class="fc" id="L402">					parserState.stop();				</span>
<span class="fc" id="L403">				}</span>
	    		
	    	};
	    }
		@Override
		protected SffVisitorCallback createCommonHeaderCallback(final ParserState parserState){
<span class="fc" id="L409">	    	return new SffVisitorCallback(){</span>

				@Override
				public boolean mementoSupported() {
<span class="nc" id="L413">					return true;</span>
				}

				@Override
				public SffVisitorMemento createMemento() {
<span class="nc" id="L418">					return new BeginningSffFileMomento();</span>
				}

				@Override
				public void haltParsing() {
<span class="fc" id="L423">					parserState.stop();				</span>
<span class="fc" id="L424">				}</span>
	    		
	    	};
	    }
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>