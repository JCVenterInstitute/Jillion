<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SffUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.sff</a> &gt; <span class="el_source">SffUtil.java</span></div><h1>SffUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Oct 6, 2008
 *
 * @author dkatzel
 */
package org.jcvi.jillion.trace.sff;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.PeekableIterator;

/**
 * Utility class for working with sff
 * encoded data.
 * @author dkatzel
 *
 */
public final class SffUtil {
   /**
     * {@value}
     */
    private static final float ONE_HUNDRED = 100F;
    /**
     * This is the magic number all SFF files
     * must start with to be recognized as sff 
     * binary files.
     */
<span class="fc" id="L56">    static final byte[] SFF_MAGIC_NUMBER = new byte[]{</span>
        0x2E,
        0x73,
        0x66,
        0x66,
        0,
        0,
        0,
        1,
    };
    
    /**
	 * 255 ^ 3 = {@value}.
	 */
	private static final long POW_3 = 16581375;
	/**
	 * 255 ^ 2 = {@value}.
	 */
	private static final long POW_2 = 65025;
	/**
	 * 255 ^ 1 = {@value}.
	 */
	private static final long POW_1 = 255;
    /**
     * Currently SFF only has 1 format code which has a value of &lt;code&gt;1&lt;/code&gt;.
     */
    public static final byte FORMAT_CODE = 1;
    /**
     * If a clip point is not set,
     * then this is the default value
     * for an empty clip specified by the SFF
     * format.
     */
<span class="fc" id="L89">    static final byte[] EMPTY_CLIP_BYTES = new byte[]{0,0,0,0};</span>
    
<span class="fc" id="L91">    private static final Pattern SFFINFO_ENCODED_FLOWGRAM_PATTERN = Pattern.compile(&quot;(\\d+)\\.(\\d+)&quot;);</span>
   
<span class="nc" id="L93">    private SffUtil(){}</span>
   /**
    * Mated Sff reads contain both mate data in the same
    * read with a &quot;linker&quot; sequence in between. 
    * {@code Linkers} contains the common linkers
    * used by 454 machines.
    * @author dkatzel
    *
    *
    */
<span class="pc" id="L103">   public static enum Linkers{</span>
       /**
        * The Linker sequence used by 454 FLX machines.
        */
<span class="fc" id="L107">       FLX(&quot;GTTGGAACCGAAAGGGTTTGAATTCAAACCCTTTCGGTTCCAAC&quot;),</span>
       /**
        * The linker sequence used by Titanium machines.
        */
<span class="fc" id="L111">       TITANIUM(&quot;TCGTATAACTTCGTATAATGTATGCTATACGAAGTTATTACG&quot;)</span>
       ;
       
       private final NucleotideSequence forwardSequence;
       private final NucleotideSequence reverseSequence;

    /**
     * @param sequence
     */
<span class="fc" id="L120">    private Linkers(String sequence) {</span>
<span class="fc" id="L121">    	NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder(sequence);</span>
<span class="fc" id="L122">        this.forwardSequence = builder.build();</span>
<span class="fc" id="L123">        this.reverseSequence = builder.reverseComplement().build();</span>
<span class="fc" id="L124">    }</span>

    public NucleotideSequence getForwardSequence() {
<span class="fc" id="L127">        return forwardSequence;</span>
    }

    public NucleotideSequence getReverseSequence() {
<span class="fc" id="L131">        return reverseSequence;</span>
    }

   
       
       
   }
   /**
    * Parse the byte array whose first 4 bytes
    * contain an encoded 454 sff file index offset
    * for a single read.
    * @param values
    * @return the file offset into the sff file
    * for the read.
    */
   public static long parseSffIndexOffsetValue(byte[] values){
<span class="fc" id="L147">		return IOUtil.toUnsignedByte(values[3]) </span>
<span class="fc" id="L148">				+ POW_1	* IOUtil.toUnsignedByte(values[2]) </span>
<span class="fc" id="L149">				+ POW_2	* IOUtil.toUnsignedByte(values[1])</span>
<span class="fc" id="L150">				+ POW_3	* IOUtil.toUnsignedByte(values[0]);</span>
	}
   
   
   /**
    * Convert a file offset into P encoded 454 sff file index offset
    * for a single read.
    * @param offset the 454 byte offset to convert into a byte array.
    * @return the file offset into the sff file
    * for the read.
    */
   public static byte[] toSffIndexOffsetValue(long offset){
<span class="fc" id="L162">	   long currentOffset = offset;</span>
<span class="fc" id="L163">	   byte[] values = new byte[4];</span>
<span class="fc" id="L164">	   short place4 = (short)(currentOffset / POW_3);</span>
<span class="fc" id="L165">	   values[0] = IOUtil.toSignedByte(place4);</span>
<span class="fc" id="L166">	   currentOffset -= place4 *POW_3;</span>
	   
<span class="fc" id="L168">	   short place3 = (short)(currentOffset / POW_2);</span>
<span class="fc" id="L169">	   values[1] = IOUtil.toSignedByte(place3);</span>
<span class="fc" id="L170">	   currentOffset -= place3 *POW_2;</span>
	   
<span class="fc" id="L172">	   short place2 = (short)(currentOffset / POW_1);</span>
<span class="fc" id="L173">	   values[2] = IOUtil.toSignedByte(place2);</span>
<span class="fc" id="L174">	   currentOffset -= place2*POW_1;</span>
	   
<span class="fc" id="L176">	   values[3] = IOUtil.toSignedByte((short)(currentOffset));</span>

<span class="fc" id="L178">		return values;</span>
	}
   
     public static int caclulatePaddedBytes(int bytesReadInSection){
<span class="fc" id="L182">         final int remainder = bytesReadInSection % 8;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">         if(remainder ==0){</span>
<span class="fc" id="L184">             return 0;</span>
         }
<span class="fc" id="L186">        return 8- remainder;</span>
    }
     /**
      * Convert the given encoded flowgram value 
      * into the intensity value
      * @param encodedValue
      * @return
      */
    public static float convertFlowgramValue(short encodedValue){
<span class="fc" id="L195">         return encodedValue / ONE_HUNDRED;</span>
    }
    public static short parseSffInfoEncodedFlowgram(String sffinfoEncodedFlowgram){
<span class="nc" id="L198">        Matcher matcher = SFFINFO_ENCODED_FLOWGRAM_PATTERN.matcher(sffinfoEncodedFlowgram);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if(matcher.find()){</span>
<span class="nc" id="L200">            return Short.parseShort(matcher.group(1)+ matcher.group(2));</span>
        }
<span class="nc" id="L202">        throw new IllegalArgumentException(&quot;could not parse sffinfo encoded flowgram value &quot;+ sffinfoEncodedFlowgram);</span>
    }
    
   
    public static int getReadDataLength(int numberOfFlows, int numberOfBases) {
<span class="fc" id="L207">        return numberOfFlows * 2 + 3*numberOfBases;</span>
        
    }
    
    public static float getFlowValueFor(SffFlowgram flowgram, int ungappedFullRangeOffset){

<span class="nc" id="L213">        int i=0;</span>
<span class="nc" id="L214">        PeekableIterator&lt;Nucleotide&gt; nucIter = IteratorUtil.createPeekableIterator(flowgram.getNucleotideSequence()</span>
<span class="nc" id="L215">        											.iterator(Range.ofLength(ungappedFullRangeOffset+1)));</span>
        
<span class="nc" id="L217">        int j=0;</span>
<span class="nc" id="L218">        float currentFlowValue=0;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        while( j &lt; ungappedFullRangeOffset){</span>
<span class="nc" id="L220">        	Nucleotide base = nucIter.next();</span>
<span class="nc" id="L221">        	j++;</span>
<span class="nc bnc" id="L222" title="All 4 branches missed.">        	while(nucIter.hasNext() &amp;&amp; base.equals(nucIter.peek())){</span>
<span class="nc" id="L223">        		nucIter.next();</span>
<span class="nc" id="L224">        		j++;</span>
        	}
<span class="nc" id="L226">        	currentFlowValue = flowgram.getCalledFlowValue(i);</span>
<span class="nc" id="L227">        	i++;</span>
        	
<span class="nc" id="L229">        }</span>

<span class="nc" id="L231">        return currentFlowValue;</span>
    }
   
    /**
     * Compute the trim {@link Range} that should be used
     * for this {@link SffFlowgram}.  This method
     * uses the values from both {@link SffFlowgram#getQualityClip()} 
     * and {@link SffFlowgram#getAdapterClip()} using
     * the algorithm described in the sff file format
     * documentation:
     * &lt;pre&gt;
     * (pseudocode)
     * trimRange =   
     *      Range.of(CoordinateSystem.RESIDUE_BASED,
     *           max(1, max(clip_qual_left, clip_adapter_left)),
     *           min( (clip_qual_right == 0 ? number_of_bases : clip_qual_right), (clip_adapter_right == 0 ? number_of_bases : clip_adapter_right) )
     * &lt;/pre&gt;
     * @param flowgram the {@link SffFlowgram} to get the trim range of;
     * can not be null.
     * @return a {@link Range} representing the trimRange to use.
     * @throws NullPointerException if flowgram is null.
     * @see &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&amp;f=formats&amp;m=doc&amp;s=formats#sff&quot;&gt;
     	sff file specification&lt;/a&gt;
     */
    public static Range computeTrimRangeFor(SffFlowgram flowgram){

<span class="fc" id="L257">        return getTrimRangeFor(flowgram.getQualityClip(), flowgram.getAdapterClip(), </span>
<span class="fc" id="L258">        		flowgram.getNucleotideSequence().getLength());</span>
    }
    
	private static Range getTrimRangeFor(Range qualityClip, Range adapterClip,
			long fullSequenceLength) {
		
		
<span class="fc" id="L265">		long firstBaseOfInsert = Math.max(1,</span>
<span class="fc" id="L266">                        Math.max(qualityClip.getBegin(CoordinateSystem.RESIDUE_BASED), </span>
<span class="fc" id="L267">                                adapterClip.getBegin(CoordinateSystem.RESIDUE_BASED)));</span>
<span class="fc" id="L268">        long lastBaseOfInsert = Math.min(</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                qualityClip.getEnd(CoordinateSystem.RESIDUE_BASED)==0?fullSequenceLength:qualityClip.getEnd(CoordinateSystem.RESIDUE_BASED), </span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">                        adapterClip.getEnd(CoordinateSystem.RESIDUE_BASED)==0?fullSequenceLength:adapterClip.getEnd(CoordinateSystem.RESIDUE_BASED));</span>
        
		//return qualityClip.intersection(adapterClip);
<span class="fc" id="L273">        return Range.of(CoordinateSystem.RESIDUE_BASED, firstBaseOfInsert, lastBaseOfInsert);</span>
	}
	 /**
     * Compute the trim {@link Range} that should be used
     * for this {@link SffReadHeader}.  This method
     * uses the values from both {@link SffReadHeader#getQualityClip()} 
     * and {@link SffReadHeader#getAdapterClip()} using
     * the algorithm described in the sff file format
     * documentation:
     * &lt;pre&gt;
     * (pseudocode)
     * trimRange =   
     *      Range.of(CoordinateSystem.RESIDUE_BASED,
     *           max(1, max(clip_qual_left, clip_adapter_left)),
     *           min( (clip_qual_right == 0 ? number_of_bases : clip_qual_right), (clip_adapter_right == 0 ? number_of_bases : clip_adapter_right) )
     * &lt;/pre&gt;
     * @param readHeader the {@link SffReadHeader} to get the trim range of;
     * can not be null.
     * @return a {@link Range} representing the trimRange to use.
     * @throws NullPointerException if readHeader is null.
     * @see &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&amp;f=formats&amp;m=doc&amp;s=formats#sff&quot;&gt;
     	sff file specification&lt;/a&gt;
     */
    public static Range computeTrimRangeFor(SffReadHeader readHeader){

<span class="nc" id="L298">        return getTrimRangeFor(readHeader.getQualityClip(), </span>
<span class="nc" id="L299">        						readHeader.getAdapterClip(), </span>
<span class="nc" id="L300">    							readHeader.getNumberOfBases());</span>
    }
    
    
    
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>