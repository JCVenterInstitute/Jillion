<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Sff454NameUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.sff</a> &gt; <span class="el_source">Sff454NameUtil.java</span></div><h1>Sff454NameUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trace.sff;

import java.math.BigInteger;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.internal.core.util.Validator;

/**
 * 454 Universal Accession Numbers are generated for each read based on the date
 * of the run, the machine name, the region the read came from and X-Y location
 * of the well.  The format is described in The FLX Data Analysis Software Manual
 * in section 13.3.7 454 Universal Accession Numbers.
 * @author dkatzel
 *
 *
 */
public final class Sff454NameUtil {
    /**
     * All 454 Universal Accession numbers follow the same 14 character format.  Some tools may add
     * suffixes to the accession number to include mate pair information.
     */
<span class="fc" id="L50">    private static final Pattern UNIVERSAL_ACCCESSION_NUM_PATTERN = Pattern.compile(&quot;^([A-Z0-9]{7}\\d\\d[A-Z0-9]{5})\\S*$&quot;);</span>
    
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">    private static final Predicate&lt;String&gt; STRING_NOT_EMPTY = (s)-&gt; !s.isEmpty();</span>
    
<span class="nc" id="L54">    private Sff454NameUtil(){</span>
        //can not instantiate
<span class="nc" id="L56">    }</span>
    /**
     * Is the given read id a 454 read.
     * @param readId the read id to check.
     * @return {@code true} if the readId is a single word
     * that starts with a valid
     * 454 universal accession number; {@code false} otherwise.
     */
    public static boolean is454Read(String readId){        
<span class="fc" id="L65">        Matcher matcher = UNIVERSAL_ACCCESSION_NUM_PATTERN.matcher(readId);</span>
<span class="fc" id="L66">        return matcher.matches();         </span>
    }
    /**
     * Parse the Universal Accession Number from a 454 read id
     * that may represent either an unmated 454 read or a mated
     * 454 read.  This method assumes that mate information
     * is appended to the universal accession number as a suffix.
     * @param readId the 454 read id to parse from.
     * @return the Universal Accession Number part of a valid 454 read id.
     * @throws IllegalArgumentException if the given read is not a valid 454 read.
     */
    public static String parseUniversalAccessionNumberFrom(String readId){        
<span class="fc" id="L78">        Matcher matcher = UNIVERSAL_ACCCESSION_NUM_PATTERN.matcher(readId);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if(matcher.matches()){</span>
<span class="fc" id="L80">            return matcher.group(1);</span>
        }
<span class="nc" id="L82">        throw new IllegalArgumentException(&quot;not a valid 454 read id: &quot;+ readId);</span>
    }
    /**
     * Compute a Rig Run Name String for the given 
     * date of the run, the rig name, the user who executed the run
     * @param date
     * @param rigName
     * @param username
     * @param uniqueRunName
     * @return
     */
    public static String computeRigRunName(Date date, String rigName, String username, String uniqueRunName){
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    	if(date ==null){</span>
<span class="nc" id="L95">    		throw new NullPointerException(&quot;date can not be null&quot;);</span>
    	}
    	
<span class="pc" id="L98">		Validator.validate(username, STRING_NOT_EMPTY, (u)-&gt;&quot;username is empty&quot;);</span>
<span class="pc" id="L99">		Validator.validate(uniqueRunName, STRING_NOT_EMPTY, (u)-&gt;&quot;unique run is empty&quot;);</span>
    	
<span class="fc" id="L101">    	LocalDateTime datetime =LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span>
    	
<span class="fc" id="L103">    	return String.format(&quot;R_%04d_%02d_%02d_%02d_%02d_%02d_%s_%s_%s&quot;,</span>
<span class="fc" id="L104">    			datetime.getYear(),</span>
<span class="fc" id="L105">    			datetime.getMonthValue(),</span>
<span class="fc" id="L106">    			datetime.getDayOfMonth(),</span>
<span class="fc" id="L107">    			datetime.getHour(),</span>
<span class="fc" id="L108">    			datetime.getMinute(),</span>
<span class="fc" id="L109">    			datetime.getSecond(),</span>
    			rigName,
    			username,
    			uniqueRunName
    			);
    }
   
   
    /**
     * Generate the correct 454 Universal Accession Number
     * for the given rigRunName, region number and well location.
     * @param rigRunName the name of the 454 rig run (usually starts 
     * 'R_{year}_{month}_{day}_{hour}_{minute}_{second}_'
     * @param regionNumber the region number of the 454 region to use.
     * @param wellLocation the Location object that refers to the 
     * X and Y coordinates of the well in the region to use.
     * @return the 454 Universal Accession Number that 
     * uniquely represents that read.
     * @throws NullPointerException if rigRunName  or wellLocation is null.
     * @throws IllegalArgumentException if rigRunName is not a valid rig run name.
     * @throws IllegalArgumentException if regionNumber is not a positive number between 0 and 99 inclusive.
     */
    public static String generateAccessionNumberFor(String rigRunName, int regionNumber, Location wellLocation){
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if(rigRunName ==null){</span>
<span class="nc" id="L133">            throw new NullPointerException(&quot;rigRunName can not be null&quot;);</span>
        }
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if(wellLocation ==null){</span>
<span class="nc" id="L136">            throw new NullPointerException(&quot;wellLocation can not be null&quot;);</span>
        }
<span class="pc bpc" id="L138" title="2 of 4 branches missed.">        if(regionNumber&lt;0 || regionNumber &gt;99){</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;region number must be &gt;=0 and &lt;=99 : &quot;+ regionNumber);</span>
        }
<span class="fc" id="L141">        RigRun rigRun = new RigRun(rigRunName);</span>
        
<span class="fc" id="L143">        final Date dateOfRigRun = rigRun.getDate();</span>
        
        
<span class="fc" id="L146">        final BigInteger encodedDate = DateEncoder.INSTANCE.encode(dateOfRigRun);</span>
<span class="fc" id="L147">        return new StringBuilder()</span>
<span class="fc" id="L148">                    .append(Base36Encoder.INSTANCE.encode(encodedDate))</span>
<span class="fc" id="L149">                    .append(rigRun.getRandomizingHashcode())</span>
<span class="fc" id="L150">                    .append(String.format(&quot;%02d&quot;, regionNumber))</span>
<span class="fc" id="L151">                    .append(wellLocation.encode())</span>
<span class="fc" id="L152">                    .toString();</span>
        
    }
	
    
    
    /**
     * Parse the Date of the Run when this
     * 454 read was generated.  
     * Universal 454 Accession Numbers encode the date of the run in their names,
     * this method parses that information out. 
     * @param readId the 454 read to parse.
     * @return a Date (not-null) of when this rig run started
     * that produced this readId.
     * @throws IllegalArgumentException is {@link #is454Read(String)}
     * returns false.
     */
    public static Date getDateOfRun(String readId){
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if(!is454Read(readId)){</span>
<span class="nc" id="L171">            throw new IllegalArgumentException(readId + &quot; is not a 454 read&quot;);</span>
        }
<span class="fc" id="L173">        final String substring = readId.substring(0,6);</span>
<span class="fc" id="L174">        BigInteger timeStamp = Base36Encoder.INSTANCE.decode(substring);        </span>
<span class="fc" id="L175">        return DateEncoder.INSTANCE.decode(timeStamp);</span>
    }
    
    
    
    /**
     * Parse the region number of where on the machine this
     * 454 read was generated.  
     * Universal 454 Accession Numbers encode the region number in their names,
     * this method parses that information out. 
     * @param readId the 454 read to parse.
     * @return a a positive 2 digit number of which region this read
     * is from. 
     * @throws IllegalArgumentException is {@link #is454Read(String)}
     * returns false.
     */
    public static int getRegionNumber(String readId){
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if(!is454Read(readId)){</span>
<span class="nc" id="L193">            throw new IllegalArgumentException(readId + &quot; is not a 454 read&quot;);</span>
        }
<span class="fc" id="L195">        final String substring = readId.substring(7,9);</span>
<span class="fc" id="L196">        return Integer.parseInt(substring);</span>
    }
    
    
    /**
     * {@code Location} represents the pixel coordinates of a well
     * on the PicoTiterPlate device which contains a DNA fragment being sequenced.
     * @author dkatzel
     *
     *
     */
    public static final class Location{
        private final int x,y;
<span class="fc" id="L209">        private static final BigInteger FOURTY_NINETY_SIX = BigInteger.valueOf(4096);</span>
        /**
         * @param x
         * @param y
         */
<span class="fc" id="L214">        public Location(int x, int y) {</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if(x &lt;0){</span>
<span class="nc" id="L216">                throw new IllegalArgumentException(&quot;x coordinate can not be negative&quot;);</span>
            }
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if(y &lt;0){</span>
<span class="nc" id="L219">                throw new IllegalArgumentException(&quot;y coordinate can not be negative&quot;);</span>
            }
<span class="fc" id="L221">            this.x = x;</span>
<span class="fc" id="L222">            this.y = y;</span>
<span class="fc" id="L223">        }</span>
        /**
         * Get the X pixel coordinate of this location.
         * @return a positive integer.
         */
        public int getX() {
<span class="nc" id="L229">            return x;</span>
        }
        /**
         * Get the Y pixel coordinate of this location.
         * @return a positive integer.
         */
        public int getY() {
<span class="nc" id="L236">            return y;</span>
        }
        
        private String encode(){
<span class="fc" id="L240">            String encoded = Base36Encoder.INSTANCE.encode(BigInteger.valueOf(x * 4096L + y));</span>
            //make it 5 characters, sometimes we don't have enough digits
            //so padd with leading A's?
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            if(encoded.length() ==5){</span>
<span class="fc" id="L244">            	return encoded;</span>
            }
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if(encoded.length() &gt; 5){</span>
<span class="nc" id="L247">            	return encoded.substring(encoded.length()-5);</span>
            }
<span class="nc" id="L249">            int numToPadd = 5 - encoded.length();</span>
<span class="nc" id="L250">            StringBuilder builder = new StringBuilder(5);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            for(int i=0; i&lt;numToPadd; i++){</span>
<span class="nc" id="L252">            	builder.append('A');</span>
            }
<span class="nc" id="L254">            builder.append(encoded);</span>
<span class="nc" id="L255">            return builder.toString();</span>
        }
        
        private static Location decode(String encodedLocation){
<span class="fc" id="L259">            BigInteger value =Base36Encoder.INSTANCE.decode(encodedLocation);</span>
<span class="fc" id="L260">            BigInteger x = value.divide(FOURTY_NINETY_SIX);</span>
<span class="fc" id="L261">            BigInteger y = value.mod(FOURTY_NINETY_SIX);</span>
<span class="fc" id="L262">            return new Location(x.intValue(), y.intValue());</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L267">            final int prime = 31;</span>
<span class="nc" id="L268">            int result = 1;</span>
<span class="nc" id="L269">            result = prime * result + x;</span>
<span class="nc" id="L270">            result = prime * result + y;</span>
<span class="nc" id="L271">            return result;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L277">                return true;</span>
            }
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L280">                return false;</span>
            }
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (!(obj instanceof Location)) {</span>
<span class="nc" id="L283">                return false;</span>
            }
<span class="fc" id="L285">            Location other = (Location) obj;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            if (x != other.x) {</span>
<span class="nc" id="L287">                return false;</span>
            }
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            if (y != other.y) {</span>
<span class="nc" id="L290">                return false;</span>
            }
<span class="fc" id="L292">            return true;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L297">            StringBuilder builder = new StringBuilder(30);</span>
<span class="nc" id="L298">            builder.append(&quot;Location [x=&quot;).append(x).append(&quot;, y=&quot;).append(y)</span>
<span class="nc" id="L299">                    .append(']');</span>
<span class="nc" id="L300">            return builder.toString();</span>
        }
        
    }
    /**
     * Parse the {@link Location} representing the X and Y coordinates 
     * of this 454 read id when it was run.
     * @param readId the 454 read id to parse from.
     * @return the Universal Accession Number part of a valid 454 read id.
     * @throws IllegalArgumentException is {@link #is454Read(String)}
     * returns false
     */
    public static Location parseLocationOf(String readId){
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if(!is454Read(readId)){</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(readId + &quot; is not a 454 read&quot;);</span>
        }
<span class="fc" id="L316">        String subString = readId.substring(9,14);</span>
<span class="fc" id="L317">        return Location.decode(subString);</span>
    }
    /**
     * Singleton helper class to convert to and from
     * 454 base-36 encoding which is different
     * than normal base36 encoding in that
     * digits 0-9 represent numbers 26-35.
     * @author dkatzel
     *
     *
     */
<span class="pc" id="L328">    private static enum Base36Encoder{</span>
<span class="fc" id="L329">        INSTANCE;</span>
        
        BigInteger decode(String encodedString){
<span class="fc" id="L332">            StringBuilder decodedBuilder = new StringBuilder(); </span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            for(char c : encodedString.toCharArray()){</span>
                final int value;
<span class="fc bfc" id="L335" title="All 2 branches covered.">                if(Character.isDigit(c)){</span>
<span class="fc" id="L336">                    value =Integer.parseInt(Character.toString(c))+26;</span>
                }else{
<span class="fc" id="L338">                    value =c-'A';</span>
                }
<span class="fc bfc" id="L340" title="All 2 branches covered.">                if(value &lt;10){</span>
<span class="fc" id="L341">                    decodedBuilder.append(value);</span>
                }else{
<span class="fc" id="L343">                    decodedBuilder.append((char)((value-10)+'A'));</span>
                }
                
            }
<span class="fc" id="L347">            return new BigInteger(decodedBuilder.toString(),36);</span>
        }
        
        String encode(long value){
<span class="fc" id="L351">            return encode(BigInteger.valueOf(value));</span>
        }
        
        
        String encode(BigInteger value){
<span class="fc" id="L356">            String base36EncodedString = value.toString(36).toUpperCase(Locale.ENGLISH);</span>
<span class="fc" id="L357">            StringBuilder x454EncodedBase36Builder = new StringBuilder();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">            for(Character c : base36EncodedString.toCharArray()){</span>
<span class="fc" id="L359">                int offset =Integer.parseInt(c.toString(), 36);</span>
               
<span class="fc bfc" id="L361" title="All 2 branches covered.">                if(offset&lt;26){</span>
<span class="fc" id="L362">                    x454EncodedBase36Builder.append((char)(offset+'A'));</span>
                }else{
<span class="fc" id="L364">                    x454EncodedBase36Builder.append((char)('0'+(offset-26)));</span>
                }
            }
            
<span class="fc" id="L368">            return x454EncodedBase36Builder.toString();</span>
        }
    }
    /**
     * Singleton to handle 454 Universal Accession Number
     * date calculations. 
     * &lt;p&gt; 
     * 454 Universal Accessions Numbers encode dates as a large number that 
     * is generated by multiplying the parts of the date by various
     * amounts and adding the results together.  Different Date parts can be
     * parsed out by division and modulus operations.
     * @author dkatzel
     *
     *
     */
<span class="pc" id="L383">    private static enum DateEncoder{</span>
<span class="fc" id="L384">        INSTANCE;</span>
        
<span class="fc" id="L386">        private static final BigInteger SIXTY = BigInteger.valueOf(60);</span>
<span class="fc" id="L387">        private static final BigInteger TWENTY_FOUR = BigInteger.valueOf(24);</span>
<span class="fc" id="L388">        private static final BigInteger THIRTEEN = BigInteger.valueOf(13);</span>
<span class="fc" id="L389">        private static final BigInteger THIRTY_TWO = BigInteger.valueOf(32);</span>
        
<span class="fc" id="L391">        private static final BigInteger MINUTE_MASK = SIXTY;</span>
<span class="fc" id="L392">        private static final BigInteger HOUR_MASK = MINUTE_MASK.multiply(SIXTY);</span>
<span class="fc" id="L393">        private static final BigInteger DAY_MASK = HOUR_MASK.multiply(TWENTY_FOUR);</span>
<span class="fc" id="L394">        private static final BigInteger MONTH_MASK = DAY_MASK.multiply(THIRTY_TWO);</span>
<span class="fc" id="L395">        private static final BigInteger YEAR_MASK = MONTH_MASK.multiply(THIRTEEN);</span>
        
        
        BigInteger encode(Date timestampOfRun){
<span class="fc" id="L399">            Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L400">            calendar.setTime(timestampOfRun);</span>
<span class="fc" id="L401">            BigInteger year = BigInteger.valueOf(calendar.get(Calendar.YEAR) -2000);</span>
<span class="fc" id="L402">            BigInteger month = BigInteger.valueOf(calendar.get(Calendar.MONTH));</span>
<span class="fc" id="L403">            BigInteger day = BigInteger.valueOf(calendar.get(Calendar.DAY_OF_MONTH));</span>
<span class="fc" id="L404">            BigInteger hour = BigInteger.valueOf(calendar.get(Calendar.HOUR_OF_DAY));</span>
<span class="fc" id="L405">            BigInteger minute = BigInteger.valueOf(calendar.get(Calendar.MINUTE));</span>
<span class="fc" id="L406">            BigInteger second = BigInteger.valueOf(calendar.get(Calendar.SECOND));</span>
            
<span class="fc" id="L408">            return YEAR_MASK.multiply(year)</span>
<span class="fc" id="L409">                                .add(MONTH_MASK.multiply(month))</span>
<span class="fc" id="L410">                                .add(DAY_MASK.multiply(day))</span>
<span class="fc" id="L411">                                .add(HOUR_MASK.multiply(hour))</span>
<span class="fc" id="L412">                                .add(MINUTE_MASK.multiply(minute))</span>
<span class="fc" id="L413">                                .add(second);</span>
                                
        }
        
        Date decode(BigInteger timestamp){
<span class="fc" id="L418">            BigInteger current = timestamp;</span>
            
<span class="fc" id="L420">            BigInteger year = current.divide(YEAR_MASK);</span>
<span class="fc" id="L421">            current = current.mod(YEAR_MASK);</span>
            
<span class="fc" id="L423">            BigInteger month = current.divide(MONTH_MASK);</span>
<span class="fc" id="L424">            current = current.mod(MONTH_MASK);</span>
            
<span class="fc" id="L426">            BigInteger dayOfMonth = current.divide(DAY_MASK);</span>
<span class="fc" id="L427">            current = current.mod(DAY_MASK);</span>
            
<span class="fc" id="L429">            BigInteger hourOfDay = current.divide(HOUR_MASK);</span>
<span class="fc" id="L430">            current = current.mod(HOUR_MASK);</span>
            
<span class="fc" id="L432">            BigInteger minute = current.divide(MINUTE_MASK);</span>
<span class="fc" id="L433">            current = current.mod(MINUTE_MASK);</span>
            
<span class="fc" id="L435">            BigInteger second = current;</span>
<span class="fc" id="L436">            return new GregorianCalendar(</span>
<span class="fc" id="L437">                    year.intValue()+2000, month.intValue()-1, dayOfMonth.intValue(), </span>
<span class="fc" id="L438">                    hourOfDay.intValue(), minute.intValue(), second.intValue())</span>
<span class="fc" id="L439">            .getTime();</span>
            
        }        
    }
    /**
     * {@code RigRun} is an object
     * representation of a 454 Rig Run.
     * @author dkatzel
     *
     *
     */
    private static final class RigRun{
<span class="fc" id="L451">        private static final Pattern RIG_RUN_NAME_PATTERN = Pattern.compile(&quot;^R_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_.+&quot;);</span>
        
        private final Date dateOfRun;
        private final char hash;
        
       
<span class="fc" id="L457">        private RigRun(String rigRunName){</span>
<span class="fc" id="L458">            this.dateOfRun = parseDateFrom(rigRunName);</span>
<span class="fc" id="L459">            this.hash = generate454Hash(rigRunName);</span>
<span class="fc" id="L460">        }</span>
        /**
         * Get the date of the run.
         * @return
         */
        Date getDate(){
<span class="fc" id="L466">            return dateOfRun;</span>
        }
        /**
         * Get the 'randomizing' hash character used in universal accession
         * numbers to enhance uniqueness.  Since Universal Accessions use date of run
         * and region and well location to generate names, it is possible for name collisions
         * to occur if 2 454 machines
         * start running at the same time.  To avoid this problem, a hash
         * based on the run name is added to the name the reduce the chance of collisions.
         * @return the randomizing 'hash' character computed based on the algorithm
         * specified in the 454 documentation.
         */
        char getRandomizingHashcode(){
<span class="fc" id="L479">            return hash;</span>
        }
        
        private Date parseDateFrom(String rigRunName){
<span class="fc" id="L483">            Matcher matcher = RIG_RUN_NAME_PATTERN.matcher(rigRunName);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if(!matcher.matches()){</span>
<span class="nc" id="L485">                throw new IllegalArgumentException(&quot;invalid rigRunName: &quot; + rigRunName);</span>
            }
<span class="fc" id="L487">            return new GregorianCalendar(</span>
<span class="fc" id="L488">                    Integer.parseInt(matcher.group(1)), </span>
<span class="fc" id="L489">                    Integer.parseInt(matcher.group(2)),</span>
<span class="fc" id="L490">                    Integer.parseInt(matcher.group(3)),</span>
<span class="fc" id="L491">                    Integer.parseInt(matcher.group(4)), </span>
<span class="fc" id="L492">                    Integer.parseInt(matcher.group(5)), </span>
<span class="fc" id="L493">                    Integer.parseInt(matcher.group(6))).getTime();</span>
        }
        private char generate454Hash(String rigRunName){
<span class="fc" id="L496">            int hash=0;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            for(char c : rigRunName.toCharArray()){</span>
<span class="fc" id="L498">                hash+= c;</span>
<span class="fc" id="L499">                hash%=31;</span>
            }
<span class="fc" id="L501">            return Base36Encoder.INSTANCE.encode(hash).charAt(0);</span>
            
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>