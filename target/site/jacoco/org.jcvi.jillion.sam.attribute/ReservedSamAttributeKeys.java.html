<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReservedSamAttributeKeys.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.sam.attribute</a> &gt; <span class="el_source">ReservedSamAttributeKeys.java</span></div><h1>ReservedSamAttributeKeys.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.sam.attribute;

import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamReadGroup;

/**
 * {@code ReservedSamAttributeKeys}
 * are the {@link SamAttributeKey}s that the 
 * SAM specification has reserved to mean
 * specific things.
 * @author dkatzel
 *
 */
<span class="pc" id="L34">public enum ReservedSamAttributeKeys{</span>
	/**
	 * The smallest template-independent mapping
	 * quality of segments in the rest.
	 */
<span class="fc" id="L39">	SMALLEST_MAPPING_QUAL('A','M', SamAttributeType.SIGNED_INT),</span>
	/**
	 * The Alignment score generated by the aligner.
	 */
<span class="fc" id="L43">	ALIGNMENT_SCORE('A','S', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Barcode sequence.
	 */
<span class="fc" id="L47">	BARCODE_SEQUENCE('B','C', SamAttributeType.STRING),</span>
	/**
	 * Offset to base alignment quality (BAQ), of the same length as the read sequence. 
	 * At the i-th read base, BAQ&lt;sub&gt;i&lt;/sub&gt; = Q&lt;sub&gt;i&lt;/sub&gt; - (BQ&lt;sub&gt;i&lt;/sub&gt; - 64) 
	 * where Q&lt;sub&gt;i&lt;/sub&gt; is the i-th base quality.
	 */
<span class="fc" id="L53">	BASE_ALIGNMENT_QUAL_OFFSET('B','Q', SamAttributeType.STRING),</span>
	/**
	 * Reference name of the next hit;
	 * '=' for the same chromosome.
	 */
<span class="fc" id="L58">	NEXT_HIT_REF_NAME('C','C', SamAttributeType.STRING),</span>
	/**
	 * Edit distance between the color sequence and the color reference (see also {@link #EDIT_DISTANCE})
	 */
<span class="fc" id="L62">	COLOR_EDIT_DISTANCE('C','M', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Free Text comments.
	 */
<span class="fc" id="L66">	COMMENTS('C','O',SamAttributeType.STRING),</span>
	/**
	 * Leftmost coordinate of the next hit
	 */
<span class="fc" id="L70">	LEFT_COORD_NEXT_HIT('C','P',SamAttributeType.SIGNED_INT),</span>
	/**
	 * Color read quality on the original strand of the read.
	 *  Same encoding as QUAL; same length as {@link #COLOR_SEQUENCE}.
	 */
<span class="fc" id="L75">	COLOR_READ_QUAL('C','Q', SamAttributeType.STRING),</span>
	/**
	 * Color read sequence on the original strand of the read. 
	 * The primer base must be included.
	 */
<span class="fc" id="L80">	COLOR_SEQUENCE('C','S', SamAttributeType.STRING),</span>
	/**
	 * Complete read annotation tag, used for consensus annotation dummy features.
	 * &lt;p&gt;
	 * This key is intended primarily for annotation dummy reads, and consists of a strand, type and zero or more
key=value pairs, each separated with semicolons. The strand field has four values as in GFF3, and supplements
 {@link SamRecordFlags#REVERSE_COMPLEMENTED} to allow unstranded (`.'), and stranded but unknown strand (`?') annotation. For these and annotation on the
forward strand (strand set to `+'), do not set {@link SamRecordFlags#REVERSE_COMPLEMENTED}. For annotation on the reverse strand, set the strand to `-'
and set {@link SamRecordFlags#REVERSE_COMPLEMENTED}. The type and any keys and their optional values are all percent encoded according to RFC3986
to escape meta-characters `=', `%', `;', `|' or non-printable characters not matched by the isprint() macro (with the C
locale). For example a percent sign becomes `%2C'. The  record matches: \strand ;type (;key (=value ))*&quot;.
	 * &lt;/p&gt;
	 */
<span class="fc" id="L93">	COMPLETE_READ_ANNOTATION('C','T', SamAttributeType.STRING),</span>
	/**
	 * The 2nd most likely base calls. Same encoding and same length as QUAL.
	 */
<span class="fc" id="L97">	SECOND_MOSTLY_LIKELY_BASECALLS('E','2', SamAttributeType.STRING),</span>
	
	/**
	 * The index of segment in the template.
	 */
<span class="fc" id="L102">	TEMPLATE_INDEX('F','I', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Segment suffix.
	 */
<span class="fc" id="L106">	SEGMENT_SUFFIX('F','S', SamAttributeType.STRING),</span>
	/**
	 * Flow signal intensities on the original strand of the read, stored as (uint16 t)
round(value * 100.0).
	 */
<span class="fc" id="L111">	FLOW_SIG('F','Z', SamAttributeType.UNSIGNED_SHORT_ARRAY),</span>
	/**
	 * Library. Value to be consistent with the header
	 * {@link org.jcvi.jillion.sam.header.ReadGroup#getLibrary()}
	 *  if this record belong to a Read Group.
	 */
<span class="fc" id="L117">	LIBRARY('L','B', SamAttributeType.STRING){</span>

		@Override
		public void validate(SamHeader header, Object value) throws InvalidAttributeException {
<span class="fc" id="L121">			String libId = getType().getString(value);</span>
<span class="fc" id="L122">			boolean found=false;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">			for(SamReadGroup readGroup : header.getReadGroups()){</span>
				//equals order allows for readGroup's getLibrary() to return null
<span class="fc bfc" id="L125" title="All 2 branches covered.">				if(libId.equals(readGroup.getLibrary())){</span>
<span class="fc" id="L126">					found = true;</span>
<span class="fc" id="L127">					break;</span>
				}
<span class="fc" id="L129">			}</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">			if(!found){</span>
<span class="fc" id="L131">				throw new InvalidAttributeException(&quot;header must have read group with id &quot;+ value);</span>
			}
<span class="fc" id="L133">		}</span>
		
	},
	/**
	 * Number of perfect hits
	 */
<span class="fc" id="L139">	NUM_PERFECT_HITS('H','0', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Number of 1-difference hits (see also {@link #EDIT_DISTANCE})
	 */
<span class="fc" id="L143">	ONE_DIFF_HITS('H','1', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Number of 2-difference hits (see also {@link #EDIT_DISTANCE})
	 */
<span class="fc" id="L147">	TWO_DIFF_HITS('H','2', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Query hit index, indicating the alignment record 
	 * is the i-th one stored in SAM.
	 */
<span class="fc" id="L152">	QUERY_HIT_INDEX('H','I', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Number of stored alignments in SAM that contains 
	 * the query in the current record.
	 */
<span class="fc" id="L157">	NUM_ALIGNMENTS('I','H', SamAttributeType.SIGNED_INT),</span>
	/**
	 * String for mismatching positions. Regex : [0-9]+(([A-Z]|\^[A-Z]+)[0-9]+)*.
	 *&lt;p&gt;
	 *This field aims to achieve SNP/indel calling without looking at the reference.
	 * For example, a string `10A5^AC6' means from the leftmost
	 *  reference base in the alignment, there are 10 matches 
	 *  followed by an A on the reference which is 
	 *  different from the aligned read base; 
	 *  the next 5 reference bases are matches followed
	 *   by a 2bp deletion from the reference; 
	 *   the deleted sequence is AC; 
	 *   the last 6 bases are matches.
	 *   This field ought to match the CIGAR string.
	 *&lt;/p&gt;
	 */
<span class="fc" id="L173">	MISMATCHING_POSITIONS('M','D', SamAttributeType.STRING),</span>
	/**
	 * Mapping quality of the mate/next segment.
	 */
<span class="fc" id="L177">	MATE_OR_NEXT_MAPPING_QUALITY('M','Q', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Number of reported alignments that contains the query in the current record.
	 */
<span class="fc" id="L181">	NUM_REPORTED_ALIGNEMENTS('N','H', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Edit distance to the reference, including ambiguous bases but excluding clipping.
	 */
<span class="fc" id="L185">	EDIT_DISTANCE('N','M', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Original base quality (usually before recalibration). Same encoding as QUAL.
	 */
<span class="fc" id="L189">	ORIGINAL_QUALTY('O','Q', SamAttributeType.STRING),</span>
	/**
	 * Original mapping position (usually before realignment).
	 */
<span class="fc" id="L193">	ORIGINAL_MAPPING_POSITION('O','P', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Original CIGAR (usually before realignment).
	 */
<span class="fc" id="L197">	ORIGINAL_CIGAR('O','C', SamAttributeType.STRING),</span>
	/**
	 * SamProgram, the value must match 
	 * a {@link org.jcvi.jillion.sam.header.SamProgram#getId()}
	 * in the header.
	 */
<span class="fc" id="L203">	PROGRAM('P','G', SamAttributeType.STRING){</span>

		@Override
		void validate(SamHeader header, Object value)
				throws InvalidAttributeException {
<span class="fc bfc" id="L208" title="All 2 branches covered.">			if(header.getSamProgram(getType().getString(value)) ==null){</span>
<span class="fc" id="L209">				throw new InvalidAttributeException(&quot;header does not contain program &quot; + value);</span>
			}
<span class="fc" id="L211">		}</span>
		
	},
	/**
	 * Phred likelihood of the template, conditional on both the mapping being correct
	 */
<span class="fc" id="L217">	PHRED_LIKELIHOOD_OF_TEMPLATE('P','Q', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Read annotations for parts of the padded read sequence.
	 * &lt;p&gt;
	 * This key's value has the format of a series of tags separated by |, each
	 * annotating a sub-region of the read. Each tag consists of start, end,
	 * strand, type and zero or more key=value pairs, each separated with
	 * semicolons. Start and end are 1-based positions between one and the sum
	 * of the M/I/D/P/S/=/X CIGAR operators, i.e. SEQ length plus any pads. Note
	 * any editing of the CIGAR string may require updating the `PT' tag
	 * coordinates, or even invalidate them. As in GFF3, strand is one of `+'
	 * for forward strand tags, `-' for reverse strand, `.' for unstranded or
	 * `?' for stranded but unknown strand. The type and any keys and their
	 * optional values are all percent encoded as in the CT tag. Formally the
	 * entire PT record matches: \start ;end ;strand ;type (;key (=value
	 * ))*(\|start ;end ;strand ;type (;key (=value ))*)*&quot;.
	 * &lt;/p&gt;
	 */
<span class="fc" id="L235">	PADDED_ANNOTATIONS('P','T', SamAttributeType.STRING),</span>
	/**
	 * Platform unit of this record, the value must be consistent with 
	 * a {@link org.jcvi.jillion.sam.header.ReadGroup#getPlatformUnit()}
	 * in the header..
	 */
<span class="fc" id="L241">	PLATFORMT_UNIT('P','U', SamAttributeType.STRING){</span>
		@Override
		void validate(SamHeader header, Object value)
				throws InvalidAttributeException {
<span class="fc" id="L245">			String actualPlatformUnit = getType().getString(value);</span>
			//don't have access to which read group
			//this read is in
			//so try them all?
			//this could have false positives if the
			//read uses a platform unit from
			//a different read group.
<span class="fc" id="L252">			boolean found=false;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">			for(SamReadGroup group : header.getReadGroups()){</span>
<span class="fc" id="L254">				String platformUnit = group.getPlatformUnit();</span>
				//equals order is to handle null platformUnits
<span class="fc bfc" id="L256" title="All 2 branches covered.">				if(actualPlatformUnit.equals(platformUnit)){</span>
<span class="fc" id="L257">					found=true;</span>
<span class="fc" id="L258">					break;</span>
				}
<span class="fc" id="L260">			}</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">			if(!found){</span>
<span class="fc" id="L262">				throw new InvalidAttributeException(&quot;header does not contain platform unit &quot; + value);</span>
			}
<span class="fc" id="L264">		}</span>
	},
	/**
	 * Phred quality of the barcode sequence in the {@link #BARCODE_SEQUENCE} (or {@link #READ_TAG}) tag. Same encoding as QUAL.
	 */
<span class="fc" id="L269">	BARCODE_QUALITY('Q','T', SamAttributeType.STRING),</span>
	/**
	 * Phred quality of the mate/next segment sequence in the {@link #SEQUENCE_OF_NEXT_OR_MATE}.
	 *  Same encoding as QUAL.
	 */
<span class="fc" id="L274">	QUALITY_OF_NEXT_OR_MATE('Q','2', SamAttributeType.STRING),</span>
	
	/**
	 * Sequence of the mate/next segment in the template.
	 */
<span class="fc" id="L279">	SEQUENCE_OF_NEXT_OR_MATE('R','2', SamAttributeType.STRING),</span>
	/**
	 * Read group this record belongs to, the value must match a {@link org.jcvi.jillion.sam.header.ReadGroup}
	 * in the header.
	 */
<span class="fc" id="L284">	READ_GROUP('R','G', SamAttributeType.STRING){</span>
		@Override
		void validate(SamHeader header, Object value)
				throws InvalidAttributeException {
<span class="fc bfc" id="L288" title="All 2 branches covered.">			if(header.getReadGroup(getType().getString(value)) ==null){</span>
<span class="fc" id="L289">				throw new InvalidAttributeException(&quot;header does not contain program &quot; + value);</span>
			}
<span class="fc" id="L291">		}</span>
	},
	/**
	 * Deprecated alternative to {@link #BARCODE_SEQUENCE} tag originally used at Sanger.
	 */
<span class="fc" id="L296">	@Deprecated</span>
	READ_TAG('R','T', SamAttributeType.STRING),
	
	/**
	 * Other canonical alignments in a chimeric alignment, in the format of:
	 * (rname,pos,strand,CIGAR,mapQ,NM;)+. Each element in the semi-colon delim-
	 * ited list represents a part of the chimeric alignment. Conventionally, at
	 * a supplementary line, the first element points to the primary line.
	 */
<span class="fc" id="L305">	OTHER_ALIGNMENT('S','A', SamAttributeType.STRING),</span>
	/**
	 * Template-independent mapping quality.
	 */
<span class="fc" id="L309">	MAPPING_QUALITY('S','M', SamAttributeType.SIGNED_INT),</span>
	/**
	 * The number of segments in the template.
	 */
<span class="fc" id="L313">	NUM_SEGS_IN_TEMPLATE('T','C', SamAttributeType.SIGNED_INT),</span>
	/**
	 * Phred probility of the 2nd call being wrong conditional on the best being
	 * wrong. The same encoding as QUAL.
	 */
<span class="fc" id="L318">	QUAL_SECOND_CALL_WRONG_TOO('Q','2', SamAttributeType.STRING),</span>
	/**
	 * Phred likelihood of the segment, conditional on the mapping being correct.
	 */
<span class="fc" id="L322">	QUAL_OF_THE_SEGMENT('U','Q', SamAttributeType.SIGNED_INT)</span>
	;
	
	private static final ReservedSamAttributeKeys[][] CACHE;
	static{
		//cache is wasteful since we don't
		//need to store every 2 letter combination
		//but it makes for very fast look ups/
		//43 because 0-Z
<span class="fc" id="L331">		CACHE = new ReservedSamAttributeKeys[43][43];</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">		for(ReservedSamAttributeKeys reserved : values()){</span>
<span class="fc" id="L333">			SamAttributeKey key = reserved.getKey();</span>
<span class="fc" id="L334">			CACHE[getCacheIndex(key.getFirstChar())][getCacheIndex(key.getSecondChar())] = reserved;</span>
		}
<span class="fc" id="L336">	}</span>
	
	private static int getCacheIndex(char c){
<span class="fc" id="L339">		return c -'0';</span>
	}
	private SamAttributeKey key;
	private SamAttributeType type;
	
<span class="fc" id="L344">	ReservedSamAttributeKeys(char c1, char c2, SamAttributeType type){</span>
<span class="fc" id="L345">		this.key = SamAttributeKeyFactory.getKey(c1,c2);</span>
<span class="fc" id="L346">		this.type = type;</span>
<span class="fc" id="L347">	}</span>

	public SamAttributeKey getKey() {
<span class="fc" id="L350">		return key;</span>
	}
	
	void validate(SamHeader header, Object value) throws InvalidAttributeException{
		//no-op by default
<span class="fc" id="L355">	}</span>
	
	public SamAttributeType getType() {
<span class="fc" id="L358">		return type;</span>
	}
	public static ReservedSamAttributeKeys parseKey(SamAttributeKey key){
<span class="fc" id="L361">		return parseKey(key.getFirstChar(), key.getSecondChar());</span>
	}
	public static ReservedSamAttributeKeys parseKey(char c1, char c2){
<span class="fc" id="L364">		return CACHE[getCacheIndex(c1)][getCacheIndex(c2)];</span>
	}
	public static ReservedSamAttributeKeys parseKey(String key){
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">		if(key.length() !=2){</span>
<span class="nc" id="L368">			throw new IllegalArgumentException(&quot;key string must be 2 chars long &quot; + key);</span>
		}
<span class="fc" id="L370">		return parseKey(key.charAt(0), key.charAt(1));</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>