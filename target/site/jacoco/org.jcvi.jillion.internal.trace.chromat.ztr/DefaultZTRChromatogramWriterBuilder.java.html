<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultZTRChromatogramWriterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.trace.chromat.ztr</a> &gt; <span class="el_source">DefaultZTRChromatogramWriterBuilder.java</span></div><h1>DefaultZTRChromatogramWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.trace.chromat.ztr;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.jcvi.jillion.core.util.Builder;
import org.jcvi.jillion.internal.core.seq.trace.sanger.chromat.ztr.data.Data;
import org.jcvi.jillion.internal.trace.chromat.ztr.chunk.Chunk;
import org.jcvi.jillion.internal.trace.chromat.ztr.chunk.ChunkType;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.DeltaEncodedData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.DeltaEncodedData.Level;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.FollowData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.RunLengthEncodedData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.ShrinkToEightBitData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.ZLibData;
import org.jcvi.jillion.trace.chromat.Chromatogram;


/**
 * {@code DefaultZTRChromatogramWriterBuilder} is a Builder for
 * {@link ZtrChromatogramWriter}s that allows total control
 * over what encoders are used in which order for every different
 * field in a {@link ZtrChromatogram}.
 * 
 * &lt;p/&gt;
 * For example: here is how to build a ZTRChromatogramWriter
 * that encodes the same as the staden IO_Lib module:
 * &lt;pre/&gt; 
 	DefaultZTRChromatogramWriterBuilder builder = new DefaultZTRChromatogramWriterBuilder();
	builder.forBasecallChunkEncoder()
    			.addEncoder(ZLibData.INSTANCE);
	builder.forPositionsChunkEncoder()
		.addDeltaEncoder(DeltaEncodedData.SHORT, Level.DELTA_LEVEL_3)
		.addEncoder(ShrinkToEightBitData.SHORT_TO_BYTE)
		.addEncoder(FollowData.INSTANCE)
		.addRunLengthEncoder()
		.addEncoder(ZLibData.INSTANCE);
	builder.forConfidenceChunkEncoder()
		.addDeltaEncoder(DeltaEncodedData.BYTE, Level.DELTA_LEVEL_1)
		.addRunLengthEncoder((byte)77)
		.addEncoder(ZLibData.INSTANCE);
	builder.forPeaksChunkEncoder()
		.addDeltaEncoder(DeltaEncodedData.INTEGER, Level.DELTA_LEVEL_1)
		.addEncoder(ShrinkToEightBitData.INTEGER_TO_BYTE)
		.addEncoder(ZLibData.INSTANCE);
	builder.forCommentsChunkEncoder()
		.addEncoder(ZLibData.INSTANCE);
		
	ZTRChromatogramWriter writer = builder.build();
	&lt;pre/&gt;
 * &lt;p/&gt;
 * @author dkatzel
 *
 */
<span class="fc" id="L79">public final class DefaultZTRChromatogramWriterBuilder implements Builder&lt;ZtrChromatogramWriter&gt;{</span>

<span class="fc" id="L81">	private final ChunkEncoderBuilder basecallEncoder = new ChunkEncoderBuilder(Chunk.BASE, ChunkType.BASECALLS);</span>
<span class="fc" id="L82">	private final ChunkEncoderBuilder positionsEncoder= new ChunkEncoderBuilder(Chunk.SMP4, ChunkType.SAMPLES);</span>
<span class="fc" id="L83">	private final ChunkEncoderBuilder confidenceEncoder= new ChunkEncoderBuilder(Chunk.CONFIDENCES, ChunkType.CONFIDENCE);</span>
<span class="fc" id="L84">	private final ChunkEncoderBuilder commentsEncoder= new ChunkEncoderBuilder(Chunk.COMMENTS, ChunkType.COMMENTS);</span>
<span class="fc" id="L85">	private final ChunkEncoderBuilder clipEncoder= new ChunkEncoderBuilder(Chunk.CLIP, ChunkType.CLIP);</span>
<span class="fc" id="L86">	private final ChunkEncoderBuilder peaksEncoder= new ChunkEncoderBuilder(Chunk.POSITIONS, ChunkType.POSITIONS);</span>
	/**
	 * Get the {@link ChunkEncoderBuilder} for the basecalls
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the basecalls
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forBasecallChunkEncoder(){
<span class="fc" id="L94">		return basecallEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the positions
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the positions
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forPositionsChunkEncoder(){
<span class="fc" id="L103">		return positionsEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the confidence
	 * (quality)
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the confidence
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forConfidenceChunkEncoder(){
<span class="fc" id="L113">		return confidenceEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the comments
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the comments
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forCommentsChunkEncoder(){
<span class="fc" id="L122">		return commentsEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the clip points
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the clip points
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forClipPointsChunkEncoder(){
<span class="nc" id="L131">		return clipEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the peaks
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the peaks
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forPeaksChunkEncoder(){
<span class="fc" id="L140">		return peaksEncoder;</span>
	}
	/**
	 * Creates a new ZTRChromatogramWriter
	 * using the encoding settings that have been given.
	 */
	@Override
	public ZtrChromatogramWriter build() {
<span class="fc" id="L148">		return new DefaultZTRChromatogramWriter(</span>
<span class="fc" id="L149">				basecallEncoder.build(), </span>
<span class="fc" id="L150">				positionsEncoder.build(), </span>
<span class="fc" id="L151">				confidenceEncoder.build(), </span>
<span class="fc" id="L152">				commentsEncoder.build(), </span>
<span class="fc" id="L153">				clipEncoder.build(),</span>
<span class="fc" id="L154">				peaksEncoder.build());</span>
	}

	private static final class DataEncoder{
		private final Data data;
		private final byte optionalParameter;
		
		private DataEncoder(Data data) {
<span class="fc" id="L162">			this(data,(byte)0);</span>
<span class="fc" id="L163">		}</span>
<span class="fc" id="L164">		private DataEncoder(Data data, byte optionalParameter) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">			if(data==null){</span>
<span class="nc" id="L166">				throw new NullPointerException(&quot;data can not be null&quot;);</span>
			}
<span class="fc" id="L168">			this.data = data;</span>
<span class="fc" id="L169">			this.optionalParameter = optionalParameter;</span>
<span class="fc" id="L170">		}</span>


		private byte[] encode(byte[] data) throws IOException{
<span class="fc" id="L174">			return this.data.encodeData(data, optionalParameter);</span>
		}
	}
	
	private static final class ChunkEncoder{
		private final ChunkType type;
		private final Chunk chunk;
		private final List&lt;DataEncoder&gt; dataEncoders;
		
		private ChunkEncoder(ChunkType type, Chunk chunk,
				List&lt;DataEncoder&gt; dataEncoders) {
<span class="fc" id="L185">			super();</span>
<span class="fc" id="L186">			this.type = type;</span>
<span class="fc" id="L187">			this.chunk = chunk;</span>
<span class="fc" id="L188">			this.dataEncoders = dataEncoders;</span>
<span class="fc" id="L189">		}</span>
		
		public byte[] encode(Chromatogram chromatogram) throws IOException{
			
<span class="fc" id="L193">			byte[] currentData = chunk.encodeChunk(chromatogram);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">			for(DataEncoder encoder : dataEncoders){</span>
<span class="fc" id="L195">				currentData =encoder.encode(currentData);</span>
<span class="fc" id="L196">			}</span>
<span class="fc" id="L197">			ByteBuffer encodedData = ByteBuffer.allocate(12+currentData.length);</span>
			try {
<span class="fc" id="L199">				encodedData.put(type.getTypeName().getBytes(&quot;UTF-8&quot;));</span>
<span class="nc" id="L200">			} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L201">				throw new IOException(&quot;could not encode chunk type &quot;+type,e);</span>
<span class="fc" id="L202">			}</span>
			//never put metadata, so metadata length is always zero
<span class="fc" id="L204">			encodedData.putInt(0);</span>
<span class="fc" id="L205">			encodedData.putInt(currentData.length);</span>
<span class="fc" id="L206">			encodedData.put(currentData);</span>
<span class="fc" id="L207">			return encodedData.array();</span>
		}
	}
	/**
	 * {@code ChunkEncoderBuilder} is a Builder which describes
	 * the order of the different encoding schemes used
	 * to encode each ZTR Chunk.  Encodings can be chained
	 * together to improve compression.  For example,
	 * it might be a good idea to encode a chunk with a Delta encoding
	 * and then with a {@link ShrinkToEightBitData} encoding
	 * since most of the delta values should fit into a single byte each. 
	 * 
	 * @author dkatzel
	 *
	 */
	public static class ChunkEncoderBuilder implements Builder&lt;ChunkEncoder&gt;{

		private final Chunk chunk;
		private final ChunkType chunkType;
<span class="fc" id="L226">		private final List&lt;DataEncoder&gt; encoders = new ArrayList&lt;DataEncoder&gt;();</span>
		/**
		 * Create a new ChunkEncoderBuilder for the given {@link Chunk} and {@link ChunkType}.
		 * @param chunk the chunk that this will encode; may not be null.
		 * @param chunkType the chunk type that this will encode; may not be null.
		 * @throws NullPointerException if chunk or chunkType are null.
		 */
<span class="fc" id="L233">		public ChunkEncoderBuilder(Chunk chunk, ChunkType chunkType) {</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			if(chunk==null){</span>
<span class="nc" id="L235">				throw new NullPointerException(&quot;chunk can not be null&quot;);</span>
			}
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">			if(chunkType==null){</span>
<span class="nc" id="L238">				throw new NullPointerException(&quot;chunkType can not be null&quot;);</span>
			}
<span class="fc" id="L240">			this.chunk = chunk;</span>
<span class="fc" id="L241">			this.chunkType = chunkType;</span>
<span class="fc" id="L242">		}		</span>
		/**
		 * Adds a runLength Encoder using the default
		 * guard value.  This is the same as
		 * {@link #addRunLengthEncoder(byte) addRunLengthEncoder(RunLengthEncodedData.DEFAULT_GUARD)}
		 * @return this
		 * @see RunLengthEncodedData#DEFAULT_GUARD
		 * @see #addRunLengthEncoder()
		 */
		public ChunkEncoderBuilder addRunLengthEncoder(){
<span class="fc" id="L252">			return addRunLengthEncoder(RunLengthEncodedData.DEFAULT_GUARD);</span>
		}
		/**
		 * Adds a ZLIB Encoder (for
		 * compressing data via ZIP).
		 * @return this.
		 */
		public ChunkEncoderBuilder addZLibEncoder(){
<span class="fc" id="L260">			encoders.add(new DataEncoder(ZLibData.INSTANCE));</span>
<span class="fc" id="L261">			return this;</span>
		}
		/**
		 * Adds a FollowData Encoder.
		 * @see FollowData
		 * @return this.
		 */
		public ChunkEncoderBuilder addFollowEncoder(){
<span class="fc" id="L269">			encoders.add(new DataEncoder(FollowData.INSTANCE));</span>
<span class="fc" id="L270">			return this;</span>
		}
		/**
		 * Adds a {@link ShrinkToEightBitData} encoder.
		 * @param shrinker the {@link ShrinkToEightBitData} encoder
		 * to use.
		 * @return this.
		 */
		public ChunkEncoderBuilder addShrinkEncoder(ShrinkToEightBitData shrinker){
<span class="fc" id="L279">			encoders.add(new DataEncoder(shrinker));</span>
<span class="fc" id="L280">			return this;</span>
		}
		/**
		 * Adds a runLength Encoder using the given
		 * guard value.  The guard value is used to run length blocks 
		 * and must be handled specially if it occurs in the un-encoded data;
		 * therefore it is preferable to use a guard value
		 * that won't occur often or at all in the un-encoded input data. 
		 * @param guard the value of the guard.
		 * @return this.
		 */
		public ChunkEncoderBuilder addRunLengthEncoder(byte guard){
<span class="fc" id="L292">			encoders.add(new DataEncoder(RunLengthEncodedData.INSTANCE,guard));</span>
<span class="fc" id="L293">			return this;</span>
		}
		/**
		 * Add a Delta Encoder of the given type with the given level.
		 * It has been found experimentally that {@link Level#DELTA_LEVEL_3}
		 * works better for int size values and {@link Level#DELTA_LEVEL_1}
		 * works better for byte and short sized values.
		 * @param deltaEncoder the deltaEncoder instance to use.
		 * @param deltaLevel the the delta level to use.  
		 * @return this
		 * @throws NullPointerException if deltaEncoder or deltaLevel are null.
		 */
		public ChunkEncoderBuilder addDeltaEncoder(DeltaEncodedData deltaEncoder,Level deltaLevel){
<span class="fc" id="L306">			encoders.add(new DataEncoder(deltaEncoder,deltaLevel.getLevel()));</span>
<span class="fc" id="L307">			return this;</span>
		}
		/**
		 * Constructs a new ChunkEncoder with the specified
		 * encoder chain for the given chunk and chunkType.
		 * @return a new ChunkEncoder.
		 */
		@Override
		public ChunkEncoder build() {			
<span class="fc" id="L316">			return new ChunkEncoder(chunkType, chunk, encoders);</span>
		}
	}
	
	
	/**
	 * {@code DefaultZTRChromatogramWriter} is an implementation
	 * of ZTRChromatogramWriter.  Use {@link DefaultZTRChromatogramWriterBuilder}
	 * to customize the encoding options.
	 * @author dkatzel
	 * @see &lt;a href=&quot;http://staden.sourceforge.net/ztr.html&quot;&gt;ZTR 1.2 Spec&lt;/a&gt;
	 */
	private static final class DefaultZTRChromatogramWriter implements ZtrChromatogramWriter{
		
		/**
		 * Specifies that this is chromatogram
		 * is encoded using ZTR 1.2 spec.
		 */
<span class="fc" id="L334">		private static final byte[] ZTR_VERSION =new byte[]{1,2};</span>
		private final ChunkEncoder basecallEncoder;
		private final ChunkEncoder peaksEncoder;
		private final ChunkEncoder positionsEncoder;
		private final ChunkEncoder confidenceEncoder;
		private final ChunkEncoder commentsEncoder;
		private final ChunkEncoder clipEncoder;
		
		
		private DefaultZTRChromatogramWriter(ChunkEncoder basecallEncoder,
				ChunkEncoder positionsEncoder, ChunkEncoder confidenceEncoder,
<span class="fc" id="L345">				ChunkEncoder commentsEncoder, ChunkEncoder clipEncoder, ChunkEncoder peaksEncoder) {</span>
<span class="fc" id="L346">			this.basecallEncoder = basecallEncoder;</span>
<span class="fc" id="L347">			this.positionsEncoder = positionsEncoder;</span>
<span class="fc" id="L348">			this.confidenceEncoder = confidenceEncoder;</span>
<span class="fc" id="L349">			this.commentsEncoder = commentsEncoder;</span>
<span class="fc" id="L350">			this.clipEncoder = clipEncoder;</span>
<span class="fc" id="L351">			this.peaksEncoder = peaksEncoder;</span>
<span class="fc" id="L352">		}</span>
		/**
		 * Encode the given chromatogram and write it
		 * to the given outputStream.  The stream
		 * WILL NOT be closed when this method completes.
		 * @param chromatogram the ZTR chromatogram to 
		 * encode and write; may not be null.
		 * @param out the OutputStream to write the encoded
		 * ZTR to.
		 * @throws IOException if there is a problem
		 * encoding the ZTR chromatogram.
		 * @throws NullPointerException if chromatogram or out
		 * are null.
		 */
		@Override
		public void write(Chromatogram chromatogram, OutputStream out)
				throws IOException {
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">			if(chromatogram ==null){</span>
<span class="nc" id="L370">				throw new NullPointerException(&quot;chromatogram can not be null&quot;);</span>
			}
			
			try {
<span class="fc" id="L374">				out.write(ZTRUtil.getMagicNumber());</span>
<span class="fc" id="L375">				out.write(ZTR_VERSION);</span>
				//this is the order that staden IO_Lib uses
				//some chunks are required before
				//other chunks can be parsed
				//(ex basecalls) so the order
				//should not be changed.
<span class="fc" id="L381">				out.write(positionsEncoder.encode(chromatogram));</span>
<span class="fc" id="L382">				out.write(basecallEncoder.encode(chromatogram));</span>
<span class="fc" id="L383">				out.write(peaksEncoder.encode(chromatogram));</span>
<span class="fc" id="L384">				out.write(confidenceEncoder.encode(chromatogram));			</span>
<span class="fc" id="L385">				out.write(commentsEncoder.encode(chromatogram));</span>
<span class="fc" id="L386">				out.write(clipEncoder.encode(chromatogram));</span>
				
<span class="nc" id="L388">			} catch (IOException e) {</span>
<span class="nc" id="L389">				throw new IOException(&quot;error writing ZTR&quot;, e);</span>
<span class="fc" id="L390">			}</span>
			
<span class="fc" id="L392">		}</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>