<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AssemblyArchiveWriterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.experimental.ncbi.submit.assemblyArchive</a> &gt; <span class="el_source">AssemblyArchiveWriterBuilder.java</span></div><h1>AssemblyArchiveWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.experimental.ncbi.submit.assemblyArchive;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.SortedSet;
import java.util.TreeSet;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.assembly.consed.ace.AceContig;
import org.jcvi.jillion.assembly.util.SliceMap;
import org.jcvi.jillion.assembly.util.SliceMapBuilder;
import org.jcvi.jillion.assembly.util.consensus.ConicConsensusCaller;
import org.jcvi.jillion.assembly.util.consensus.ConsensusCaller;
import org.jcvi.jillion.assembly.util.consensus.ConsensusResult;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceDataStore;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.residue.nt.ReferenceMappedNucleotideSequence;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.experimental.ncbi.submit.assemblyArchive.AssemblyArchiveWriter.TraceNameLookup;
import org.jcvi.jillion.internal.core.util.GrowableIntArray;

public class AssemblyArchiveWriterBuilder {

	private final File outputDirectory;
	private final QualitySequenceDataStore qualityDataStore;
	private final AssemblyArchiveMetaData sampleMetaData;
	
<span class="nc" id="L73">	private AssemblyArchiveFilenameFactory filenamefactory=null;</span>
<span class="nc" id="L74">	private boolean crossLinkContigSubmission=true;</span>
	
	public AssemblyArchiveWriterBuilder(File outputDirectory, 
			QualitySequenceDataStore qualityDataStore,
			AssemblyArchiveMetaData sampleMetaData
<span class="nc" id="L79">			){</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">		if(outputDirectory==null){</span>
<span class="nc" id="L81">			throw new NullPointerException(&quot;output directory can not be null&quot;);</span>
		}
		
<span class="nc bnc" id="L84" title="All 2 branches missed.">		if(qualityDataStore==null){</span>
<span class="nc" id="L85">			throw new NullPointerException(&quot;quality sequence datastore can not be null&quot;);</span>
		}
<span class="nc bnc" id="L87" title="All 2 branches missed.">		if(sampleMetaData==null){</span>
<span class="nc" id="L88">			throw new NullPointerException(&quot;sampleMetaData datastore can not be null&quot;);</span>
		}
		
<span class="nc" id="L91">		this.outputDirectory = outputDirectory;</span>
<span class="nc" id="L92">		this.qualityDataStore = qualityDataStore;</span>
<span class="nc" id="L93">		this.sampleMetaData = sampleMetaData;</span>
<span class="nc" id="L94">	}</span>
	
	public AssemblyArchiveWriterBuilder writeContigDataToSeparateFiles(AssemblyArchiveFilenameFactory factory){
<span class="nc" id="L97">		filenamefactory= factory;</span>
<span class="nc" id="L98">		return this;</span>
	}
	/**
	 * Should the assembly consensus
	 * be cross linked with the genbank submission's
	 * accession.
	 * The consensus of the assembly is imported from the 
	 * completed genbank submission. 
	 * This is a requirement of the Assembly Archive- 
	 * they only want fully valid and crosslinked contigs uploaded.
	 * If this method is not called, then 
	 * by default cross-linking is set to {@code true}.
	 * @param value if {@code true} then the
	 * ungapped assembly consensus sequence is not specified
	 * in the assembly archive (the gaps will still be written)
	 * and instead a value of &quot;ACCESSION&quot; is used instead
	 * which will tell NCBI to cross link to the genbank accession sequence.
	 * @return this
	 */
	public AssemblyArchiveWriterBuilder crossLinkContigSubmission(boolean value){
<span class="nc" id="L118">		crossLinkContigSubmission = value;</span>
<span class="nc" id="L119">		return this;</span>
	}
	
	public AssemblyArchiveWriter build() throws IOException{
<span class="nc" id="L123">		return new Writer(this);</span>
	}
	
	
	
	private static final class Writer implements AssemblyArchiveWriter{
		
<span class="nc" id="L130">		private static final DateFormat DATE_FORMATTER = new SimpleDateFormat(&quot;MM/dd/yy HH:mm:ss&quot;, Locale.US);</span>
		
		private final File outputDirectory;
		private final AssemblyArchiveFilenameFactory filenamefactory;
		private final boolean crossLinkContigSubmission;
		private final AssemblyArchiveMetaData sampleMetaData;
		
		private final QualitySequenceDataStore qualityDataStore;
		
<span class="nc" id="L139">		private long numberOfTotalReads=0L;</span>
<span class="nc" id="L140">		private long numberOfTotalReadBases=0L;</span>
<span class="nc" id="L141">		private long numberOfTotalConsensusBases =0L;</span>

<span class="nc" id="L143">		private List&lt;String&gt; contigNames = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L144">		private List&lt;File&gt; extraFilesCreated = new ArrayList&lt;File&gt;();</span>
		
		private final File tempFile;
		private final java.io.Writer tempOut;
		
<span class="nc" id="L149">		private AssemblyArchiveType overallType = AssemblyArchiveType.NEW;</span>
		
<span class="nc" id="L151">		private static final String EOL = String.format(&quot;%n&quot;);</span>
		
<span class="nc" id="L153">		public Writer(AssemblyArchiveWriterBuilder builder) throws IOException {</span>
<span class="nc" id="L154">			this.outputDirectory = builder.outputDirectory;</span>
<span class="nc" id="L155">			this.filenamefactory = builder.filenamefactory;</span>
<span class="nc" id="L156">			this.crossLinkContigSubmission = builder.crossLinkContigSubmission;</span>
<span class="nc" id="L157">			this.qualityDataStore = builder.qualityDataStore;</span>
<span class="nc" id="L158">			this.sampleMetaData = builder.sampleMetaData;</span>
			//make directory if it doesn't exist
<span class="nc" id="L160">			IOUtil.mkdirs(outputDirectory);</span>
			
<span class="nc" id="L162">			tempFile = File.createTempFile(&quot;asmArchive&quot;, null, outputDirectory);</span>
<span class="nc" id="L163">			tempOut = IOUtil.createNewBufferedWriter(tempFile, IOUtil.UTF_8_NAME);</span>
<span class="nc" id="L164">		}</span>


		@Override
		public void close() throws IOException {
			//number of bases, avg cov, genomic segments ?
			//type for entire archive (can be computed by all types?)
			//close temp
<span class="nc" id="L172">			tempOut.close();</span>
<span class="nc" id="L173">			File xmlFile = writeAssemblyFile();</span>
<span class="nc" id="L174">			writeManifestFile(xmlFile);	</span>
			
<span class="nc" id="L176">		}</span>


		private File writeManifestFile(File xmlFile) throws IOException {
<span class="nc" id="L180">			File manifestFile = new File(outputDirectory, &quot;MANIFEST&quot;);</span>
<span class="nc" id="L181">			PrintWriter writer = new PrintWriter(IOUtil.createNewBufferedWriter(manifestFile, IOUtil.UTF_8_NAME));</span>
			try{
<span class="nc bnc" id="L183" title="All 2 branches missed.">				for(File f : extraFilesCreated){</span>
<span class="nc" id="L184">					writer.printf(&quot;%s: %s%n&quot;, f.getName(), computeMd5(f));</span>
<span class="nc" id="L185">				}</span>
<span class="nc" id="L186">				writer.printf(&quot;%s: %s%n&quot;, xmlFile.getName(), computeMd5(xmlFile));</span>
<span class="nc" id="L187">				return manifestFile;</span>
			}finally{
<span class="nc" id="L189">				IOUtil.closeAndIgnoreErrors(writer);</span>
			}
		}

		private String computeMd5(File f) throws IOException{
			final MessageDigest m;
			try {
<span class="nc" id="L196">				m = MessageDigest.getInstance(&quot;MD5&quot;);				</span>
<span class="nc" id="L197">			} catch (NoSuchAlgorithmException e) {</span>
				//shouldn't happen
<span class="nc" id="L199">				throw new IllegalStateException(&quot;error getting MD5 algorithm&quot;, e);</span>
<span class="nc" id="L200">			}</span>
			//not sure if we need to reset it
			//each time but can't hurt
<span class="nc" id="L203">			m.reset();</span>
<span class="nc" id="L204">			m.update(IOUtil.toByteArray(f));</span>
<span class="nc" id="L205">			byte[] digest = m.digest();</span>
<span class="nc" id="L206">			String hexString =new BigInteger(1, digest).toString(16);</span>
<span class="nc" id="L207">			return padString(hexString);</span>
		}
		/**
		 * Adds leading 0s to hexString if string length is &lt;32.
		 * @param hexString
		 * @return
		 */
		private String padString(String hexString) {
<span class="nc" id="L215">			int length = hexString.length();</span>
<span class="nc" id="L216">			int padding = 32-length;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">			if(padding==0){</span>
<span class="nc" id="L218">				return hexString;</span>
			}
<span class="nc" id="L220">			char[] pads = new char[padding];</span>
<span class="nc" id="L221">			Arrays.fill(pads, '0');</span>
			
<span class="nc" id="L223">			return new StringBuilder(32).append(pads).append(hexString).toString();</span>
		}


		private File writeAssemblyFile()	throws IOException {
			//create main output file
<span class="nc" id="L229">			File xmlFile = new File(outputDirectory, &quot;ASSEMBLY.xml&quot;);</span>
			
<span class="nc" id="L231">			OutputStream out = new BufferedOutputStream(new FileOutputStream(xmlFile));</span>
			try{
<span class="nc" id="L233">				double coverage = numberOfTotalReadBases/(double)numberOfTotalConsensusBases;</span>
<span class="nc" id="L234">				String header = new StringBuilder(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;).append(EOL)</span>
<span class="nc" id="L235">									.append(String.format(&quot;&lt;assembly submitter_reference=\&quot;%s\&quot; type=\&quot;%s\&quot;&gt;%n&quot;, </span>
<span class="nc" id="L236">															sampleMetaData.getSubmitterReference(),</span>
															overallType))
<span class="nc" id="L238">									.append(createTag(&quot;center_name&quot;, sampleMetaData.getCenterName()))</span>
<span class="nc" id="L239">									.append(createTag(&quot;date&quot;, formatDate(sampleMetaData.getSubmissionDate())))</span>
<span class="nc" id="L240">									.append(createTag(&quot;organism&quot;, sampleMetaData.getOrganismName()))</span>
<span class="nc" id="L241">									.append(createTag(&quot;description&quot;, sampleMetaData.getDescription()))</span>
<span class="nc" id="L242">									.append(createTag(&quot;structure&quot;, sampleMetaData.getStructure()))</span>
<span class="nc" id="L243">									.append(createTag(&quot;ncontigs&quot;, contigNames.size()))</span>
<span class="nc" id="L244">									.append(createTag(&quot;nconbases&quot;, numberOfTotalConsensusBases))</span>
<span class="nc" id="L245">									.append(createTag(&quot;ntraces&quot;, numberOfTotalReads))</span>
<span class="nc" id="L246">									.append(createTag(&quot;nbasecalls&quot;, numberOfTotalReadBases))</span>
<span class="nc" id="L247">									.append(createTag(&quot;coverage&quot;, String.format(&quot;%.2f&quot;, coverage)))</span>
<span class="nc" id="L248">										.toString();</span>
<span class="nc" id="L249">				out.write(header.getBytes(IOUtil.UTF_8));</span>
				//re-open and append temp data to file
<span class="nc" id="L251">				InputStream tempIn = new FileInputStream(tempFile);</span>
				try{
<span class="nc" id="L253">					IOUtil.copy(tempIn, out);</span>
				}finally{
<span class="nc" id="L255">					IOUtil.closeAndIgnoreErrors(tempIn);</span>
<span class="nc" id="L256">				}</span>
				//TODO do we need to put readme files here?
<span class="nc" id="L258">				out.write((&quot;&lt;/assembly&gt;&quot;+EOL).getBytes(IOUtil.UTF_8));</span>
				//only delete temp file if everything worked
<span class="nc" id="L260">				IOUtil.delete(tempFile);</span>
<span class="nc" id="L261">				return xmlFile;</span>
			}finally{
<span class="nc" id="L263">				IOUtil.closeAndIgnoreErrors(out);</span>
				
			}
		}

		private static synchronized String formatDate(Date date){
<span class="nc" id="L269">			return DATE_FORMATTER.format(date);</span>
		}

		@Override
		public void write(
				String submitterReference,
				AssemblyArchiveConformation conformation,
				AssemblyArchiveType type, 
				Contig&lt;? extends AssembledRead&gt; superContig,
				TraceNameLookup lookup) throws IOException {
<span class="nc bnc" id="L279" title="All 2 branches missed.">			if(submitterReference==null){</span>
<span class="nc" id="L280">				throw new NullPointerException(&quot;submitter ref can not be null&quot;);</span>
			}
<span class="nc bnc" id="L282" title="All 2 branches missed.">			if(conformation==null){</span>
<span class="nc" id="L283">				throw new NullPointerException(&quot;contig conformation can not be null&quot;);</span>
			}
<span class="nc bnc" id="L285" title="All 2 branches missed.">			if(type==null){</span>
<span class="nc" id="L286">				throw new NullPointerException(&quot;contig submission type can not be null&quot;);</span>
			}
<span class="nc bnc" id="L288" title="All 2 branches missed.">			if(superContig ==null){</span>
<span class="nc" id="L289">				throw new NullPointerException(&quot;super contig can not be null&quot;);</span>
			}
<span class="nc bnc" id="L291" title="All 2 branches missed.">			if(lookup==null){</span>
<span class="nc" id="L292">				throw new NullPointerException(&quot;TraceNameLookup can not be null&quot;);</span>
			}
<span class="nc bnc" id="L294" title="All 2 branches missed.">			if(type !=AssemblyArchiveType.NEW){</span>
<span class="nc" id="L295">				overallType = AssemblyArchiveType.UPDATE;</span>
			}
<span class="nc" id="L297">			contigNames.add(superContig.getId());</span>
			
<span class="nc" id="L299">			writeContigHeader(submitterReference, conformation, type);</span>
<span class="nc" id="L300">			handleConsensus(submitterReference, conformation, type, superContig);</span>
<span class="nc" id="L301">			handleReads(superContig, lookup);</span>
<span class="nc" id="L302">			tempOut.write(String.format(&quot;&lt;/contig&gt;%n&quot;));</span>
<span class="nc" id="L303">		}</span>


		private void handleReads(Contig&lt;? extends AssembledRead&gt; superContig, TraceNameLookup lookup) throws IOException {
<span class="nc" id="L307">			NucleotideSequence consensusSequence =superContig.getConsensusSequence();</span>
			
<span class="nc" id="L309">			SortedSet&lt;AssembledRead&gt; sortedReads = sortReads(superContig, lookup);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">			for(AssembledRead read : sortedReads){</span>
<span class="nc" id="L311">				Range validRange =read.getReadInfo().getValidRange();</span>
<span class="nc" id="L312">				StringBuilder readRecord = new StringBuilder(300);</span>
<span class="nc" id="L313">				long readStart = read.getGappedStartOffset();</span>
<span class="nc" id="L314">				long readEnd = read.getGappedEndOffset();</span>
<span class="nc" id="L315">				ReferenceMappedNucleotideSequence readSequence = read.getNucleotideSequence();</span>
<span class="nc" id="L316">				List&lt;Integer&gt; readGapOffsets =readSequence.getGapOffsets();</span>
				
<span class="nc" id="L318">				readRecord.append(&quot;&lt;trace&gt;&quot;).append(EOL)</span>
						
<span class="nc" id="L320">						.append(createTag(&quot;trace_name&quot;,lookup.getTraceNameByContigReadId(read.getId()), 1))</span>
<span class="nc" id="L321">							.append(createTag(&quot;nbasecalls&quot;, readSequence.getUngappedLength(),1))</span>
<span class="nc" id="L322">							.append(&quot;\t&lt;valid&gt;&quot;).append(EOL)</span>
<span class="nc" id="L323">								.append(createTag(&quot;start&quot;, validRange.getBegin()+1, 2))</span>
<span class="nc" id="L324">								.append(createTag(&quot;stop&quot;, validRange.getEnd()+1, 2))</span>
<span class="nc" id="L325">							.append(&quot;\t&lt;/valid&gt;&quot;).append(EOL)</span>
							//denote the gapped coordinates 1-based into the consensus
<span class="nc" id="L327">							.append(String.format(&quot;\t&lt;tiling direction = \&quot;%s\&quot;&gt;&quot;, read.getDirection())).append(EOL)</span>
<span class="nc" id="L328">								.append(createTag(&quot;start&quot;, readStart+1, 2))</span>
<span class="nc" id="L329">								.append(createTag(&quot;stop&quot;, readEnd+1, 2))</span>
<span class="nc" id="L330">							.append(&quot;\t&lt;/tiling&gt;&quot;).append(EOL)</span>
							//denote the consensus range of the trace in the ungapped consensus 
<span class="nc" id="L332">							.append(&quot;\t&lt;traceconsensus&gt;&quot;).append(EOL)</span>
<span class="nc" id="L333">							.append(createTag(&quot;start&quot;, consensusSequence.getUngappedOffsetFor((int)readStart)+1, 2))</span>
<span class="nc" id="L334">								.append(createTag(&quot;stop&quot;, consensusSequence.getUngappedOffsetFor((int)readEnd)+1, 2))</span>
<span class="nc" id="L335">							.append(&quot;\t&lt;/traceconsensus&gt;&quot;).append(EOL);</span>
							//only print gap offsets if we have any
<span class="nc bnc" id="L337" title="All 2 branches missed.">							if(!readGapOffsets.isEmpty()){</span>
<span class="nc" id="L338">								readRecord.append(createTag(&quot;ntracegaps&quot;, readGapOffsets.size(), 1))</span>
<span class="nc" id="L339">											.append(String.format(&quot;\t&lt;tracegaps source=\&quot;INLINE\&quot;&gt;%s&lt;/tracegaps&gt;%n&quot;,</span>
<span class="nc" id="L340">														createDeltaGapString(readGapOffsets)));</span>
							}
<span class="nc" id="L342">							readRecord.append(&quot;&lt;/trace&gt;&quot;).append(EOL)</span>
							;	
				
<span class="nc" id="L345">				tempOut.write(readRecord.toString());</span>
<span class="nc" id="L346">			}</span>
			
<span class="nc" id="L348">		}</span>


		private SortedSet&lt;AssembledRead&gt; sortReads(
				Contig&lt;? extends AssembledRead&gt; superContig,
				TraceNameLookup lookup) {
<span class="nc" id="L354">			SortedSet&lt;AssembledRead&gt; sortedReads = new TreeSet&lt;AssembledRead&gt;(new ReadSorter(lookup));</span>
<span class="nc" id="L355">			StreamingIterator&lt;? extends AssembledRead&gt; readIter = superContig.getReadIterator();</span>
			try{
<span class="nc bnc" id="L357" title="All 2 branches missed.">				while(readIter.hasNext()){</span>
<span class="nc" id="L358">					sortedReads.add(readIter.next());</span>
				}
<span class="nc" id="L360">				return sortedReads;</span>
			}finally{
<span class="nc" id="L362">				IOUtil.closeAndIgnoreErrors(readIter);</span>
			}
			
		}


		private void handleConsensus(String submitterReference,
				AssemblyArchiveConformation conformation,
				AssemblyArchiveType type,
				Contig&lt;? extends AssembledRead&gt; superContig)
				throws IOException, FileNotFoundException {
			
<span class="nc" id="L374">			long numberOfReads = superContig.getNumberOfReads();</span>
<span class="nc" id="L375">			numberOfTotalReads += numberOfReads;</span>
<span class="nc" id="L376">			tempOut.write(createTag(&quot;ntraces&quot;,numberOfReads));</span>
			
<span class="nc" id="L378">			NucleotideSequence consensusSequence = superContig.getConsensusSequence();</span>
<span class="nc" id="L379">			long ungappedLength = consensusSequence.getUngappedLength();</span>
<span class="nc" id="L380">			numberOfTotalConsensusBases+= ungappedLength;</span>
			
<span class="nc" id="L382">			tempOut.write(createTag(&quot;nconbases&quot;,ungappedLength));</span>
			
			//TODO make this more efficient?
<span class="nc" id="L385">			long numberOfReadBases=getNumberOfReadBases(superContig);</span>
<span class="nc" id="L386">			numberOfTotalReadBases += numberOfReadBases;</span>
<span class="nc" id="L387">			tempOut.write(createTag(&quot;nbasecalls&quot;,numberOfReadBases));</span>
<span class="nc" id="L388">			List&lt;Integer&gt; gapOffsets = consensusSequence.getGapOffsets();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">			if(!gapOffsets.isEmpty()){</span>
<span class="nc" id="L390">				tempOut.write(createTag(&quot;ncongaps&quot;, gapOffsets.size()));</span>
			}
<span class="nc" id="L392">			String deltaGapString = createDeltaGapString(gapOffsets);</span>
<span class="nc" id="L393">			String consensusQualities = computeConsensusQualities(superContig);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">			if(writeContigDataToSeparateFiles()){</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">				if(!gapOffsets.isEmpty()){</span>
<span class="nc" id="L396">					String consensusGapFilename = filenamefactory.createConsensusGapFileNameFor(superContig);</span>
<span class="nc" id="L397">					File consensusGapFile = new File(outputDirectory, consensusGapFilename);</span>
<span class="nc" id="L398">					extraFilesCreated.add(consensusGapFile);</span>
					
<span class="nc" id="L400">					writeSourceFile(consensusGapFile, deltaGapString);</span>
<span class="nc" id="L401">					tempOut.write(String.format(&quot;&lt;congaps source=\&quot;FILE\&quot;&gt;%s&lt;/congaps&gt;%n&quot;,consensusGapFile.getName()));</span>
					
				}
<span class="nc" id="L404">				String consensusQualFilename = filenamefactory.createConsensusQualityFileNameFor(superContig);</span>
<span class="nc" id="L405">				File consensusQualFile = new File(outputDirectory, consensusQualFilename);</span>
<span class="nc" id="L406">				extraFilesCreated.add(consensusQualFile);</span>
				
<span class="nc" id="L408">				writeSourceFile(consensusQualFile, consensusQualities);</span>
				
				
<span class="nc bnc" id="L411" title="All 2 branches missed.">				if(crossLinkContigSubmission){</span>
<span class="nc" id="L412">					tempOut.write(String.format(&quot;&lt;consensus source=\&quot;ACCESSION\&quot;&gt;&lt;/consensus&gt;%n&quot;));</span>
				}else{
<span class="nc" id="L414">					String consensusFilename = filenamefactory.createConsensusSequenceFileNameFor(superContig);</span>
<span class="nc" id="L415">					File consensusFile = new File(outputDirectory, consensusFilename);</span>
<span class="nc" id="L416">					extraFilesCreated.add(consensusFile);</span>
<span class="nc" id="L417">					writeSourceFile(consensusFile, new NucleotideSequenceBuilder(consensusSequence).ungap().toString());</span>
				}
<span class="nc" id="L419">				tempOut.write(String.format(&quot;&lt;conqualities source=\&quot;FILE\&quot;&gt;%s&lt;/conqualities&gt;%n&quot;,consensusQualFile.getName()));</span>
				
<span class="nc" id="L421">			}else{</span>
				//inline everything
<span class="nc bnc" id="L423" title="All 2 branches missed.">				if(!gapOffsets.isEmpty()){</span>
<span class="nc" id="L424">					tempOut.write(String.format(&quot;&lt;congaps source=\&quot;INLINE\&quot;&gt;%s&lt;/congaps&gt;%n&quot;,deltaGapString));</span>
				}
<span class="nc bnc" id="L426" title="All 2 branches missed.">				if(crossLinkContigSubmission){</span>
<span class="nc" id="L427">					tempOut.write(String.format(&quot;&lt;consensus source=\&quot;ACCESSION\&quot;&gt;&lt;/consensus&gt;%n&quot;));</span>
				}else{
<span class="nc" id="L429">					tempOut.write(String.format(&quot;&lt;consensus source=\&quot;INLINE\&quot;&gt;%s&lt;/consensus&gt;%n&quot;, </span>
<span class="nc" id="L430">							new NucleotideSequenceBuilder(consensusSequence).ungap().toString()));</span>
				}
<span class="nc" id="L432">				tempOut.write(String.format(&quot;&lt;conqualities source=\&quot;INLINE\&quot;&gt;%s&lt;/conqualities&gt;%n&quot;,consensusQualities));</span>
			}
<span class="nc" id="L434">		}</span>
		
		private String computeConsensusQualities(
				Contig&lt;?&gt; superContig) {
<span class="nc bnc" id="L438" title="All 2 branches missed.">			if(superContig instanceof AceContig){</span>
				//already computed
<span class="nc" id="L440">				QualitySequence quals= ((AceContig)superContig).getConsensusQualitySequence();</span>
<span class="nc" id="L441">				StringBuilder builder = new StringBuilder((int)quals.getLength()*5);</span>
<span class="nc" id="L442">				Iterator&lt;PhredQuality&gt; qualIter = quals.iterator();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">				if(qualIter.hasNext()){</span>
					
				}
<span class="nc bnc" id="L446" title="All 2 branches missed.">				while(qualIter.hasNext()){</span>
<span class="nc" id="L447">					builder.append(&quot; &quot; +qualIter.next().getQualityScore());</span>
				}
<span class="nc" id="L449">				return builder.toString();</span>
			}
			
			//have to compute it
<span class="nc" id="L453">			SliceMap sliceMap = new SliceMapBuilder&lt;&gt;(superContig, qualityDataStore)</span>
<span class="nc" id="L454">									.build();</span>
<span class="nc" id="L455">			NucleotideSequence consensusSequence = superContig.getConsensusSequence();</span>
<span class="nc" id="L456">			GrowableIntArray gapOffsets =new GrowableIntArray(consensusSequence.getGapOffsets());</span>
			
<span class="nc" id="L458">			StringBuilder builder = new StringBuilder((int)consensusSequence.getLength()*5);</span>
<span class="nc" id="L459">			ConsensusCaller consensusCaller = new ConicConsensusCaller(PhredQuality.valueOf(30));</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">			for(int i=0; i&lt;sliceMap.getSize(); i++){</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">				if(gapOffsets.binarySearch(i)&lt;0){</span>
					//not a gap
<span class="nc" id="L463">					ConsensusResult consensus = consensusCaller.callConsensus(sliceMap.getSlice(i));</span>
<span class="nc" id="L464">					builder.append(&quot; &quot; +consensus.getConsensusQuality());</span>
				}
			}
			//remove leading space?
<span class="nc" id="L468">			return builder.substring(1);</span>
		}


		private void writeSourceFile(File file,
				String data) throws IOException {
<span class="nc" id="L474">			PrintWriter pw = new PrintWriter(IOUtil.createNewBufferedWriter(file, IOUtil.UTF_8_NAME));</span>
			//legacy Perl code didn't put new line at end of file
			//so we won't either
<span class="nc" id="L477">			pw.print(data);</span>
<span class="nc" id="L478">			pw.close();</span>
			
<span class="nc" id="L480">		}</span>


		private boolean writeContigDataToSeparateFiles(){
<span class="nc bnc" id="L484" title="All 2 branches missed.">			return filenamefactory!=null;</span>
		}
		


		private long getNumberOfReadBases(
				Contig&lt;? extends AssembledRead&gt; superContig) {
<span class="nc" id="L491">			StreamingIterator&lt;? extends AssembledRead&gt; readIter = superContig.getReadIterator();</span>
<span class="nc" id="L492">			long numberOfReadBases=0L;</span>
			try{
<span class="nc bnc" id="L494" title="All 2 branches missed.">				while(readIter.hasNext()){</span>
<span class="nc" id="L495">					numberOfReadBases+= readIter.next().getNucleotideSequence().getUngappedLength();</span>
				}
			}finally{
<span class="nc" id="L498">				IOUtil.closeAndIgnoreErrors(readIter);</span>
<span class="nc" id="L499">			}</span>
<span class="nc" id="L500">			return numberOfReadBases;</span>
		}

		private String createDeltaGapString(List&lt;Integer&gt; gapOffsets) {
<span class="nc" id="L504">	        int previous=0;</span>
<span class="nc" id="L505">	        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">	        for(Integer index : gapOffsets){</span>
<span class="nc" id="L507">	            sb.append(index - previous);</span>
<span class="nc" id="L508">	            sb.append(' ');</span>
<span class="nc" id="L509">	            previous = index+1;</span>
<span class="nc" id="L510">	        }</span>
<span class="nc" id="L511">	        return sb.toString().trim();</span>
	    }

		private void writeContigHeader(String submitterReference,
				AssemblyArchiveConformation conformation,
				AssemblyArchiveType type) throws IOException{
<span class="nc" id="L517">			tempOut.write(String.format(</span>
					&quot;&lt;contig submitter_reference=\&quot;%s\&quot; conformation=\&quot;%s\&quot; type =\&quot;%s\&quot;&gt;%n&quot;,
					submitterReference,
					conformation,
					type
					));
<span class="nc" id="L523">		}</span>
		private static String createTag(String field, int value, int level){
<span class="nc" id="L525">			return createTag(field, Integer.toString(value),level);</span>
		}
		private static String createTag(String field, int value){
<span class="nc" id="L528">			return createTag(field,value,0);</span>
		}
		private static String createTag(String field, long value, int level){
<span class="nc" id="L531">			return createTag(field, Long.toString(value),level);</span>
		}
		private static String createTag(String field, long value){
<span class="nc" id="L534">			return createTag(field, value,0);</span>
		}
		private static String createTag(String field, String value){
<span class="nc" id="L537">			return createTag(field, value,0);</span>
		}
		private static String createTag(String field, String value, int level){
<span class="nc" id="L540">			StringBuilder builder =  new StringBuilder(field.length() + value.length()+6 );</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">			for(int i=0; i&lt;level; i++){</span>
<span class="nc" id="L542">				builder.append('\t');</span>
			}
<span class="nc" id="L544">	        return builder.append('&lt;').append(field).append('&gt;')</span>
<span class="nc" id="L545">	                    .append(value)</span>
<span class="nc" id="L546">            .append(&quot;&lt;/&quot;).append(field).append('&gt;')</span>
<span class="nc" id="L547">            .append(EOL)</span>
<span class="nc" id="L548">            .toString();</span>
	    }
		
		
	}
	
	
	public static interface AssemblyArchiveFilenameFactory{
		String createConsensusGapFileNameFor(Contig&lt;?&gt; contig);
		
		String createConsensusQualityFileNameFor(Contig&lt;?&gt; contig);
		
		String createConsensusSequenceFileNameFor(Contig&lt;?&gt; contig);
	}
	/**
	 * Sort reads by the method specified in the Assembly Archive RFC.
	 * 
	 * Traces are listed in order of their occurrence in the contig's tiling.
	 *  The first order is by trace.tiling.start, 
	 *  then by length of the tiling range 
	 *  (shortest first), else by trace.ti, else by trace.trace_name. 
	 * @author dkatzel
	 *
	 */
	private static class ReadSorter implements Comparator&lt;AssembledRead&gt;{

		private final TraceNameLookup lookup;
		
<span class="nc" id="L576">		public ReadSorter(TraceNameLookup lookup) {</span>
<span class="nc" id="L577">			this.lookup = lookup;</span>
<span class="nc" id="L578">		}</span>

		@Override
		public int compare(AssembledRead o1, AssembledRead o2) {
<span class="nc" id="L582">			int rangeCmp =Range.Comparators.ARRIVAL.compare(o1.asRange(), o2.asRange());</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">			if(rangeCmp !=0){</span>
<span class="nc" id="L584">				return rangeCmp;</span>
			}
<span class="nc" id="L586">			String o1Ti =lookup.getTraceNameByContigReadId(o1.getId());</span>
			
<span class="nc" id="L588">			String o2Ti =lookup.getTraceNameByContigReadId(o2.getId());</span>
<span class="nc" id="L589">			int tiCmp = o1Ti.compareTo(o2Ti);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">			if(tiCmp !=0){</span>
<span class="nc" id="L591">				return tiCmp;</span>
			}
<span class="nc" id="L593">			return o1.getId().compareTo(o2.getId());</span>
		}
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>