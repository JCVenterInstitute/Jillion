<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractFastaRecordWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.shared.fasta</a> &gt; <span class="el_source">AbstractFastaRecordWriter.java</span></div><h1>AbstractFastaRecordWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.shared.fasta;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Objects;

import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.fasta.FastaRecord;
import org.jcvi.jillion.fasta.FastaWriter;
import org.jcvi.jillion.internal.core.io.OutputStreamFactory;
import org.jcvi.jillion.internal.fasta.FastaUtil;


public  abstract class AbstractFastaRecordWriter&lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S,T&gt;&gt; implements FastaWriter&lt;S, T, F&gt;{

	private final Writer writer;
	private final int numberOfResiduesPerLine;
	private final boolean hasSymbolSeparator;
	private final String eol;
	/**
	 * Lock object used to synchronize the recordBuffer.
	 * This is a performance improvement to re-use the same
	 * StringBuilder as a buffer for every record we write.
	 */
<span class="fc" id="L53">	private final Object lock = new Object();</span>
	
<span class="fc" id="L55">	private final StringBuilder recordBuffer = new StringBuilder(2000);</span>
	
	protected AbstractFastaRecordWriter(OutputStream out,
<span class="fc" id="L58">			int numberOfResiduesPerLine, Charset charSet, String eol) {</span>
		//wrap in OutputStream Writer to do char encodings
		//for us.  If we did String#getBytes(Charset) instead
		//for each write call that could put unwanted
		//char encoding headers in each record
		//which would be incorrect.  This way
		//the char encoding headers (if any) will
		//only appear at the beginning of the inputstream
<span class="fc" id="L66">		this.writer =  new BufferedWriter(new OutputStreamWriter(out,charSet));</span>
<span class="fc" id="L67">		this.numberOfResiduesPerLine = numberOfResiduesPerLine;</span>
<span class="fc" id="L68">		this.hasSymbolSeparator = hasSymbolSeparator();</span>
<span class="fc" id="L69">		this.eol = eol;</span>
<span class="fc" id="L70">	}</span>
	
	@Override
	public final void close() throws IOException {
		//just incase the implementation of
		//OutputStream is buffering we need to explicitly
		//call flush
<span class="fc" id="L77">		writer.flush();</span>
<span class="fc" id="L78">		writer.close();		</span>
<span class="fc" id="L79">	}</span>

	@Override
	public final void write(F record) throws IOException {
<span class="fc" id="L83">		write(record.getId(),record.getSequence(),record.getComment());</span>
		
<span class="fc" id="L85">	}</span>

	@Override
	public final void write(String id, T sequence)
			throws IOException {
<span class="fc" id="L90">		write(id,sequence,null);		</span>
<span class="fc" id="L91">	}</span>

	@Override
	public final void write(String id, T sequence,
			String optionalComment) throws IOException {
<span class="fc" id="L96">		String formattedString = toFormattedString(id, sequence, optionalComment);</span>
<span class="fc" id="L97">		writer.write(formattedString);</span>
		
<span class="fc" id="L99">	}</span>

    private String toFormattedString(String id, T sequence, String comment) {
       // int bufferSize = computeFormattedBufferSize(id, sequence, comment);
        String ret;
<span class="fc" id="L104">        synchronized(lock){</span>
<span class="fc" id="L105">            recordBuffer.setLength(0);</span>
<span class="fc" id="L106">            appendDefline(id, comment, recordBuffer);</span>
<span class="fc" id="L107">            appendRecordBody(sequence, recordBuffer);</span>
<span class="fc" id="L108">            ret = recordBuffer.toString();</span>
        
<span class="pc" id="L110">        }</span>
<span class="fc" id="L111">        return ret;</span>
    }

    private void appendRecordBody(T sequence, final StringBuilder record) {
<span class="fc" id="L115">        Iterator&lt;S&gt; iter = sequence.iterator();</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (iter.hasNext()) {</span>
<span class="fc" id="L118">            record.append(getStringRepresentationFor(iter.next()));</span>
        }
<span class="fc" id="L120">        int count = 1;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc bfc" id="L122" title="All 4 branches covered.">            if (numberOfResiduesPerLine != AbstractBuilder.ALL_ON_ONE_LINE</span>
                    &amp;&amp; count % numberOfResiduesPerLine == 0) {
<span class="fc" id="L124">                record.append(eol);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            } else if (hasSymbolSeparator) {</span>
<span class="fc" id="L126">                record.append(getSymbolSeparator());</span>
            }
<span class="fc" id="L128">            record.append(getStringRepresentationFor(iter.next()));</span>
<span class="fc" id="L129">            count++;</span>
        }
<span class="fc" id="L131">        record.append(eol);</span>
<span class="fc" id="L132">    }</span>

	protected abstract boolean hasSymbolSeparator();

	protected abstract String getSymbolSeparator();

	protected abstract String getStringRepresentationFor(S symbol);
	
	private void appendDefline(String id, String comment,
			final StringBuilder record) {
<span class="fc" id="L142">		record.append(FastaUtil.getHeaderPrefix()).append(id);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (comment != null) {</span>
<span class="fc" id="L144">        	record.append(' ').append(comment);</span>
        }
<span class="fc" id="L146">        record.append(eol);</span>
<span class="fc" id="L147">	}</span>
    
 
    
    public abstract static class AbstractBuilder&lt;S, T extends Sequence&lt;S&gt;,F extends FastaRecord&lt;S,T&gt;, W extends FastaWriter&lt;S, T, F&gt;, B extends AbstractBuilder&lt;S,T,F,W, B&gt;&gt; implements org.jcvi.jillion.core.util.Builder&lt;W&gt;{
		
    	public static final int ALL_ON_ONE_LINE =-1;
    	
<span class="fc" id="L155">		private static final Charset DEFAULT_CHARSET = IOUtil.UTF_8;</span>
<span class="fc" id="L156">		private static final String DEFAULT_LINE_SEPARATOR = FastaUtil.getLineSeparator();</span>
		
		private static final int DEFAULT_CACHE_SIZE =1024;
		
		private final OutputStream out;
		private int numberOfSymbolsPerLine;
<span class="fc" id="L162">		private String eol = DEFAULT_LINE_SEPARATOR;</span>
		
<span class="fc" id="L164">		private Comparator&lt;F&gt; comparator = null;</span>
		private Integer inMemoryCacheSize;
		private File tmpDir;
		
<span class="fc" id="L168">		private Charset charSet = DEFAULT_CHARSET;</span>
		
		
		/**
		 * Create a new Builder that will use
		 * the given {@link OutputStream} to write
		 * out the fasta records.
		 * @param out the {@link OutputStream} to use;
		 * can not be null.
		 * @throws NullPointerException if out is null.
		 */
<span class="fc" id="L179">		public AbstractBuilder(OutputStream out){</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">			if(out==null){</span>
<span class="fc" id="L181">				throw new NullPointerException(&quot;outputstream can not be null&quot;);</span>
			}
<span class="fc" id="L183">			this.out = out;</span>
<span class="fc" id="L184">			numberPerLine(getDefaultNumberOfSymbolsPerLine());</span>
<span class="fc" id="L185">		}</span>
		
		protected abstract B getThis();
		/**
		 * Get the number of symbols
		 * that should be printed on each line
		 * of the fasta record body.
		 * @return a number &gt;=1.
		 */
		protected abstract int getDefaultNumberOfSymbolsPerLine();
		/**
		 * Create a new Builder that will use
		 * the given File to write
		 * out the fasta records.  Any contents
		 * that previously existed in this file
		 * will be overwritten.
		 * @param outputFile the File to use;
		 * can not be null.
		 * 
		 * Since 5.3, if the file extension is either {@code &quot;.gz&quot; or &quot;.zip&quot;}
		 * then the writer will automatically compress the output for you.
		 * 
		 * @throws NullPointerException if outputFile is null.
		 * @throws IOException if the file exists but 
		 * is a directory rather than a regular file, 
		 * does not exist but cannot be created, 
		 * or cannot be opened for any other reason.
		 */
<span class="fc" id="L213">		public AbstractBuilder(File outputFile) throws IOException{</span>
			
<span class="fc" id="L215">			this.out = OutputStreamFactory.create(outputFile);</span>
<span class="fc" id="L216">			numberPerLine(getDefaultNumberOfSymbolsPerLine());</span>
<span class="fc" id="L217">		}</span>
		
		
		/**
		 * Change the {@link Charset} used
		 * to write out the fasta record.
		 * If this method is not called,
		 * then the CharSet will default to
		 * UTF-8.
		 * @param charset the {@link Charset} to use;
		 * can not be null.
		 * @return this.
		 * @throws NullPointerException if charset is null.
		 */
		public final B charset(Charset charset){
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">			if(charset ==null){</span>
<span class="nc" id="L233">				throw new NullPointerException(&quot;charset can not be null&quot;);</span>
			}
<span class="fc" id="L235">			this.charSet=charset;</span>
<span class="fc" id="L236">			return getThis();</span>
		}
		/**
		 * Change the end of line separator String.
		 * &lt;br/&gt;
		 * &lt;strong&gt;Note:&lt;/strong&gt; This method should be used with caution.
		 * Many fasta parsers will only expect lines to be terminated
		 * with '\n'.
		 * @param eol the end of line string to use to denote
		 * end of lines; can not be empty.  If set to {@code null},
		 * then the default '\n' is used.
		 * @return this.
		 */
		public final B lineSeparator(String eol){
<span class="fc bfc" id="L250" title="All 2 branches covered.">			if(eol==null){</span>
<span class="fc" id="L251">				this.eol = DEFAULT_LINE_SEPARATOR;</span>
			}else{
<span class="fc bfc" id="L253" title="All 2 branches covered.">				if(eol.isEmpty()){</span>
<span class="fc" id="L254">					throw new IllegalArgumentException(&quot;line separator can not be empty&quot;);</span>
				}
<span class="fc" id="L256">				this.eol = eol;</span>
			}
<span class="fc" id="L258">			return getThis();</span>
		}
		/**
		 * Change the number of bases per line
		 * to write for each fasta record.
		 * If this method is not called,
		 * then the a default value will be used.
		 * If {@link #allBasesOnOneLine()}
		 * is also called, then whichever method is called last
		 * &quot;wins&quot;.
		 * @param numberPerLine the basesPerLine to use
		 * must be &gt;=1.
		 * @return this.
		 * @throws IllegalArgumentException if basesPerLine &lt;1.
		 * @see #allBasesOnOneLine()
		 */
		public final B numberPerLine(int numberPerLine){
<span class="fc bfc" id="L275" title="All 2 branches covered.">			if(numberPerLine&lt;1){</span>
<span class="fc" id="L276">				throw new IllegalArgumentException(&quot;number per line must be &gt;=1&quot;);</span>
			}
<span class="fc" id="L278">			numberOfSymbolsPerLine = numberPerLine;</span>
<span class="fc" id="L279">			return getThis();</span>
		}
		/**
		 * Write all the bases on one line instead of allowing
		 * the possibility of multiple lines. If {@link #numberPerLine(int)}
		 * is also called, then whichever method is called last
		 * &quot;wins&quot;.
		 * @return this.
		 * @see #numberPerLine(int)
		 */
		public final B allBasesOnOneLine(){
<span class="fc" id="L290">			numberOfSymbolsPerLine = ALL_ON_ONE_LINE;</span>
<span class="fc" id="L291">			return getThis();</span>
		}
		
		/**
		 * Create a new {@link FastaWriter} instance
		 * which uses the parameters supplied to this builder.
		 * @return a new instance of {@link FastaWriter}. 
		 */
		@Override
		public W build() {
<span class="fc" id="L301">			W writer= create(out, numberOfSymbolsPerLine, charSet,eol);</span>
			
<span class="fc bfc" id="L303" title="All 2 branches covered.">			if(comparator ==null){</span>
				//no sorting
<span class="fc" id="L305">				return writer;</span>
			}
<span class="fc bfc" id="L307" title="All 2 branches covered.">			if(inMemoryCacheSize ==null){</span>
				//use in memory cache only
<span class="fc" id="L309">				return createInMemorySortedWriterWriter(writer, comparator);</span>
			}
<span class="fc" id="L311">			return createTmpDirSortedWriterWriter(writer, comparator, inMemoryCacheSize, tmpDir);</span>
		}
		
		protected abstract W createTmpDirSortedWriterWriter(FastaWriter&lt;S,T,F&gt; delegate, Comparator&lt;F&gt; comparator, int cacheSize, File tmpDir);
		protected abstract W createInMemorySortedWriterWriter(FastaWriter&lt;S,T,F&gt; delegate, Comparator&lt;F&gt; comparator);
		/**
		 * Create a new instance of a {@link FastaWriter}
		 * with the given non-null parameters.
		 * @param out the OutputStream that the new writer will use
		 * to output the fasta data; will never be null.
		 * @param numberOfResiduesPerLine the number of residues per line 
		 * that should be written to the file.  If a sequence length
		 * is more than this number, then the sequence should be split
		 * over several lines, each line never exceeding this value.
		 * @param charSet the {@link Charset} to encode the output to,
		 * usually UTF-8.
		 * @return a new {@link FastaWriter}; can not be null.
		 */
		protected abstract W create(OutputStream out, int numberOfResiduesPerLine, Charset charSet, String eol);
		
		
		/**
		 * Write out the {@link FastaRecord}s written by this writer
		 * sorted by the specified {@link Comparator} but do all the sorting in memory.
		 * All of the records will be cached in memory so the output can be written sorted
		 * when the {@link FastaWriter#close()} method is called.  It is not recommended
		 * to use this method if a large number of records will be written because
		 * an {@link OutOfMemoryError} may occur.
		 * 
		 * @param comparator the {@link Comparator} to use to sort the {@link FastaRecord}s;
		 * can not be null.
		 * 
		 * @return this
		 * 
		 * @throws NullPointerException if comparator is null.
		 * 
		 * @since 5.0
		 */
		public B sortInMemoryOnly(Comparator&lt;F&gt; comparator){
<span class="fc" id="L350">		    Objects.requireNonNull(comparator);</span>
<span class="fc" id="L351">		    this.comparator = comparator;</span>
<span class="fc" id="L352">		    this.inMemoryCacheSize = null;</span>
<span class="fc" id="L353">		    this.tmpDir = null;</span>
		    
<span class="fc" id="L355">		    return getThis();</span>
		}
		/**
                 * Write out the {@link FastaRecord}s written by this writer
                 * sorted by the specified {@link Comparator} using a combination of 
                 * in memory sorting and writing out sorted temporary files 
                 * using the default in memory cache size (currently 1024 records).
                 * 
                 * &lt;p/&gt;
                 * This is the same as {@link #sort(Comparator, int) sort(comparator, 1024}
                 * which uses the default temp area to make temp files.
                 * 
                 * @param comparator the {@link Comparator} to use to sort the {@link FastaRecord}s;
                 * can not be null.
                 * 
                 * @return this.
                 * 
                 * @throws NullPointerException if comparator is null.
                 * 
                 * 
                 * @since 5.3
                 */
                public B sort(Comparator&lt;F&gt; comparator){
<span class="nc" id="L378">                    return sort(comparator, DEFAULT_CACHE_SIZE);</span>
                }
                
		/**
		 * Write out the {@link FastaRecord}s written by this writer
		 * sorted by the specified {@link Comparator} using a combination of 
		 * in memory sorting and writing out sorted temporary files.
		 * 
		 * &lt;p/&gt;
		 * This is the same as {@link #sort(Comparator, int, File) sort(comparator, inMemCacheSize, null)}
		 * which uses the default temp area to make temp files.
		 * 
		 * @param comparator the {@link Comparator} to use to sort the {@link FastaRecord}s;
		 * can not be null.
		 * @param inMemoryCacheSize the in memory cache size to use; must be positive.
		 * 
		 * @return this.
		 * 
		 * @throws NullPointerException if comparator is null.
		 * 
		 * @throws IllegalArgumentException if inMemoryCacheSize &lt; 1.
		 * 
		 * @since 5.0
		 */
		public B sort(Comparator&lt;F&gt; comparator, int inMemoryCacheSize){
<span class="fc" id="L403">		    return sort(comparator, inMemoryCacheSize, null);</span>
		}
		/**
		 * Write out the {@link FastaRecord}s written by this writer
		 * sorted by the specified {@link Comparator} using a combination of 
		 * in memory sorting and writing out sorted temporary files.
		 * 
		 * An in memory cache similar of the specified size will be created
		 * and whenever the cache fills, the sorted cache contents will be written to a temp file
		 * in the specified tmpDir and the cache cleared out to make room for more records to write.
		 * There may be multiple temp files written depending on how many {@link FastaRecord}s are 
		 * passed to the Writer.
		 * 
		 * Once {@link FastaWriter#close()} has been called, the contents of the in memory cache,
		 * and any temp files written out are merged and written sorted to the final output file.
		 * 
		 * &lt;p&gt;
		 * If any files get written to temp files under {@code dir},
		 * they will be deleted when the writer is closed.  However {@code dir}
		 * itself will not be deleted so feel free to provide non-temp directories as well.
		 * &lt;/p&gt;
		 * 
		 * @param comparator the {@link Comparator} to use to sort the {@link FastaRecord}s;
		 * can not be null.
		 * @param inMemoryCacheSize the in memory cache size to use; must be positive.
		 * 
		 * @param dir the directory to write files to; if set to {@code null}
		 * then the default system temporary directory is used.  If the value is not null,
		 * then it must be a directory that already exists.
		 * 
		 * @return this.
		 * 
		 * @throws NullPointerException if comparator is null.
		 * 
		 * @throws IllegalArgumentException if inMemoryCacheSize &lt; 1,
		 * 			or if a non-null dir does not exist or is not a directory.
		 * 
		 * @since 5.0
		 */
		public B sort(Comparator&lt;F&gt; comparator, int inMemoryCacheSize, File dir){
<span class="fc" id="L443">		    Objects.requireNonNull(comparator);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		    if(inMemoryCacheSize &lt;1){</span>
<span class="nc" id="L445">		        throw new IllegalArgumentException(&quot;in memory cache size must be positive&quot;);</span>
		    }
		    
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">		    if(dir !=null){</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">		    	if(!dir.exists()){	    </span>
<span class="nc" id="L450">		    		throw new IllegalArgumentException(&quot;tmpDir does not exist: &quot; + dir.getAbsolutePath());</span>
		    	}
<span class="nc bnc" id="L452" title="All 2 branches missed.">		    	if(!dir.isDirectory()){</span>
<span class="nc" id="L453">		    		throw new IllegalArgumentException(&quot;tmpDir is not a directory: &quot; + dir.getAbsolutePath());</span>
		    	}
		    }
<span class="fc" id="L456">	            this.comparator = comparator;</span>
<span class="fc" id="L457">	            this.inMemoryCacheSize = inMemoryCacheSize;</span>
<span class="fc" id="L458">	            this.tmpDir = dir;</span>
<span class="fc" id="L459">		    return getThis();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>