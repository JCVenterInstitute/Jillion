<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CasFileTransformationService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.clc.cas.transform</a> &gt; <span class="el_source">CasFileTransformationService.java</span></div><h1>CasFileTransformationService.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.clc.cas.transform;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Objects;

import org.jcvi.jillion.assembly.AssemblyTransformationService;
import org.jcvi.jillion.assembly.AssemblyTransformer;
import org.jcvi.jillion.assembly.clc.cas.AbstractAlignedReadCasVisitor;
import org.jcvi.jillion.assembly.clc.cas.CasFileInfo;
import org.jcvi.jillion.assembly.clc.cas.CasFileParser;
import org.jcvi.jillion.assembly.clc.cas.CasFileVisitor;
import org.jcvi.jillion.assembly.clc.cas.CasGappedReferenceDataStore;
import org.jcvi.jillion.assembly.clc.cas.CasGappedReferenceDataStoreBuilderVisitor;
import org.jcvi.jillion.assembly.clc.cas.CasParser;
import org.jcvi.jillion.assembly.clc.cas.CasUtil;
import org.jcvi.jillion.assembly.clc.cas.read.CasPlacedRead;
import org.jcvi.jillion.core.datastore.DataStoreEntry;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.datastore.DataStoreProviderHint;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.fasta.nt.NucleotideFastaDataStore;
import org.jcvi.jillion.fasta.nt.NucleotideFastaFileDataStoreBuilder;
import org.jcvi.jillion.trace.Trace;
import org.jcvi.jillion.trace.fastq.FastqFileDataStore;
import org.jcvi.jillion.trace.fastq.FastqFileDataStoreBuilder;
import org.jcvi.jillion.trace.fastq.FastqQualityCodec;
import org.jcvi.jillion.trace.sff.SffFileDataStoreBuilder;

public class CasFileTransformationService implements AssemblyTransformationService{

    @FunctionalInterface
    public interface FastqDataStoreSupplier{
        FastqFileDataStore apply(File fastqFile) throws IOException;
    }
    
	private final File chromatDir;
	
	private FastqQualityCodec qualityCodec;
	private final CasParser casParser;
	
	private FastqDataStoreSupplier fastqDataStoreSupplier;
        
	
	public CasFileTransformationService(File casFile) throws IOException{
<span class="fc" id="L69">		this(casFile, null);</span>
<span class="fc" id="L70">	}</span>
<span class="fc" id="L71">	public CasFileTransformationService(File casFile, File chromatDir) throws IOException {</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">		if(casFile ==null){</span>
<span class="nc" id="L73">			throw new NullPointerException(&quot;cas file can not be null&quot;);</span>
		}
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">		if(!casFile.exists()){</span>
<span class="nc" id="L76">			throw new FileNotFoundException(casFile.getAbsolutePath());</span>
		}
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">		if(chromatDir !=null){</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">			if(!chromatDir.exists()){</span>
<span class="nc" id="L80">				throw new FileNotFoundException(chromatDir.getAbsolutePath());</span>
			}
<span class="nc bnc" id="L82" title="All 2 branches missed.">			if(!chromatDir.isDirectory()){</span>
<span class="nc" id="L83">				throw new IOException(&quot;chromat dir must be a directory&quot;+ chromatDir.getAbsolutePath());</span>
			}
		}		
<span class="fc" id="L86">		this.chromatDir = chromatDir;</span>
<span class="fc" id="L87">		this.casParser = CasFileParser.create(casFile, true);</span>
<span class="fc" id="L88">	}</span>
	
	public CasFileTransformationService(CasParser parser) throws IOException{
<span class="nc" id="L91">		this(parser, null);</span>
<span class="nc" id="L92">	}</span>
	
	
	public void setFastqDataStoreSupplier(
	        FastqDataStoreSupplier fastqDataStoreSupplier) {
<span class="nc" id="L97">        this.fastqDataStoreSupplier = fastqDataStoreSupplier;</span>
<span class="nc" id="L98">    }</span>
<span class="nc" id="L99">    public CasFileTransformationService(CasParser parser, File chromatDir) throws IOException{</span>

<span class="nc" id="L101">		Objects.requireNonNull(parser);</span>
<span class="nc" id="L102">		this.casParser = parser;		</span>
<span class="nc" id="L103">		this.chromatDir = chromatDir;</span>
<span class="nc" id="L104">	}</span>

   
    public FastqQualityCodec getQualityCodec() {
<span class="nc" id="L108">		return qualityCodec;</span>
	}
	public void setQualityCodec(FastqQualityCodec qualityCodec) {
<span class="nc" id="L111">		this.qualityCodec = qualityCodec;</span>
<span class="nc" id="L112">	}</span>
	
	protected File getCasDir() {
<span class="nc" id="L115">		return casParser.getWorkingDir();</span>
	}
	protected File getChromatDir() {
<span class="nc" id="L118">		return chromatDir;</span>
	}
	
	@Override
	public final void transform(AssemblyTransformer transformer) throws IOException{
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">		if(transformer == null){</span>
<span class="nc" id="L124">			throw new NullPointerException(&quot;transformer can not be null&quot;);</span>
		}
<span class="fc" id="L126">		CasGappedReferenceDataStoreBuilderVisitor gappedRefVisitor = new CasGappedReferenceDataStoreBuilderVisitor(casParser.getWorkingDir());</span>
		 
		
<span class="fc" id="L129">		casParser.parse(gappedRefVisitor);</span>
		 
<span class="fc" id="L131">		 CasGappedReferenceDataStore gappedReferenceDataStore = gappedRefVisitor.build();</span>
	
<span class="fc" id="L133">		 StreamingIterator&lt;DataStoreEntry&lt;NucleotideSequence&gt;&gt; idIter =null;</span>
		 try{
<span class="fc" id="L135">			 idIter = gappedReferenceDataStore.entryIterator();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">			 while(idIter.hasNext()){</span>
<span class="fc" id="L137">				 DataStoreEntry&lt;NucleotideSequence&gt; entry = idIter.next();</span>
<span class="fc" id="L138">				 transformer.referenceOrConsensus(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L139">			 }</span>
			 
<span class="nc" id="L141">		 }catch(DataStoreException e){</span>
<span class="nc" id="L142">			 throw new IOException(&quot;error getting gapped DataStore elements&quot;, e);</span>
		 }finally{
<span class="pc" id="L144">			 IOUtil.closeAndIgnoreErrors(idIter);</span>
<span class="fc" id="L145">		 }</span>
		 
		 
		 
<span class="fc" id="L149">		 Visitor visitor = new Visitor(casParser.getWorkingDir(), gappedReferenceDataStore, </span>
<span class="fc" id="L150">		         transformer,chromatDir, getFastqDataStoreSupplier());</span>
<span class="fc" id="L151">		 casParser.parse(wrapVisitor(visitor));</span>
<span class="fc" id="L152">		 transformer.endAssembly();</span>
		 
<span class="fc" id="L154">	}</span>
	
	private FastqDataStoreSupplier getFastqDataStoreSupplier() {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if(fastqDataStoreSupplier !=null){</span>
<span class="nc" id="L158">            return fastqDataStoreSupplier;</span>
        }
<span class="fc" id="L160">        final FastqQualityCodec codec = qualityCodec;</span>
<span class="fc" id="L161">        return (file)-&gt;{</span>
<span class="nc" id="L162">            FastqFileDataStoreBuilder builder = new FastqFileDataStoreBuilder(file);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if(codec !=null){</span>
<span class="nc" id="L164">                builder.qualityCodec(codec);</span>
            }
<span class="nc" id="L166">            return builder.hint(DataStoreProviderHint.ITERATION_ONLY)</span>
<span class="nc" id="L167">                            .build();</span>
        };
    }
    protected CasFileVisitor wrapVisitor(final CasFileVisitor transformationVisitor){
<span class="fc" id="L171">		return transformationVisitor;</span>
	}
	
	private static class Visitor extends AbstractAlignedReadCasVisitor{

		private final AssemblyTransformer transformer;
		private final File chromatDir;
		
		private FastqDataStoreSupplier fastqDataStoreSupplier;
		
		public Visitor(File workingDir,  
				CasGappedReferenceDataStore gappedReferenceDataStore,
				AssemblyTransformer transformer,
				File chromatDir,
				FastqDataStoreSupplier fastqDataStoreSupplier) {
<span class="fc" id="L186">			super(workingDir, gappedReferenceDataStore);</span>
<span class="fc" id="L187">			this.transformer = transformer;</span>
<span class="fc" id="L188">			this.chromatDir = chromatDir;</span>
<span class="fc" id="L189">			this.fastqDataStoreSupplier = fastqDataStoreSupplier;</span>
<span class="fc" id="L190">		}</span>

		@Override
		public void visitAssemblyProgramInfo(String name, String version,
				String parameters) {
<span class="fc" id="L195">			transformer.assemblyCommand(name, version, parameters);</span>
<span class="fc" id="L196">			super.visitAssemblyProgramInfo(name, version, parameters);</span>
<span class="fc" id="L197">		}</span>

		@Override
		public void visitReferenceFileInfo(CasFileInfo referenceFileInfo) {
<span class="fc bfc" id="L201" title="All 2 branches covered.">			for(String filename : referenceFileInfo.getFileNames()){</span>
				try {
<span class="fc" id="L203">					File f = CasUtil.getFileFor(this.getWorkingDir(), filename);</span>
<span class="fc" id="L204">					transformer.referenceFile(f.toURI());			</span>
				
<span class="nc" id="L206">				} catch (FileNotFoundException e) {</span>
<span class="nc" id="L207">					throw new IllegalStateException(&quot;reference file not found :&quot; + filename,e );</span>
<span class="fc" id="L208">				}</span>
				
<span class="fc" id="L210">			}</span>
<span class="fc" id="L211">			super.visitReferenceFileInfo(referenceFileInfo);</span>
<span class="fc" id="L212">		}</span>

		@Override
		public void visitReadFileInfo(CasFileInfo readFileInfo) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">			for(String filename : readFileInfo.getFileNames()){</span>
				try {
<span class="fc" id="L218">					File f = CasUtil.getFileFor(this.getWorkingDir(), filename);</span>
<span class="fc" id="L219">					transformer.readFile(f.toURI());			</span>
				
<span class="nc" id="L221">				} catch (FileNotFoundException e) {</span>
<span class="nc" id="L222">					throw new IllegalStateException(&quot;read file not found :&quot; + filename, e);</span>
<span class="fc" id="L223">				}</span>
				
<span class="fc" id="L225">			}</span>
<span class="fc" id="L226">			super.visitReadFileInfo(readFileInfo);</span>
<span class="fc" id="L227">		}</span>

		@Override
		protected void notAligned(Trace currentTrace) {
<span class="fc" id="L231">			ReadData readData = (ReadData)currentTrace;</span>
<span class="fc" id="L232">			transformer.notAligned(readData.getId(),</span>
<span class="fc" id="L233">					readData.getNucleotideSequence(),</span>
<span class="fc" id="L234">					readData.getQualitySequence(),</span>
<span class="fc" id="L235">					readData.getPositions(),</span>
<span class="fc" id="L236">					readData.getUri()</span>
					);
			
<span class="fc" id="L239">		}</span>

		@Override
		protected void aligned(Trace traceOfRead, String referenceId,
				CasPlacedRead read) {
<span class="fc" id="L244">			ReadData readData = (ReadData)traceOfRead;</span>
			
<span class="fc" id="L246">			transformer.aligned(</span>
<span class="fc" id="L247">			readData.getId(),</span>
<span class="fc" id="L248">			readData.getNucleotideSequence(),</span>
<span class="fc" id="L249">			readData.getQualitySequence(),</span>
<span class="fc" id="L250">			readData.getPositions(),</span>
<span class="fc" id="L251">			readData.getUri(),</span>
			
			referenceId,
<span class="fc" id="L254">			read.getGappedStartOffset(),</span>
<span class="fc" id="L255">			read.getDirection(),</span>
<span class="fc" id="L256">			read.getNucleotideSequence(),</span>
<span class="fc" id="L257">			read.getReadInfo()</span>
			);
<span class="fc" id="L259">		}</span>

		@Override
        protected FastqFileDataStore createFastqDataStore(File fastqFile)
                throws IOException {
<span class="nc" id="L264">            return fastqDataStoreSupplier.apply(fastqFile);</span>
                   
        }

        @Override
        protected StreamingIterator&lt;? extends Trace&gt; createIteratorFor(
                FastqFileDataStore datastore) throws DataStoreException {
		    //I think the get() on the optional is safe here
		    //since we are always using real files?
<span class="nc" id="L273">		    return new FastqReadDatadAdaptedIterator(datastore.iterator(), datastore.getFile().get());</span>
        }

      

		@Override
		protected StreamingIterator&lt;? extends Trace&gt; createSffIterator(
				File sffFile) throws DataStoreException, IOException {
			
<span class="nc" id="L282">			return new FlowgramReadDataAdaptedIterator( new SffFileDataStoreBuilder(sffFile).hint(DataStoreProviderHint.ITERATION_ONLY).build().iterator(),</span>
					sffFile);
		}

		@Override
		protected StreamingIterator&lt;? extends Trace&gt; createFastaIterator(
				File fastaFile) throws DataStoreException {
			try{
<span class="fc" id="L290">			NucleotideFastaDataStore datastore = new NucleotideFastaFileDataStoreBuilder(fastaFile)</span>
<span class="fc" id="L291">												.hint(DataStoreProviderHint.ITERATION_ONLY)</span>
<span class="fc" id="L292">												.build();</span>

<span class="pc bpc" id="L294" title="1 of 2 branches missed.">			if(chromatDir ==null){</span>
				//fasta(s) only
<span class="fc" id="L296">				return new FastaReadDataAdaptedIterator(datastore.iterator(), fastaFile);</span>
			}else{
<span class="nc" id="L298">				return new ChromatDirFastaReadDataAdaptedIterator(datastore.iterator(), fastaFile, chromatDir);</span>
			}
<span class="nc" id="L300">			}catch(IOException e){</span>
<span class="nc" id="L301">				throw new DataStoreException(&quot;error parsing fasta file&quot;, e);</span>
			}
		}
		
		
		
	}
}
 
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>