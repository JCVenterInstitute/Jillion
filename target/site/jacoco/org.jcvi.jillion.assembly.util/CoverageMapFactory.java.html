<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CoverageMapFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util</a> &gt; <span class="el_source">CoverageMapFactory.java</span></div><h1>CoverageMapFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 16, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.util;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Stream;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Rangeable;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.iter.ArrayIterator;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;

/**
 * {@code CoverageMapFactory} is a factory class
 * that is able to build various kinds of
 * {@link CoverageMap}s.
 * 
 * @author dkatzel
 *
 */
final class CoverageMapFactory {

	/**
	 * Create a new {@link CoverageMap} using the given
	 * {@link Rangeable}s.
	 * @param elements the elements to create a coverage map of.
	 * @return a new {@link CoverageMap}; never null.
	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
	 */
    public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
            create(Collection&lt;R&gt; elements){
<span class="fc" id="L67">        return new Builder&lt;R&gt;(elements).build();</span>
    }
    /**
	 * Create a new {@link CoverageMap} using the given
	 * {@link Rangeable}s.
	 * @param elements the elements to create a coverage map of.
	 * @return a new {@link CoverageMap}; never null.
	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
	 */
    public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
            create(Collection&lt;R&gt; elements, boolean startAtOrigin){
<span class="fc" id="L78">        return new Builder&lt;R&gt;(elements,startAtOrigin).build();</span>
    }
    /**
   	 * Create a new {@link CoverageMap} using the given
   	 * {@link Rangeable}s but limiting the max coverage
   	 * in the map to {@code maxAllowedCoverage}.  
   	 * @param elements the elements to create a coverage map of.
   	 * @param maxAllowedCoverage Any
   	 * elements that would cause the max coverage to exceed this threshold
   	 * will be ignored.
   	 * @return a new {@link CoverageMap}; never null.
   	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
   	 */
       public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
               create(Collection&lt;R&gt; elements, int maxAllowedCoverage){
<span class="fc" id="L93">    	   return new Builder&lt;R&gt;(elements,maxAllowedCoverage, false).build();</span>
       }
       /**
      	 * Create a new {@link CoverageMap} using the given
      	 * {@link Rangeable}s but limiting the max coverage
      	 * in the map to {@code maxAllowedCoverage}.  
      	 * @param elements the elements to create a coverage map of.
      	 * @param maxAllowedCoverage Any
      	 * elements that would cause the max coverage to exceed this threshold
      	 * will be ignored.
      	 * @return a new {@link CoverageMap}; never null.
      	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
      	 */
          public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
                  create(Collection&lt;R&gt; elements, int maxAllowedCoverage, boolean startAtOrigin){
<span class="fc" id="L108">        	  return new Builder&lt;R&gt;(elements,maxAllowedCoverage, startAtOrigin).build();</span>
          }
       /**
      	 * Create a new {@link CoverageMap} using the given
      	 * {@link Rangeable}s but limiting the max coverage
      	 * in the map to {@code maxAllowedCoverage}.  
      	 * @param elements the elements to create a coverage map of.
      	 * @param maxAllowedCoverage Any
      	 * elements that would cause the max coverage to exceed this threshold
      	 * will be ignored.
      	 * @return a new {@link CoverageMap}; never null.
      	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
      	 */
          public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
                  create(Collection&lt;R&gt; elements, int maxAllowedCoverage, int minRequiredCoverage){
<span class="fc" id="L123">       	   return create(elements, maxAllowedCoverage, minRequiredCoverage, false);</span>
          }
    /**
	 * Create a new {@link CoverageMap} using the given
	 * {@link Rangeable}s but limiting the max coverage
	 * in the map to {@code maxAllowedCoverage}.  
	 * @param elements the elements to create a coverage map of.
	 * @param maxAllowedCoverage Any
	 * elements that would cause the max coverage to exceed this threshold
	 * will be ignored.
	 * @return a new {@link CoverageMap}; never null.
	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
	 */
    public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
            create(Collection&lt;R&gt; elements, int maxAllowedCoverage,  int minRequiredCoverage,
            		boolean startAtOrigin){
<span class="fc" id="L139">        return new Builder&lt;R&gt;(elements,maxAllowedCoverage, minRequiredCoverage, startAtOrigin).build();</span>
    }

    public static &lt;R extends AssembledRead&gt; CoverageMap&lt;R&gt; createUngappedCoverageMap(
            NucleotideSequence consensus, CoverageMap&lt;R&gt; gappedCoverageMap) {
<span class="fc" id="L144">        List&lt;CoverageRegion&lt;R&gt;&gt; ungappedCoverageRegions = new ArrayList&lt;CoverageRegion&lt;R&gt;&gt;();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for(CoverageRegion&lt;R&gt; gappedCoverageRegion : gappedCoverageMap){</span>
<span class="fc" id="L146">            Range gappedRange = gappedCoverageRegion.asRange();</span>
<span class="fc" id="L147">            Range ungappedRange = AssemblyUtil.toUngappedRange(consensus,gappedRange);</span>
<span class="fc" id="L148">            List&lt;R&gt; reads = new ArrayList&lt;R&gt;(gappedCoverageRegion.getCoverageDepth());</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            for(R read : gappedCoverageRegion){</span>
<span class="fc" id="L150">                reads.add(read);</span>
<span class="fc" id="L151">            }</span>
            
<span class="fc" id="L153">            ungappedCoverageRegions.add(</span>
<span class="fc" id="L154">                    new DefaultCoverageRegion.Builder&lt;R&gt;(ungappedRange.getBegin(),reads)</span>
<span class="fc" id="L155">                                .end(ungappedRange.getEnd())</span>
<span class="fc" id="L156">                                .build());</span>
<span class="fc" id="L157">        }</span>
        
<span class="fc" id="L159">        return new CoverageMapImpl&lt;R&gt;(ungappedCoverageRegions);</span>
    }

<span class="fc" id="L162">    private static class RangeableStartComparator &lt;T extends Rangeable&gt; implements Comparator&lt;T&gt;,Serializable {       </span>
        /**
         * 
         */
        private static final long serialVersionUID = -8517894363563047881L;

        @Override
        public int compare(T o1, T o2) {           
<span class="fc" id="L170">        	 long o1End= o1.asRange().getBegin();</span>
<span class="fc" id="L171">             long o2End = o2.asRange().getBegin();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">             if(o1End ==o2End){</span>
<span class="fc" id="L173">             	return 0;</span>
             }
<span class="fc bfc" id="L175" title="All 2 branches covered.">             if(o1End &lt; o2End){</span>
<span class="fc" id="L176">             	return -1;</span>
             }
<span class="fc" id="L178">             return 1;</span>
        }

    }
    
<span class="fc" id="L183">    private static class RangeableEndComparator&lt;T extends Rangeable&gt; implements Comparator&lt;T&gt;, Serializable {       </span>
        /**
         * 
         */
        private static final long serialVersionUID = 5135449151100427846L;

        @Override
        public int compare(T o1, T o2) {    
        	
<span class="fc" id="L192">            long o1End= o1.asRange().getEnd();</span>
<span class="fc" id="L193">            long o2End = o2.asRange().getEnd();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if(o1End ==o2End){</span>
<span class="fc" id="L195">            	return 0;</span>
            }
<span class="fc bfc" id="L197" title="All 2 branches covered.">            if(o1End &lt; o2End){</span>
<span class="fc" id="L198">            	return -1;</span>
            }
<span class="fc" id="L200">            return 1;</span>
        }
            
    }
    
<span class="nc" id="L205">    private CoverageMapFactory(){}</span>
    
    private static final class CoverageMapImpl&lt;V extends Rangeable&gt; implements CoverageMap&lt;V&gt;{
	    private final CoverageRegion&lt;V&gt;[] regions;
	    /**
	     * Statistics of this coverage map
	     * lazily computed since it is an
	     * expensive operation.
	     */
<span class="fc" id="L214">	    private CoverageMapStats stats=null;</span>
	    
	    /**
	     *
	     * Creates a new &lt;code&gt;CoverageMapImpl&lt;/code&gt;.
	     * @param amplicons A {@link Collection} of {@link Coordinated}s.
	     */
	    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="fc" id="L222">		private CoverageMapImpl(List&lt;CoverageRegion&lt;V&gt;&gt; regions){</span>
<span class="fc" id="L223">	        this.regions = regions.toArray(new CoverageRegion[regions.size()]);</span>
<span class="fc" id="L224">	    }</span>
	    @Override
	    public int getNumberOfRegions() {
<span class="fc" id="L227">	        return regions.length;</span>
	    }
	    @Override
	    public CoverageRegion&lt;V&gt; getRegion(int i) {	    	
<span class="fc" id="L231">	        return regions[i];</span>
	    }
	    @Override
	    public synchronized CoverageMapStats getStats(){
<span class="nc bnc" id="L235" title="All 2 branches missed.">	    	if(stats ==null){</span>
<span class="nc" id="L236">	    		computeStats();</span>
	    	}
<span class="nc" id="L238">	    	return stats;</span>
	    }
	    @Override
	    public synchronized double getAverageCoverage(){
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">	        if(stats ==null){</span>
<span class="fc" id="L243">		    	computeStats();</span>
	        }
<span class="fc" id="L245">	        return stats.getAvgCoverage();</span>
	    }
		public synchronized void computeStats() {
			
<span class="fc bfc" id="L249" title="All 2 branches covered.">			if(isEmpty()){</span>
<span class="fc" id="L250">				stats = new CoverageMapStats(0, 0, 0);</span>
<span class="fc" id="L251">				return;</span>
			}
			/*
			long totalLength = 0L;
			long totalCoverage =0L;
			
			int minCoverage = Integer.MAX_VALUE;
			int maxCoverage = Integer.MIN_VALUE;
			/*
			for(CoverageRegion&lt;?&gt; region : this){
				long regionLength = region.asRange().getLength();
				totalLength +=regionLength;
				int coverageDepth = region.getCoverageDepth();
				totalCoverage += coverageDepth * regionLength;
				if(coverageDepth &lt; minCoverage){
					minCoverage = coverageDepth;
				}
				if(coverageDepth &gt; maxCoverage){
					maxCoverage = coverageDepth;
				}
			}
			*/
			//use java 8 streams for faster performance?
<span class="fc" id="L274">			stats = Arrays.stream(regions)</span>
<span class="fc" id="L275">											.parallel()</span>
<span class="fc" id="L276">											.collect(CoverageMapCollectors.computeStats());</span>
			
<span class="fc" id="L278">		}</span>
	  
	    
	    
	    @Override
		public synchronized int getMinCoverage() {
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">	    	if(stats ==null){</span>
<span class="nc" id="L285">		    	computeStats();</span>
	        }
<span class="fc" id="L287">			return stats.getMinCoverage();</span>
		}
		@Override
		public synchronized int getMaxCoverage() {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">	    	if(stats ==null){</span>
<span class="nc" id="L292">		    	computeStats();</span>
	        }
<span class="fc" id="L294">			return stats.getMaxCoverage();</span>
		}
		@Override
	    public boolean equals(Object obj) {
<span class="fc bfc" id="L298" title="All 2 branches covered.">	        if(this == obj){</span>
<span class="fc" id="L299">	            return true;</span>
	        }
<span class="fc bfc" id="L301" title="All 2 branches covered.">	        if(obj instanceof CoverageMap){</span>
<span class="fc" id="L302">	        	CoverageMap&lt;?&gt; other = (CoverageMap&lt;?&gt;) obj;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">	            if(getNumberOfRegions() !=other.getNumberOfRegions()){</span>
<span class="fc" id="L304">	                return false;</span>
	            }
<span class="fc bfc" id="L306" title="All 2 branches covered.">	            for( int i=0; i&lt;getNumberOfRegions(); i++){</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">	                if(!getRegion(i).equals(other.getRegion(i))){</span>
<span class="fc" id="L308">	                    return false;</span>
	                }
	            }
<span class="fc" id="L311">	            return true;</span>
	        }
<span class="fc" id="L313">	       return false;</span>
	    }
	
	      public int hashCode(){
<span class="fc" id="L317">	          final int prime = 37;</span>
<span class="fc" id="L318">	          int ret = 17;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">	          for(CoverageRegion&lt;V&gt; region : regions){</span>
<span class="fc" id="L320">	              ret = ret*prime + region.hashCode();</span>
	          }
<span class="fc" id="L322">	          return ret;</span>
	      }
	    
	    /* (non-Javadoc)
	     * @see java.lang.Object#toString()
	     */
	    @Override
	    public String toString() {
<span class="nc" id="L330">	        StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">	        for(CoverageRegion&lt;V&gt; region : regions){</span>
<span class="nc" id="L332">	            buf.append(region)</span>
<span class="nc" id="L333">	            	.append('\n');</span>
	        }
<span class="nc" id="L335">	        return buf.toString();</span>
	    }
	    @Override
	    public List&lt;CoverageRegion&lt;V&gt;&gt; getRegionsWhichIntersect(Range range) {
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">	    	if(range ==null){</span>
<span class="nc" id="L340">	    		throw new NullPointerException(&quot;range can not be null&quot;);</span>
	    	}
<span class="fc bfc" id="L342" title="All 4 branches covered.">	    	if(this.isEmpty() || range.isEmpty()){</span>
	    		//empty coverage map or
	    		//empty ranges never intersect anything
<span class="fc" id="L345">	    		return Collections.emptyList();</span>
	    	}	    	
<span class="fc bfc" id="L347" title="All 2 branches covered.">	    	if(regions[0].asRange().getBegin() &gt; range.getEnd()){</span>
	    		//region is entirely before coverage map
<span class="fc" id="L349">	    		return Collections.emptyList();</span>
	    	}
<span class="fc bfc" id="L351" title="All 2 branches covered.">	    	if(regions[regions.length-1].asRange().getEnd() &lt; range.getBegin()){</span>
	    		//region is entirely after coverage map
<span class="fc" id="L353">	    		return Collections.emptyList();</span>
	    	}
<span class="fc" id="L355">	    	CoverageRegion&lt;V&gt; fakeRegion = new DefaultCoverageRegion.Builder&lt;V&gt;(range.getBegin(), Collections.&lt;V&gt;emptyList())</span>
<span class="fc" id="L356">	    											.end(range.getEnd())</span>
<span class="fc" id="L357">	    											.build();</span>
	    	
<span class="fc" id="L359">	    	int beginIndex =Arrays.binarySearch(regions, fakeRegion, CoverageRegionComparators.BY_BEGIN);</span>
<span class="fc" id="L360">	    	int endIndex =Arrays.binarySearch(regions, fakeRegion, CoverageRegionComparators.BY_END);</span>
	    	
	    	
	    	//Arrays.binarySearch will return a negative
	    	//(index+1) if the key isn't found but the 
	    	//absolute value -1 is where the key 
	    	//WOULD be if it was in the array
	    	//which is good enough for our intersection
	    	//so we need to adjust the offset by either 1 if it's
	    	//the end index or 2
	    	//if its the beginIndex
	    	//to get
	    	//the flanking region to be included
	    	
<span class="fc bfc" id="L374" title="All 2 branches covered.">	    	int correctedBeginIndex = Math.max(0, beginIndex&lt;0? Math.abs(beginIndex) -2 : beginIndex);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">	    	int correctedEndIndex = Math.min(regions.length -1, endIndex &lt;0? Math.abs(endIndex)-1  : endIndex);</span>
	    	
	    	
<span class="fc" id="L378">	    	int numberOfRegionsIntersected = correctedEndIndex-correctedBeginIndex +1;</span>
	    	
<span class="fc" id="L380">	    	List&lt;CoverageRegion&lt;V&gt;&gt; intersectedRegions = new ArrayList&lt;CoverageRegion&lt;V&gt;&gt;(numberOfRegionsIntersected);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">	    	for(int i=correctedBeginIndex; i&lt;=correctedEndIndex; i++){</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">	    		if(i&lt; regions.length){</span>
<span class="fc" id="L383">	    			intersectedRegions.add(regions[i]);</span>
	    		}
	    	}
<span class="fc" id="L386">	    	return intersectedRegions;	    	</span>
	    }
	    @Override
	    public CoverageRegion&lt;V&gt; getRegionWhichCovers(long consensusIndex) {
<span class="fc" id="L390">	        Range range = Range.of(consensusIndex, consensusIndex);</span>
<span class="fc" id="L391">	        final List&lt;CoverageRegion&lt;V&gt;&gt; intersectedRegion = getRegionsWhichIntersect(range);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">	        if(intersectedRegion.isEmpty()){</span>
<span class="fc" id="L393">	            return null;</span>
	        }
<span class="fc" id="L395">	        return intersectedRegion.get(0);</span>
	    }
	    
	    @Override
	    public Iterator&lt;CoverageRegion&lt;V&gt;&gt; iterator() {
<span class="fc" id="L400">	        return new ArrayIterator&lt;CoverageRegion&lt;V&gt;&gt;(regions, false);</span>
	    }
	
	   
	    /**
	    * {@inheritDoc}
	    */
	    @Override
	    public boolean isEmpty() {
<span class="fc bfc" id="L409" title="All 2 branches covered.">	        return regions.length==0;</span>
	    }
		@Override
		public Stream&lt;CoverageRegion&lt;V&gt;&gt; regions() {
<span class="nc" id="L413">			return Arrays.stream(regions);</span>
		}
		@Override
		public Stream&lt;CoverageRegion&lt;V&gt;&gt; regions(Range range) {
			//TODO this beginning part of the code 
			//is copy and pasted from #getRegionsWhichIntersect
			
<span class="nc bnc" id="L420" title="All 2 branches missed.">			if(range ==null){</span>
<span class="nc" id="L421">	    		throw new NullPointerException(&quot;range can not be null&quot;);</span>
	    	}
<span class="nc bnc" id="L423" title="All 4 branches missed.">	    	if(this.isEmpty() || range.isEmpty()){</span>
	    		//empty coverage map or
	    		//empty ranges never intersect anything
<span class="nc" id="L426">	    		return Collections.&lt;CoverageRegion&lt;V&gt;&gt;emptyList().stream();</span>
	    	}	    	
<span class="nc bnc" id="L428" title="All 2 branches missed.">	    	if(regions[0].asRange().getBegin() &gt; range.getEnd()){</span>
	    		//region is entirely before coverage map
<span class="nc" id="L430">	    		return Collections.&lt;CoverageRegion&lt;V&gt;&gt;emptyList().stream();</span>
	    	}
<span class="nc bnc" id="L432" title="All 2 branches missed.">	    	if(regions[regions.length-1].asRange().getEnd() &lt; range.getBegin()){</span>
	    		//region is entirely after coverage map
<span class="nc" id="L434">	    		return Collections.&lt;CoverageRegion&lt;V&gt;&gt;emptyList().stream();</span>
	    	}
<span class="nc" id="L436">	    	CoverageRegion&lt;V&gt; fakeRegion = new DefaultCoverageRegion.Builder&lt;V&gt;(range.getBegin(), Collections.&lt;V&gt;emptyList())</span>
<span class="nc" id="L437">	    											.end(range.getEnd())</span>
<span class="nc" id="L438">	    											.build();</span>
	    	
<span class="nc" id="L440">	    	int beginIndex =Arrays.binarySearch(regions, fakeRegion, CoverageRegionComparators.BY_BEGIN);</span>
<span class="nc" id="L441">	    	int endIndex =Arrays.binarySearch(regions, fakeRegion, CoverageRegionComparators.BY_END);</span>
	    	
	    	
	    	//Arrays.binarySearch will return a negative
	    	//(index+1) if the key isn't found but the 
	    	//absolute value -1 is where the key 
	    	//WOULD be if it was in the array
	    	//which is good enough for our intersection
	    	//so we need to adjust the offset by either 1 if it's
	    	//the end index or 2
	    	//if its the beginIndex
	    	//to get
	    	//the flanking region to be included
	    	
<span class="nc bnc" id="L455" title="All 2 branches missed.">	    	int correctedBeginIndex = Math.max(0, beginIndex&lt;0? Math.abs(beginIndex) -2 : beginIndex);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">	    	int correctedEndIndex = Math.min(regions.length -1, endIndex &lt;0? Math.abs(endIndex)-1  : endIndex);</span>
	    	
<span class="nc" id="L458">			return Arrays.stream(regions, correctedBeginIndex, correctedEndIndex +1);</span>
		}
	    
	    
	    

    }
    
    
<span class="pc" id="L467">    private static enum CoverageRegionComparators implements Comparator&lt;CoverageRegion&lt;?&gt;&gt;{</span>
		//Comparators can't use the Range Comparators 
    	//because those comparators use not only being and end
    	//coordinates but range length as well to determine 
    	//if comparator returns 0
<span class="fc" id="L472">    	BY_BEGIN(new Comparator&lt;Range&gt;(){</span>

			@Override
			public int compare(Range o1, Range o2) {
<span class="fc" id="L476">				long l1 =o1.getBegin();</span>
<span class="fc" id="L477">				long l2 =o2.getBegin();</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">				if(l1 ==l2){</span>
<span class="fc" id="L479">					return 0;</span>
				}
<span class="fc bfc" id="L481" title="All 2 branches covered.">				if(l1&lt; l2){</span>
<span class="fc" id="L482">					return -1;</span>
				}
<span class="fc" id="L484">				return 1;</span>
			}			
		}
		),
<span class="fc" id="L488">		BY_END(new Comparator&lt;Range&gt;(){</span>

			@Override
			public int compare(Range o1, Range o2) {
<span class="fc" id="L492">				long l1 =o1.getEnd();</span>
<span class="fc" id="L493">				long l2 =o2.getEnd();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">				if(l1 ==l2){</span>
<span class="fc" id="L495">					return 0;</span>
				}
<span class="fc bfc" id="L497" title="All 2 branches covered.">				if(l1&lt; l2){</span>
<span class="fc" id="L498">					return -1;</span>
				}
<span class="fc" id="L500">				return 1;</span>
			}			
		})
    	;
    	private final Comparator&lt;Range&gt; rangeComparator;
    	
<span class="fc" id="L506">    	private CoverageRegionComparators(Comparator&lt;Range&gt; comparator){</span>
<span class="fc" id="L507">    		this.rangeComparator = comparator;</span>
<span class="fc" id="L508">    	}</span>
    	
    	@Override
		public int compare(CoverageRegion&lt;?&gt; o1, CoverageRegion&lt;?&gt; o2) {
<span class="fc" id="L512">			return rangeComparator.compare(o1.asRange(), o2.asRange());</span>
		}
    	
    	
    }
    
    private static  class Builder&lt;P extends Rangeable&gt; extends AbstractCoverageMapBuilder&lt;P&gt;{
<span class="fc" id="L519">        private final List&lt;P&gt; startCoordinateSortedList = new ArrayList&lt;P&gt;();</span>
<span class="fc" id="L520">        private final List&lt;P&gt; endCoordinateSortedList = new ArrayList&lt;P&gt;();</span>
        private final boolean startAtOrigin;
        
        public Builder(Collection&lt;P&gt; elements, int maxAllowedCoverage, boolean startAtOrigin){
<span class="fc" id="L524">            super(maxAllowedCoverage);</span>
<span class="fc" id="L525">            initialize(elements);</span>
<span class="fc" id="L526">            this.startAtOrigin = startAtOrigin;</span>
<span class="fc" id="L527">        }</span>
        public Builder(Collection&lt;P&gt; elements, int maxAllowedCoverage, int minRequiredCoverage, boolean startAtOrigin){
<span class="fc" id="L529">            super(maxAllowedCoverage, minRequiredCoverage);</span>
<span class="fc" id="L530">            initialize(elements);</span>
<span class="fc" id="L531">            this.startAtOrigin = startAtOrigin;</span>
<span class="fc" id="L532">        }</span>
<span class="fc" id="L533">        public Builder(Collection&lt;P&gt; elements, boolean startAtOrigin) {</span>
<span class="fc" id="L534">            initialize(elements);</span>
<span class="fc" id="L535">            this.startAtOrigin =startAtOrigin;</span>
<span class="fc" id="L536">        }</span>
        public Builder(Collection&lt;P&gt; elements) {
<span class="fc" id="L538">           this(elements, false);</span>
<span class="fc" id="L539">        }</span>
        
       
        private final void initialize(Collection&lt;P&gt; collection){
<span class="fc" id="L543">        	initialize(IteratorUtil.createStreamingIterator(collection.iterator()));</span>
<span class="fc" id="L544">        }</span>
        private final void initialize(StreamingIterator&lt;P&gt; elements){
        	try{
<span class="fc bfc" id="L547" title="All 2 branches covered.">        		while(elements.hasNext()){</span>
<span class="fc" id="L548">        			P element = elements.next();</span>
<span class="fc" id="L549">        			startCoordinateSortedList.add(element);</span>
<span class="fc" id="L550">        			endCoordinateSortedList.add(element);</span>
<span class="fc" id="L551">        		}</span>
        	}finally{
<span class="pc" id="L553">        		IOUtil.closeAndIgnoreErrors(elements);</span>
<span class="fc" id="L554">        	}</span>
<span class="fc" id="L555">            filterAmpliconsWithoutCoordinates(startCoordinateSortedList);</span>
<span class="fc" id="L556">            filterAmpliconsWithoutCoordinates(endCoordinateSortedList);</span>
<span class="fc" id="L557">            Collections.sort(startCoordinateSortedList,</span>
                    new RangeableStartComparator&lt;P&gt;());
<span class="fc" id="L559">            Collections.sort(endCoordinateSortedList, new RangeableEndComparator&lt;P&gt;());</span>
<span class="fc" id="L560">        }</span>
        /**
         * If there are no coordinates (start or end are null) then we remove them
         * so they don't mess up our computations.
         * 
         * @param amp
         */
        private void filterAmpliconsWithoutCoordinates(Collection&lt;P&gt; amp) {
<span class="fc bfc" id="L568" title="All 2 branches covered.">            for (Iterator&lt;P&gt; it = amp.iterator(); it.hasNext();) {</span>
<span class="fc" id="L569">                P entry = it.next();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                if (entry.asRange().getLength() == 0) {</span>
<span class="fc" id="L571">                    it.remove();</span>
                }
<span class="fc" id="L573">            }</span>
<span class="fc" id="L574">        }</span>
        @Override
        protected CoverageRegionBuilder&lt;P&gt; createNewCoverageRegionBuilder(
                Collection&lt;P&gt; elements, long start, Integer maxAllowedCoverage) {
<span class="fc" id="L578">            return new DefaultCoverageRegion.Builder&lt;P&gt;(start, elements,maxAllowedCoverage);</span>
        }

        private List&lt;CoverageRegion&lt;P&gt;&gt; buildAllCoverageRegions(List&lt;CoverageRegionBuilder&lt;P&gt;&gt; coverageRegionBuilders) {
            
<span class="fc bfc" id="L583" title="All 2 branches covered.">        	if(coverageRegionBuilders.isEmpty()){</span>
<span class="fc" id="L584">        		return Collections.emptyList();</span>
        	}
        	//+1 incase we need to add an extra region to cover origin
<span class="fc" id="L587">            List&lt;CoverageRegion&lt;P&gt;&gt; regions = new ArrayList&lt;CoverageRegion&lt;P&gt;&gt;(</span>
<span class="fc" id="L588">                    coverageRegionBuilders.size()+1);</span>
<span class="fc" id="L589">            DefaultCoverageRegion.Builder&lt;P&gt; newFirst=null, newLast = null;</span>
            
<span class="fc bfc" id="L591" title="All 2 branches covered.">            if(startAtOrigin){            	</span>
<span class="fc" id="L592">				long firstStart =coverageRegionBuilders.get(0).start();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">				if(firstStart &lt;0){</span>
					//we start at negative
					//check to see if we cross the origin
					//(which means we cover it)
<span class="fc" id="L597">					long lastCoveredOffset =coverageRegionBuilders.get(coverageRegionBuilders.size()-1).end();</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">					if(lastCoveredOffset &lt;0){				</span>
<span class="fc" id="L599">						newLast = new DefaultCoverageRegion.Builder&lt;P&gt;(lastCoveredOffset+1, Collections.&lt;P&gt;emptyList());</span>
<span class="fc" id="L600">						newLast.end(0);</span>
						
					}
<span class="fc bfc" id="L603" title="All 2 branches covered.">				}else if(firstStart &gt;0){</span>
					//don't need to shift but need to add
					//and 0x coverage region
<span class="fc" id="L606">					newFirst = new DefaultCoverageRegion.Builder&lt;P&gt;(0, Collections.&lt;P&gt;emptyList());</span>
<span class="fc" id="L607">					newFirst.end(firstStart -1);</span>
				}
				
            }
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if(newFirst !=null){</span>
<span class="fc" id="L612">            	regions.add(newFirst.build());</span>
            }
<span class="fc" id="L614">            Iterator&lt;CoverageRegionBuilder&lt;P&gt;&gt; iterator = coverageRegionBuilders.iterator();</span>
           
<span class="fc bfc" id="L616" title="All 2 branches covered.">        	while(iterator.hasNext()){</span>
<span class="fc" id="L617">				regions.add(iterator.next().build());</span>
            }
<span class="fc bfc" id="L619" title="All 2 branches covered.">        	if(newLast !=null){</span>
<span class="fc" id="L620">            	regions.add(newLast.build());</span>
            }
            
<span class="fc" id="L623">            return regions;</span>
        }

        @Override
        protected CoverageMap&lt;P&gt; build(
                List&lt;CoverageRegionBuilder&lt;P&gt;&gt; coverageRegionBuilders) {
<span class="fc" id="L629">            return new CoverageMapImpl&lt;P&gt;(</span>
<span class="fc" id="L630">                    buildAllCoverageRegions(coverageRegionBuilders));</span>
        }

        @Override
        protected Iterator&lt;P&gt; createEnteringIterator() {
<span class="fc" id="L635">            return startCoordinateSortedList.iterator();</span>
        }

        @Override
        protected Iterator&lt;P&gt; createLeavingIterator() {
<span class="fc" id="L640">            return endCoordinateSortedList.iterator();</span>
        }
        
    }

  

}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>