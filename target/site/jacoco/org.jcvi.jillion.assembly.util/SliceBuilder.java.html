<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SliceBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util</a> &gt; <span class="el_source">SliceBuilder.java</span></div><h1>SliceBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.util;

import java.util.ArrayList;
import java.util.List;

import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.util.Builder;
import org.jcvi.jillion.internal.assembly.util.CompactedSliceElement;
import org.jcvi.jillion.internal.assembly.util.ConsensusCompactedSlice;
import org.jcvi.jillion.internal.assembly.util.NoConsensusCompactedSlice;
import org.jcvi.jillion.internal.core.util.GrowableShortArray;
/**
 * {@code SliceBuilder} is a {@link Builder}
 * object that builds a single {@link Slice}
 * instance which contains given
 * {@link SliceElement}s.
 * @author dkatzel
 *
 */
public final class SliceBuilder implements Builder&lt;Slice&gt;{

	
<span class="fc" id="L45">    private GrowableShortArray bytes = new GrowableShortArray(1024);</span>
<span class="fc" id="L46">    private List&lt;String&gt; ids = new ArrayList&lt;String&gt;();</span>
    private Nucleotide consensus;
    /**
     * {@code SliceElementFilter} is used to remove
     * {@link SliceElement}s &lt;strong&gt;currently&lt;/strong&gt;
     * in the Slice being built.
     * Applying a filter on a SliceBuilder
     * will iterate over all the current
     * SliceElements in the SliceBuilder
     * and remove any elements that are
     * not accepted by the filter.
     * @author dkatzel
     *
     */
    public interface SliceElementFilter{
    	/**
    	 * Should the given SliceElement 
    	 * be included in the SliceBuilder.
    	 * @param e the current SliceElement to inspect;
    	 * will never be null.
    	 * @return {@code true} if this {@link SliceElement}
    	 * should be kept by the SliceBuilder;
    	 * {@code false} if the SliceElement should be removed.
    	 */
		boolean accept(SliceElement e);
	}
    /**
     * Create a new {@link SliceBuilder}
     * which will start off empty with a null consensus.
     */
<span class="fc" id="L76">    public SliceBuilder(){</span>
    	//creates empty builder with null consensus
<span class="fc" id="L78">    }</span>
    /**
     * Create a new {@link SliceBuilder}
     * which will start off empty with a null consensus.
     * 
     * @param consensus the {@link Nucleotide} of the consensus at this slice.
     * 
     */
<span class="fc" id="L86">    public SliceBuilder(Nucleotide consensus){</span>
<span class="fc" id="L87">    	setConsensus(consensus);</span>
<span class="fc" id="L88">    }</span>
    /**
     * Create a new {@link SliceBuilder}
     * which will start off containing
     * the same SliceElements as the given Slice.
     * Each SliceElement will be a deep
     * copy.
     * @param slice the {@link Slice} to copy;
     * can not be null.
     * @throws NullPointerException if slice is null.
     */
<span class="fc" id="L99">    public SliceBuilder(Slice slice){</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">    	if(slice ==null){</span>
<span class="fc" id="L101">    		throw new NullPointerException(&quot;Slice can not be null&quot;);</span>
    	}
<span class="fc" id="L103">    	addAll(slice);</span>
<span class="fc" id="L104">    	setConsensus(slice.getConsensusCall());</span>
<span class="fc" id="L105">    }</span>
    /**
     * Create a new {@link SliceBuilder}
     * which will start off containing
     * the only the SliceElements from the given Slice
     * that are accepted by the SliceElementFilter.
     * This should be the same result
     * as 
     * {@code new SliceBuilder(slice).filter(filter)}
     * but may be implemented more efficiently.
     * @param slice the {@link Slice} to copy;
     * can not be null.
     * @param filter an instance of {@link SliceElementFilter}
     * to filter the input SliceElements to this builder.
     * @throws NullPointerException if slice is null.
     */
<span class="fc" id="L121">    public SliceBuilder(Slice slice, SliceElementFilter filter){</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    	if(slice ==null){</span>
<span class="nc" id="L123">    		throw new NullPointerException(&quot;Slice can not be null&quot;);</span>
    	}
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">    	if(filter ==null){</span>
<span class="nc" id="L126">    		throw new NullPointerException(&quot;filter can not be null&quot;);</span>
    	}
<span class="fc bfc" id="L128" title="All 2 branches covered.">		for(SliceElement e: slice){</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">			if(filter.accept(e)){</span>
<span class="fc" id="L130">				add(e);</span>
			}
<span class="fc" id="L132">    	}</span>
<span class="fc" id="L133">    	setConsensus(slice.getConsensusCall());</span>
<span class="fc" id="L134">    }</span>
    /**
     * Filter the &lt;strong&gt;current&lt;/strong&gt;
     * {@link SliceElement}s in this builder.
     * Any SliceElements not accepted by the filter
     * will be removed.
     * @param filter the {@link SliceElementFilter} instance
     * that will be used to filter the SliceElements;
     * can not be null.
     * @return this.
     * @throws NullPointerException if filter is null.
     */
    public SliceBuilder filter(SliceElementFilter filter){
<span class="fc bfc" id="L147" title="All 2 branches covered.">    	if(filter==null){</span>
<span class="fc" id="L148">    		throw new NullPointerException(&quot;filter can not be null&quot;);</span>
    	}
<span class="fc" id="L150">    	GrowableShortArray newBytes = new GrowableShortArray(bytes.getCurrentLength());</span>
<span class="fc" id="L151">    	List&lt;String&gt; newIds = new ArrayList&lt;String&gt;(ids.size());</span>
    	
<span class="fc bfc" id="L153" title="All 2 branches covered.">    	for(int i=0; i&lt;ids.size(); i++){</span>
<span class="fc" id="L154">    		String id = ids.get(i);</span>
<span class="fc" id="L155">    		short value =bytes.get(i);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    		if(filter.accept(CompactedSliceElement.create(id, value))){</span>
<span class="fc" id="L157">    			newBytes.append(value);</span>
<span class="fc" id="L158">    			newIds.add(id);</span>
    		}
    	}
<span class="fc" id="L161">    	this.ids = newIds;</span>
<span class="fc" id="L162">    	this.bytes = newBytes;</span>
<span class="fc" id="L163">    	return this;</span>
    }
    /**
     * Create a new {@link SliceBuilder}
     * which will start off given
     * SliceElements.
     * Each SliceElement will be a deep
     * copy.
     * @param elements the {@link SliceElement}s to copy;
     * can not be null and each SliceElement in the {@link Iterable}
     * can not be null.
     * @throws NullPointerException if slice is null.
     */
<span class="fc" id="L176">    public SliceBuilder(Iterable&lt;? extends SliceElement&gt; elements){</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">    	if(elements ==null){</span>
<span class="fc" id="L178">    		throw new NullPointerException(&quot;Slice can not be null&quot;);</span>
    	}
<span class="fc" id="L180">    	addAll(elements);</span>
<span class="fc" id="L181">    }</span>
    public int getCurrentCoverageDepth(){
<span class="fc" id="L183">    	return ids.size();</span>
    }
    
<span class="fc" id="L186">    private SliceBuilder(SliceBuilder copy){</span>
<span class="fc" id="L187">    	this.ids = new ArrayList&lt;String&gt;(copy.ids);</span>
<span class="fc" id="L188">    	this.bytes = copy.bytes.copy();</span>
<span class="fc" id="L189">    	this.consensus = copy.consensus;</span>
<span class="fc" id="L190">    }</span>
    
    public SliceBuilder setConsensus(Nucleotide consensus){
<span class="fc" id="L193">    	this.consensus = consensus;</span>
<span class="fc" id="L194">    	return this;</span>
    }
    
    /**
     * Add the given {@link SliceElement} to this builder.
     * Adding a SliceElement with the same id
     * as a pre-existing element already
     * present in this builder will cause the new
     * value to overwrite the existing value.
     * 
     * @param element the SliceElement to add;
     * can not be null.
     * @return this
     * @throws NullPointerException if element is null.
     */
    public SliceBuilder add(SliceElement element){  
<span class="fc bfc" id="L210" title="All 2 branches covered.">    	if(element ==null){</span>
<span class="fc" id="L211">    		throw new NullPointerException(&quot;SliceElement can not be nul&quot;);</span>
    	}
<span class="fc" id="L213">        return add(element.getId(),element.getBase(), element.getQuality(), element.getDirection());</span>
    }
    public SliceBuilder addAll(Iterable&lt;? extends SliceElement&gt; elements){
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for(SliceElement e : elements){</span>
<span class="fc" id="L217">            add(e);</span>
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">        return this;</span>
    }
    /**
     * Add all the slice Elements from the given builder to this builder.
     * 
     * @param other the other SliceBuilder whose elements are to be added;
     *          can not be null.
     * @return this
     * 
     * @throws NullPointerException if other is null.
     * 
     * @since 5.2
     */
    public SliceBuilder addAll(SliceBuilder other){
<span class="nc" id="L233">        other.addTo(this);</span>
<span class="nc" id="L234">        return this;</span>
    }
    protected void addTo(SliceBuilder sliceBuilder) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for(SliceElement e : build()){</span>
<span class="nc" id="L238">            sliceBuilder.add(e);</span>
<span class="nc" id="L239">        }</span>
        
<span class="nc" id="L241">    }</span>
    /**
     * Add a new SliceElement with the following values
     * to this builder.
     * Adding a SliceElement with the same id
     * as a pre-existing element already
     * present in this builder will cause the new
     * value to overwrite the existing value.
     * 
     * @param id the id of the SliceElement to add;
     * can not be null.
     * @param base the {@link Nucleotide} basecall of the SliceElement to add;
     * can not be null.
     * @param quality the {@link PhredQuality} of the SliceElement to add;
     * can not be null.
     * @param dir the {@link Direction} of the SliceElement to add;
     * can not be null.
     * @return this
     * @throws NullPointerException if any parameter is null.
     */
    public SliceBuilder add(String id, Nucleotide base, PhredQuality quality, Direction dir){
    	
<span class="fc" id="L263">    	CompactedSliceElement compacted = new CompactedSliceElement(id, base, quality, dir);</span>
<span class="fc" id="L264">    	int value = compacted.getEncodedDirAndNucleotide() &lt;&lt;8;</span>
<span class="fc" id="L265">    	value |= (compacted.getEncodedQuality() &amp;0xFF);</span>
    	
<span class="fc" id="L267">    	int index =ids.indexOf(id);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">    	if(index == -1){</span>
    		//append
<span class="fc" id="L270">    		bytes.append((short)value);            </span>
<span class="fc" id="L271">            ids.add(id);    		</span>
    	}else{    		
          //overwrite
<span class="fc" id="L274">    		bytes.replace(index, (short)value);</span>
<span class="fc" id="L275">    		ids.remove(index);</span>
<span class="fc" id="L276">    		ids.add(index, id);</span>
    	}
    	
        
<span class="fc" id="L280">        return this;</span>
    }

    /**
     * Does this builder contain
     * a SliceElement with the given id.
     * @param id the SliceElement id to find;
     * can not be null.
     * @return {@code true} if a SliceElement with this
     * id is present in the builder; 
     * {@code false} otherwise.
     * @throws NullPointerException if id is null.
     */
	public boolean containsId(String id) {
<span class="fc bfc" id="L294" title="All 2 branches covered.">		if(id ==null){</span>
<span class="fc" id="L295">			throw new NullPointerException(&quot;id can not be null&quot;);</span>
		}
<span class="fc" id="L297">		return ids.contains(id);</span>
	}
    /**
     * Removes the SliceElement with the given
     * id.  If no SliceElement exists with the given
     * id, then no changes are made.
     * @param id the id of the SliceElement to remove,
     * can not be null.
     * @return this.
     * @throws NullPointerException if id is null.
     */
    public SliceBuilder removeById(String id){
<span class="fc" id="L309">    	int index =ids.indexOf(id);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">    	if(index !=-1){</span>
<span class="fc" id="L311">    		ids.remove(index);</span>
<span class="fc" id="L312">    		bytes.remove(index);</span>
    	}
<span class="fc" id="L314">    	return this;</span>
    }
    /**
     * Make a deep copy of this SlliceBuilder.
     * Any changes to either this instance
     * or its copy will not affect the other.
     * @return a new SliceBuilder instance
     * which contains a copy of all the current
     * SliceElements.
     */
    public SliceBuilder copy(){
<span class="fc" id="L325">    	return new SliceBuilder(this);</span>
    }
    
    /**
    * {@inheritDoc}
    */
    @Override
    public Slice build() {
<span class="fc bfc" id="L333" title="All 2 branches covered.">    	if(consensus==null){</span>
<span class="fc" id="L334">    		return new NoConsensusCompactedSlice(bytes.toArray(), ids);</span>
    	}
<span class="fc" id="L336">    	return new ConsensusCompactedSlice(bytes.toArray(), ids,consensus);</span>
    }
	@Override
	public String toString() {
<span class="nc" id="L340">		return &quot;SliceBuilder [bytes=&quot; + bytes + &quot;, ids=&quot; + ids + &quot;, consensus=&quot;</span>
				+ consensus + &quot;]&quot;;
	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>