<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IndexUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.sam.index</a> &gt; <span class="el_source">IndexUtil.java</span></div><h1>IndexUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.sam.index;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.util.JillionUtil;
import org.jcvi.jillion.internal.sam.SamUtil;
import org.jcvi.jillion.sam.VirtualFileOffset;
import org.jcvi.jillion.sam.header.SamHeader;
import org.jcvi.jillion.sam.header.SamReferenceSequence;
import org.jcvi.jillion.sam.index.BamIndex;
import org.jcvi.jillion.sam.index.Bin;
import org.jcvi.jillion.sam.index.Chunk;
import org.jcvi.jillion.sam.index.ReferenceIndex;

public final class IndexUtil {

	private static final int METADATA_BIN_ID = 37450;

	private static final int INTERVAL_SHIFT = 14; //shift by 0x40_000 which is 14 bits or 16384
<span class="fc" id="L51">	private static final byte[] BAM_INDEX_MAGIC = new byte[]{'B','A','I',1};</span>
<span class="nc" id="L52">	private IndexUtil(){</span>
		//can not instantiate
<span class="nc" id="L54">	}</span>
	
	public static int getIntervalOffsetFor(int genomicOffset){
<span class="fc" id="L57">		return genomicOffset &gt;&gt;INTERVAL_SHIFT;</span>
		
	}
	
	public static BamIndex parseIndex(InputStream in, SamHeader header) throws IOException{
<span class="fc" id="L62">		byte[] magicNumber = IOUtil.readByteArray(in, 4);</span>
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">		if(!Arrays.equals(BAM_INDEX_MAGIC, magicNumber)){</span>
<span class="nc" id="L64">			throw new IOException(&quot;invalid magic number : &quot; + Arrays.toString(magicNumber));</span>
		}
<span class="fc" id="L66">		int numRefs = IOUtil.readSignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L67">		List&lt;ReferenceIndex&gt; refIndexes = new ArrayList&lt;ReferenceIndex&gt;(numRefs);</span>
<span class="fc" id="L68">		Iterator&lt;SamReferenceSequence&gt; refSeqIer = header.getReferenceSequences().iterator();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">		for(int i=0; i&lt;numRefs; i++){</span>
			//don't need to use builders
			//since the file has everything
			//&quot;prebuilt&quot; for us.
<span class="fc" id="L73">			int numBins = IOUtil.readSignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">			if(!refSeqIer.hasNext()){</span>
<span class="nc" id="L75">				throw new NullPointerException(&quot;no ref &quot; + i);</span>
			}
<span class="fc" id="L77">			SamReferenceSequence refSeq = refSeqIer.next();</span>
                        
<span class="fc" id="L79">			int maxBin = SamUtil.computeBinFor(new Range.Builder(1)</span>
<span class="fc" id="L80">											.shift(refSeq.getLength())</span>
<span class="fc" id="L81">											.build());</span>
<span class="fc" id="L82">			Bin[] bins = new Bin[numBins];</span>
<span class="fc" id="L83">			int numOfBinsUsed=0;</span>
<span class="fc" id="L84">			VirtualFileOffset lowestStart=null, highestEnd =null;</span>
<span class="fc" id="L85">			Long alignedCount=null, unAlignedCount=null;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">			for(int j=0; j&lt;numBins; j++){</span>
<span class="fc" id="L87">				int binId = IOUtil.readSignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L88">				int numChunks = IOUtil.readSignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L89">				Chunk[] chunks = new Chunk[numChunks];</span>
				
<span class="fc bfc" id="L91" title="All 2 branches covered.">				for(int k =0; k&lt;numChunks; k++){</span>
<span class="fc" id="L92">					VirtualFileOffset begin = readVirtualFileOffset(in);					</span>
<span class="fc" id="L93">					VirtualFileOffset end = readVirtualFileOffset(in);</span>
<span class="fc" id="L94">					chunks[k] =new Chunk(begin, end);</span>
				}
<span class="pc bpc" id="L96" title="1 of 4 branches missed.">				if(binId==METADATA_BIN_ID &amp;&amp; maxBin&lt; METADATA_BIN_ID){</span>
					//picard and samtools violate their
					//spec and put additional meta data in the
					//the last bin
<span class="fc" id="L100">					lowestStart = chunks[0].getBegin();</span>
<span class="fc" id="L101">					highestEnd = chunks[0].getEnd();</span>
					
<span class="fc" id="L103">					alignedCount = chunks[1].getBegin().getEncodedValue();</span>
<span class="fc" id="L104">					unAlignedCount = chunks[1].getEnd().getEncodedValue();</span>
					
				}else{
<span class="fc" id="L107">					bins[j] = new BaiBin(binId, chunks);</span>
<span class="fc" id="L108">					numOfBinsUsed++;</span>
				}
				
			}
<span class="fc" id="L112">			int numIntervals = IOUtil.readSignedInt(in, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L113">			VirtualFileOffset intervals[] = new VirtualFileOffset[numIntervals];</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">			for(int j=0; j&lt; numIntervals; j++){</span>
<span class="fc" id="L115">				intervals[j] =readVirtualFileOffset(in);</span>
			}
<span class="fc" id="L117">			BaiRefIndex ref = new BaiRefIndex(Arrays.copyOf(bins, numOfBinsUsed),</span>
													intervals);

			//set metadata if any
<span class="fc" id="L121">			ref.setLowestStartOffset(lowestStart);</span>
<span class="fc" id="L122">			ref.setHighestEndOffset(highestEnd);</span>
			
<span class="fc" id="L124">			ref.setAlignedCount(alignedCount);</span>
<span class="fc" id="L125">			ref.setUnalignedCount(unAlignedCount);</span>
			
<span class="fc" id="L127">			refIndexes.add(ref);</span>
		}
		//see if there is any more data
		//which is the # of unmapped reads
<span class="fc" id="L131">		PushbackInputStream in2 = new PushbackInputStream(in, 1);</span>
<span class="fc" id="L132">		int value = in.read();</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">		if(value == -1){</span>
			//EOF
<span class="nc" id="L135">			return new BamIndex(header, refIndexes);</span>
		}
<span class="fc" id="L137">		in2.unread(value);</span>
<span class="fc" id="L138">		long numUnMapped = IOUtil.readSignedLong(in2, ByteOrder.LITTLE_ENDIAN);</span>
	
<span class="fc" id="L140">		return new BamIndex(header, refIndexes, numUnMapped);</span>
	}

	private static VirtualFileOffset readVirtualFileOffset(InputStream in)
			throws IOException {
<span class="fc" id="L145">		return new VirtualFileOffset(</span>
				//technically, the spec says unsigned but 
				//our bit shifting does casts so it should be ok
<span class="fc" id="L148">				IOUtil.readSignedLong(in, ByteOrder.LITTLE_ENDIAN)</span>
				);
	}
	public static void writeIndex(OutputStream out, BamIndex indexes) throws IOException{
<span class="nc" id="L152">		writeIndex(out, indexes, false);</span>
<span class="nc" id="L153">	}</span>
	public static void writeIndex(OutputStream out, BamIndex indexes, boolean includeMetaData) throws IOException{
<span class="fc" id="L155">		out.write(BAM_INDEX_MAGIC);</span>
		//assume little endian like BAM
<span class="fc" id="L157">		int numberOfIndexes = indexes.getNumberOfReferenceIndexes();</span>
<span class="fc" id="L158">		IOUtil.putInt(out,numberOfIndexes, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">		for(int i =0; i&lt;numberOfIndexes; i++){</span>
<span class="fc" id="L160">			ReferenceIndex refIndex = indexes.getReferenceIndex(i);</span>
			List&lt;Bin&gt; bins;
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">			if(includeMetaData){</span>
<span class="fc" id="L163">				bins = new ArrayList&lt;Bin&gt;(refIndex.getBins());</span>
<span class="fc" id="L164">				Bin metaDataBin = createFakeMetaDataBin(refIndex);</span>
				//only write metadata if we have bins
<span class="fc bfc" id="L166" title="All 2 branches covered.">				if(metaDataBin !=null){</span>
<span class="fc" id="L167">					bins.add(metaDataBin);</span>
				}
<span class="fc" id="L169">			}else{</span>
<span class="nc" id="L170">				bins = refIndex.getBins();</span>
			}
<span class="fc" id="L172">			IOUtil.putInt(out,bins.size(), ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">			for(Bin bin : bins){</span>
<span class="fc" id="L174">				IOUtil.putInt(out,bin.getBinNumber(), ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L175">				List&lt;Chunk&gt; chunks = bin.getChunks();</span>
<span class="fc" id="L176">				IOUtil.putInt(out,chunks.size(), ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">				for(Chunk chunk : chunks){</span>
<span class="fc" id="L178">					IOUtil.putLong(out,chunk.getBegin().getEncodedValue(), ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L179">					IOUtil.putLong(out,chunk.getEnd().getEncodedValue(), ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L180">				}</span>
<span class="fc" id="L181">			}</span>
			
			//intervals
<span class="fc" id="L184">			VirtualFileOffset[] intervals =refIndex.getIntervals();</span>
<span class="fc" id="L185">			IOUtil.putInt(out,intervals.length, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L186">			long prev =0;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">			for(int j=0; j&lt;intervals.length; j++){</span>
<span class="fc" id="L188">				VirtualFileOffset current = intervals[j];</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">				if(current ==null){</span>
					//no offset for this interval
					//use previous?
<span class="nc" id="L192">					IOUtil.putLong(out, prev, ByteOrder.LITTLE_ENDIAN);</span>
				}else{
<span class="fc" id="L194">					long encodedValue = current.getEncodedValue();</span>
<span class="fc" id="L195">					IOUtil.putLong(out, encodedValue, ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L196">					prev = encodedValue;</span>
				}
			}
		}
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">		if(includeMetaData){</span>
<span class="fc" id="L201">			Long count =indexes.getTotalNumberOfUnmappedReads();</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">			IOUtil.putLong(out, count ==null? 0: count.longValue(), ByteOrder.LITTLE_ENDIAN);</span>
		}
<span class="fc" id="L204">		out.close();</span>
		
		
		
<span class="fc" id="L208">	}</span>

	private static Bin createFakeMetaDataBin(ReferenceIndex refIndex) {
<span class="pc bpc" id="L211" title="1 of 4 branches missed.">		if(!refIndex.hasMetaData() || refIndex.getNumberOfBins()==0){</span>
			//no meta data
<span class="fc" id="L213">			return null;</span>
		}
		//metadata is 2 chunks
		//chunk 1 = firstOffset - last offset
		//chunk 2 = # aligned vs #unaligned
<span class="fc" id="L218">		Chunk[] chunks = new Chunk[2];</span>
<span class="fc" id="L219">		chunks[0] =new Chunk(refIndex.getLowestStartOffset(), refIndex.getHighestEndOffset());</span>
		//chunk doesn't do any validation to make sure start &lt; end
		//so this should be safe...
<span class="fc" id="L222">		chunks[1] =new Chunk(new VirtualFileOffset(refIndex.getNumberOfAlignedReads()), </span>
<span class="fc" id="L223">							new VirtualFileOffset(refIndex.getNumberOfUnAlignedReads()));</span>
<span class="fc" id="L224">		return new BaiBin(METADATA_BIN_ID, chunks);</span>
	}

	/**
	 * Sorts Bins by bin number in increasing order.
	 * @author dkatzel
	 *
	 */
<span class="pc" id="L232">	public static enum BinSorter implements Comparator&lt;Bin&gt;{</span>
		
<span class="fc" id="L234">		INSTANCE;</span>

		@Override
		public int compare(Bin o1, Bin o2) {
<span class="fc" id="L238">			return JillionUtil.compare(o1.getBinNumber(), o2.getBinNumber());</span>
		}
		
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>