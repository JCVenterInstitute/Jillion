<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TasmContigBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.tigr.tasm</a> &gt; <span class="el_source">TasmContigBuilder.java</span></div><h1>TasmContigBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.tigr.tasm;

import java.util.Collection;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

import org.jcvi.jillion.assembly.AbstractContigBuilder;
import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.AssembledReadBuilder;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.MapUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.internal.assembly.DefaultContig;
/**
 * Builder
 * for {@link TasmContig}s that allows
 * creating {@link TasmContig} objects read by read by adding assembled reads
 * and setting a consensus.  An {@link TasmContigBuilder}
 * can be used to create {@link TasmContig}s that 
 * have been created by an assembler or can be used
 * to create contigs from &quot;scratch&quot;.
 * There are additional methods to allow
 * the contig consensus or underlying
 * reads to be modified before
 * the creation of the {@link TasmContig} instance
 * (which is immutable).
 * @author dkatzel
 *
 *
 */
public final class TasmContigBuilder extends AbstractContigBuilder&lt;TasmAssembledRead, TasmContig&gt;{
	private Long celeraAssemblerId;
	private String comment, commonName;
	private Integer sampleId;
	private Long asmblId;
	
	private String editPerson;
	private Long editDate;
	private String assemblyMethod;
	private boolean isCircular;
	
	private Double avgCoverage;
	private Integer numberOfReads;
	
    /**
     * Create a new TasmContigBuilder instance setting the
     * contig id and contig consensus.  If the contig id
     * is a positive numeric, then the TigrProjectAssemblyId
     * will also be set to the contig id.  This can
     * be changed by calling {@link #setTigrProjectAssemblyId(Long)}.
     * All other {@link TasmContig} optional specific attributes
     * will be set to the default values of {@code null}
     * or {@code false}.
     * @param id the contig id; can not be null.
     * @param consensus the contig consensus; can not be null.
     * @throws NullPointerException if either id or consensus
     * are null.
     */
    public TasmContigBuilder(String id, NucleotideSequence consensus) {
<span class="fc" id="L85">    	super(id,consensus);</span>
    	try{
<span class="fc" id="L87">    		long asmblId =Long.parseLong(id);</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    		if(asmblId &gt;0){</span>
<span class="fc" id="L89">    			setTigrProjectAssemblyId(asmblId);</span>
    		}
<span class="nc" id="L91">    	}catch(Exception e){</span>
    		//must not be an assemble id
<span class="fc" id="L93">    	}</span>
<span class="fc" id="L94">    }</span>
    /**
     * Create a new TasmContigBuilder instance setting the
     * initial contig state to have 
     * the same contig, id, and underlying reads
     * as the given contig. If the contig id
     * is a positive numeric, then the TigrProjectAssemblyId
     * will also be set to the contig id.  This can
     * be changed by calling {@link #setTigrProjectAssemblyId(Long)}.
     * All other {@link TasmContig} optional specific attributes
     * will be set to the default values of {@code null}
     * or {@code false}.
     * @param copy the contig to copy; can not be null.
     * @throws NullPointerException if copy is null.
     */
    public  TasmContigBuilder(Contig&lt;? extends AssembledRead&gt; copy){
<span class="fc" id="L110">    	this(copy.getId(), copy.getConsensusSequence());</span>
<span class="fc" id="L111">        StreamingIterator&lt;? extends AssembledRead&gt; iter =null;</span>
        try{
<span class="fc" id="L113">        	 iter = copy.getReadIterator();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        	 while(iter.hasNext()){</span>
<span class="fc" id="L115">        		 AssembledRead read = iter.next();</span>
<span class="fc" id="L116">        		 addRead(new TasmAssembledReadAdapter(read));</span>
<span class="fc" id="L117">        	 }</span>
        }finally{
<span class="pc" id="L119">        	IOUtil.closeAndIgnoreErrors(iter);</span>
<span class="fc" id="L120">        }</span>
<span class="fc" id="L121">    }</span>
    /**
     * Create a new Builder instance with
     * the initial state of a copy of the given {@link TasmContig}.
     * The contig id, consensus, underlying reads and all tasm
     * specific attributes will be identical to the values
     * of the input {@link TasmContig}.  These initial 
     * values may be changed by the mutator methods
     * of this class.
     * 
     * @param copy the TasmContig to copy; can not be null.
     * @throws NullPointerException if copy is null.
     */
    public  TasmContigBuilder(TasmContig copy){
<span class="nc" id="L135">        this(copy.getId(), copy.getConsensusSequence());</span>
<span class="nc" id="L136">        StreamingIterator&lt;TasmAssembledRead&gt; iter =null;</span>
        try{
<span class="nc" id="L138">        	 iter = copy.getReadIterator();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        	 while(iter.hasNext()){</span>
<span class="nc" id="L140">        		 TasmAssembledRead read = iter.next();</span>
<span class="nc" id="L141">        		 addRead(read);</span>
<span class="nc" id="L142">        	 }</span>
        }finally{
<span class="nc" id="L144">        	IOUtil.closeAndIgnoreErrors(iter);</span>
<span class="nc" id="L145">        }</span>
<span class="nc" id="L146">        this.celeraAssemblerId = copy.getCeleraAssemblerId();</span>
<span class="nc" id="L147">        this.sampleId = copy.getSampleId();</span>
<span class="nc" id="L148">        this.asmblId = copy.getTigrProjectAssemblyId();</span>
        
<span class="nc" id="L150">        this.assemblyMethod = copy.getAssemblyMethod();</span>
<span class="nc" id="L151">        this.comment = copy.getComment();</span>
<span class="nc" id="L152">        this.commonName = copy.getCommonName();</span>
<span class="nc" id="L153">        this.editDate = Long.valueOf(copy.getEditDate().getTime());</span>
<span class="nc" id="L154">        this.editPerson = copy.getEditPerson();</span>
<span class="nc" id="L155">        this.isCircular = copy.isCircular();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if(copy.getNumberOfReads()==0D){</span>
<span class="nc" id="L157">        	this.avgCoverage = copy.getAvgCoverage();</span>
        }
<span class="nc" id="L159">     }</span>
   
   
    @Override
    public TasmContigBuilder addRead(String id, int offset,Range validRange, String basecalls, Direction dir, int fullUngappedLength){            
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if(offset &lt;0){</span>
<span class="nc" id="L165">            throw new IllegalArgumentException(&quot;circular reads not supported&quot;);</span>
            
          }
<span class="fc" id="L168">        super.addRead(id, offset, validRange, basecalls, dir,fullUngappedLength);</span>
<span class="fc" id="L169">        return this;            </span>
    }
    
   
   
   
    @SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public Collection&lt;TasmAssembledReadBuilder&gt; getAllAssembledReadBuilders() {
<span class="fc" id="L178">		return (Collection&lt;TasmAssembledReadBuilder&gt;) super.getAllAssembledReadBuilders();</span>
	}
	@Override
	public TasmAssembledReadBuilder getAssembledReadBuilder(
			String readId) {
<span class="nc" id="L183">		return (TasmAssembledReadBuilder)super.getAssembledReadBuilder(readId);</span>
	}
	/**
     * Sets the comment
     * attribute for this adapted contig.  Calling this method
     * multiple times will overwrite previous entries with the current
     * entry. Setting the value to {@code null} will remove the current
     * entry (the type can later be re-added by calling this method 
     * again with a non-null value).
     * @param comment the value of the comment to set;
     * if this value is null, then the contig should not
     * have this attribute.
     * @return this.
     */
    public TasmContigBuilder withComment(String comment){
<span class="nc" id="L198">       this.comment=comment;</span>
<span class="nc" id="L199">        return this;</span>
    }
    /**
     * Sets the com_name
     * attribute for this adapted contig.  Calling this method
     * multiple times will overwrite previous entries with the current
     * entry. Setting the value to {@code null} will remove the current
     * entry (the type can later be re-added by calling this method 
     * again with a non-null value).
     * @param commonName the value of the com-name to set;
     * if this value is null, then the contig should not
     * have this attribute.
     * @return this.
     */
    public TasmContigBuilder withCommonName(String commonName){
<span class="nc" id="L214">       this.commonName = commonName;</span>
<span class="nc" id="L215">        return this;</span>
    }
    
    /**
     * Sets the number of reads and avg coverage
     * attributes for this contig.  If these values are not set,
     * or set to {@code null}, then the values
     * will be computed by counting the bases in the
     * underlying reads.  Calling this method
     * multiple times will overwrite previous entries with the current
     * entry. Setting the values to {@code null} will remove the current
     * entries (and can later be re-added by calling this method 
     * again with a non-null values).
     * @param numberOfReads the value to set as the number of
     * reads
     * &lt;strong&gt;regardless&lt;/strong&gt; of what the actual
     * underlying read count is.
     * @param avgCoverage the value to set as the average coverage
     * &lt;strong&gt;regardless&lt;/strong&gt; of what the actual
     * underlying reads are.
     * @return this.
     * @throws IllegalArgumentException if avgCoverage &amp;lt; 0
     */
    public TasmContigBuilder setCoverageInfo(Integer numberOfReads, Double avgCoverage){
<span class="pc bpc" id="L239" title="1 of 4 branches missed.">    	if(numberOfReads !=null &amp;&amp; numberOfReads &lt;0){</span>
<span class="nc" id="L240">    		throw new IllegalArgumentException(&quot;number of reads must be &gt;= 0&quot;);</span>
    	}
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">    	if(avgCoverage !=null &amp;&amp; avgCoverage &lt;0D){</span>
<span class="nc" id="L243">    		throw new IllegalArgumentException(&quot;avg coverage must be &gt;= 0&quot;);</span>
    	}
<span class="fc" id="L245">       this.avgCoverage = avgCoverage;</span>
<span class="fc" id="L246">       this.numberOfReads = numberOfReads;</span>
<span class="fc" id="L247">        return this;</span>
    }
    /**
     * Sets the Celeara Assembler UID
     * attribute for this adapted contig.  Calling this method
     * multiple times will overwrite previous entries with the current
     * entry. Setting the value to {@code null} will remove the current
     * entry (the type can later be re-added by calling this method 
     * again with a non-null value). As of 2006, All contigs
     * should get a CA Contig Id set to a UID.
     * @param caId the value of the Celera Assembler Contig Id to set;
     * if this value is null, then the contig should not
     * have this attribute.
     * @return this.
     */
    public TasmContigBuilder withCeleraAssemblerContigId(Long caId){
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">    	if(caId==null){</span>
<span class="nc" id="L264">    		this.celeraAssemblerId = null;</span>
    	}else{
<span class="fc" id="L266">    		this.celeraAssemblerId = caId;</span>
    	}
<span class="fc" id="L268">        return this;</span>
    }
    
    /**
     * Sets the bac_id
     * attribute for this adapted contig.  Calling this method
     * multiple times will overwrite previous entries with the current
     * entry. Setting the value to {@code null} will remove the current
     * entry (the type can later be re-added by calling this method 
     * again with a non-null value). 
     * @param sampleId the value of the sample id to set;
     * may be null if this contig does not have a 
     * sample id.
     * @return this.
     */
    public TasmContigBuilder setSampleId(String sampleId){
<span class="nc bnc" id="L284" title="All 2 branches missed.">       if(sampleId==null){</span>
<span class="nc" id="L285">    	   this.sampleId = null;</span>
       }else{
<span class="nc" id="L287">    	   this.sampleId = Integer.parseInt(sampleId);</span>
       }
<span class="nc" id="L289">        return this;</span>
    }
	/**
	 * Sets the assembly method
	 * attribute for this adapted contig.  Calling this method
	 * multiple times will overwrite previous entries with the current
	 * entry. Setting the value to {@code null} will remove the current
	 * entry (the method can later be re-added by calling this method 
	 * again with a non-null value).
	 * @param method the value of the method to set;
	 * if this value is null, then the contig should not
	 * have this attribute.
	 * @return this.
	 */
	public TasmContigBuilder withMethod(String method){
<span class="fc" id="L304">		this.assemblyMethod = method;</span>
<span class="fc" id="L305">		return this;</span>
	}

	/**
	 * Sets the edit person and edit date attributes for this contig.
	 * Calling this method
	 * multiple times will overwrite previous entries with the current
	 * entries. Setting &lt;strong&gt;EITHER&lt;/strong&gt; value to {@code null} will remove the current
	 * entries (the attributes can later be re-added by calling this method 
	 * again with a non-null values).
	 * @param editPerson the person who last made an edit
	 * to this contig. 
	 * @param editDate the date that this contig was last edited
	 * (by the editPerson)
	 * @return this.
	 */
	public TasmContigBuilder withEditInfo(String editPerson, Date editDate){
<span class="pc bpc" id="L322" title="2 of 4 branches missed.">		if(editPerson ==null || editDate ==null){</span>
<span class="nc" id="L323">			this.editPerson = null;</span>
<span class="nc" id="L324">			this.editDate = null;</span>
		}else{
<span class="fc" id="L326">			this.editDate = Long.valueOf(editDate.getTime());</span>
<span class="fc" id="L327">			this.editPerson = editPerson;</span>
		}
<span class="fc" id="L329">		return this;</span>
	}

	public TasmContigBuilder isCircular(boolean isCircular){
<span class="fc" id="L333">		this.isCircular = isCircular;</span>
<span class="fc" id="L334">		return this;</span>
	}
	
	public TasmContigBuilder setTigrProjectAssemblyId(Long asmblId){
<span class="fc" id="L338">		this.asmblId = asmblId;</span>
<span class="fc" id="L339">		return this;</span>
	}
    @Override
    public DefaultTasmContig build() {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">    	 if(consensusCaller !=null){</span>
<span class="nc" id="L344"> 			recallConsensusNow();</span>
         }
<span class="fc" id="L346">    	 int capacity = MapUtil.computeMinHashMapSizeWithoutRehashing(numberOfReads());</span>
<span class="fc" id="L347">        Map&lt;String,TasmAssembledRead&gt; reads = new LinkedHashMap&lt;String, TasmAssembledRead&gt;(capacity);</span>
<span class="fc" id="L348">        NucleotideSequence consensus = getConsensusBuilder().build();</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for(AssembledReadBuilder&lt;TasmAssembledRead&gt; builder : getAllAssembledReadBuilders()){</span>
<span class="fc" id="L350">            reads.put(builder.getId(),builder.build(consensus));</span>
<span class="fc" id="L351">        }</span>
<span class="fc" id="L352">        return new DefaultTasmContig(this, consensus,reads, avgCoverage, numberOfReads);</span>
    }

    
    /**
    * {@inheritDoc}
    */
    @Override
    protected TasmAssembledReadBuilder createPlacedReadBuilder(
            TasmAssembledRead read) {
<span class="fc" id="L362">        TasmAssembledReadBuilder builder =DefaultTasmAssembledRead.createBuilder(</span>
<span class="fc" id="L363">                read.getId(), </span>
<span class="fc" id="L364">                read.getNucleotideSequence().toString(), </span>
<span class="fc" id="L365">                (int)read.getGappedStartOffset(), </span>
<span class="fc" id="L366">                read.getDirection(), </span>
<span class="fc" id="L367">                read.getReadInfo().getValidRange(), </span>
<span class="fc" id="L368">                read.getReadInfo().getUngappedFullLength());</span>

<span class="fc" id="L370">        return builder;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    protected TasmAssembledReadBuilder createPlacedReadBuilder(
            String id, int offset, Range validRange, String basecalls,
            Direction dir, int fullUngappedLength) {
<span class="fc" id="L379">        return DefaultTasmAssembledRead.createBuilder(</span>
                id, 
                basecalls, 
                offset, 
                dir, 
                validRange, 
                fullUngappedLength);
    }
    /**
     * {@code DefaultTasmContig} is a {@link Contig}
     * implementation for TIGR Assembler contig data.
     * @author dkatzel
     *
     *
     */
    private static final class DefaultTasmContig implements TasmContig{
    	private final Long celeraAssemblerId;
    	private final String comment, commonName;
    	private final Integer sampleId;
    	private final Long asmblId;
    	
    	private final String editPerson;
    	private final Long editDate;
    	private final String assemblyMethod;
    	private final double avgCoverage;
    	private final boolean isCircular;
    	private final int numberOfReads;
        private final Contig&lt;TasmAssembledRead&gt; contig;
        /**
         * @param id
         * @param consensus
         * @param placedReads
         * @param circular
         */
        private DefaultTasmContig(TasmContigBuilder builder, NucleotideSequence consensus, Map&lt;String,TasmAssembledRead&gt; reads,
<span class="fc" id="L414">        		Double userProvidedAvgCoverage, Integer userProvidedNumberOfReads) {</span>
<span class="fc" id="L415">            contig = new DefaultContig&lt;TasmAssembledRead&gt;(builder.getContigId(),</span>
            		consensus,reads);
<span class="fc bfc" id="L417" title="All 2 branches covered.">            this.numberOfReads = userProvidedNumberOfReads ==null ? (int) contig.getNumberOfReads() : userProvidedNumberOfReads;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if(userProvidedAvgCoverage ==null){</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">	            if(numberOfReads &gt;0){</span>
<span class="fc" id="L420">	    	        long totalNumberOfReadBases=0L;</span>
	    	        
<span class="fc bfc" id="L422" title="All 2 branches covered.">	    	        for(TasmAssembledRead read : reads.values()){</span>
<span class="fc" id="L423">	    	        	totalNumberOfReadBases+=read.getNucleotideSequence().getUngappedLength();</span>
<span class="fc" id="L424">	    	        }</span>
	    	       
<span class="fc" id="L426">	    			avgCoverage = totalNumberOfReadBases/(double) contig.getConsensusSequence().getUngappedLength();</span>
<span class="fc" id="L427">	            }else{</span>
<span class="nc" id="L428">	            	avgCoverage=0D;</span>
	            }
            }else{
<span class="fc" id="L431">            	this.avgCoverage = userProvidedAvgCoverage;</span>
            }
<span class="fc" id="L433">    		this.sampleId = builder.sampleId;</span>
<span class="fc" id="L434">    		this.celeraAssemblerId = builder.celeraAssemblerId;</span>
<span class="fc" id="L435">    		this.editDate = builder.editDate;</span>
<span class="fc" id="L436">    		this.editPerson = builder.editPerson;</span>
<span class="fc" id="L437">    		this.comment = builder.comment;</span>
<span class="fc" id="L438">    		this.commonName = builder.commonName;</span>
<span class="fc" id="L439">    		this.assemblyMethod = builder.assemblyMethod;</span>
<span class="fc" id="L440">    		this.isCircular = builder.isCircular;</span>
<span class="fc" id="L441">    		this.asmblId = builder.asmblId;</span>
<span class="fc" id="L442">        }</span>

    	@Override
		public boolean isAnnotationContig() {
<span class="fc bfc" id="L446" title="All 2 branches covered.">			return contig.getNumberOfReads()==0;</span>
		}

		@Override
    	public String getId() {
<span class="fc" id="L451">    		return contig.getId();</span>
    	}

    	@Override
    	public double getAvgCoverage() {
<span class="fc" id="L456">    		return avgCoverage;</span>
    	}
    	@Override
    	public Integer getSampleId() {
<span class="fc" id="L460">    		return sampleId;</span>
    	}

    	@Override
    	public Long getCeleraAssemblerId() {
<span class="fc" id="L465">    		return celeraAssemblerId;</span>
    	}

    	@Override
    	public Long getTigrProjectAssemblyId() {
<span class="fc" id="L470">    		return asmblId;</span>
    	}

    	@Override
    	public String getAssemblyMethod() {
<span class="fc" id="L475">    		return assemblyMethod;</span>
    	}

    	@Override
    	public String getComment() {
<span class="fc" id="L480">    		return comment;</span>
    	}

    	@Override
    	public String getCommonName() {
<span class="fc" id="L485">    		return commonName;</span>
    	}

    	@Override
    	public String getEditPerson() {
<span class="fc" id="L490">    		return editPerson;</span>
    	}


    	@Override
    	public Date getEditDate() {
<span class="fc" id="L496">    		return new Date(editDate);</span>
    	}
    	@Override
    	public boolean isCircular() {
<span class="fc" id="L500">    		return isCircular;</span>
    	}


    	@Override
    	public long getNumberOfReads() {
<span class="fc" id="L506">    		return numberOfReads;</span>
    	}



    	@Override
    	public NucleotideSequence getConsensusSequence() {
<span class="fc" id="L513">    		return contig.getConsensusSequence();</span>
    	}



    	@Override
    	public TasmAssembledRead getRead(String id) {
<span class="fc" id="L520">    		return contig.getRead(id);</span>
    	}



    	@Override
    	public boolean containsRead(String readId) {
<span class="nc" id="L527">    		return contig.containsRead(readId);</span>
    	}



    	@Override
    	public StreamingIterator&lt;TasmAssembledRead&gt; getReadIterator() {
<span class="fc" id="L534">    		return contig.getReadIterator();</span>
    	}


        


    	


    	@Override
    	public int hashCode() {
<span class="nc" id="L546">    		final int prime = 31;</span>
<span class="nc" id="L547">    		int result = 1;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">    		result = prime * result + ((asmblId == null) ? 0 : asmblId.hashCode());</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">    		result = prime * result</span>
<span class="nc" id="L550">    				+ ((assemblyMethod == null) ? 0 : assemblyMethod.hashCode());</span>
    		long temp;
<span class="nc" id="L552">    		temp = Double.doubleToLongBits(avgCoverage);</span>
<span class="nc" id="L553">    		result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">    		result = prime</span>
    				* result
    				+ ((celeraAssemblerId == null) ? 0 : celeraAssemblerId
<span class="nc" id="L557">    						.hashCode());</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">    		result = prime * result + ((comment == null) ? 0 : comment.hashCode());</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">    		result = prime * result</span>
<span class="nc" id="L560">    				+ ((commonName == null) ? 0 : commonName.hashCode());</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">    		result = prime * result + ((contig == null) ? 0 : contig.hashCode());</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">    		result = prime * result</span>
<span class="nc" id="L563">    				+ ((editDate == null) ? 0 : editDate.hashCode());</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">    		result = prime * result</span>
<span class="nc" id="L565">    				+ ((editPerson == null) ? 0 : editPerson.hashCode());</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">    		result = prime * result + (isCircular ? 1231 : 1237);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">    		result = prime * result</span>
<span class="nc" id="L568">    				+ ((sampleId == null) ? 0 : sampleId.hashCode());</span>
<span class="nc" id="L569">    		return result;</span>
    	}

    	@Override
    	public boolean equals(Object obj) {
<span class="nc bnc" id="L574" title="All 2 branches missed.">    		if (this == obj) {</span>
<span class="nc" id="L575">    			return true;</span>
    		}
<span class="nc bnc" id="L577" title="All 2 branches missed.">    		if (obj == null) {</span>
<span class="nc" id="L578">    			return false;</span>
    		}
<span class="nc bnc" id="L580" title="All 2 branches missed.">    		if (!(obj instanceof TasmContig)) {</span>
<span class="nc" id="L581">    			return false;</span>
    		}
<span class="nc" id="L583">    		TasmContig other = (TasmContig) obj;</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">    		if (!contig.getId().equals(other.getId())) {</span>
<span class="nc" id="L585">    			return false;</span>
    		}
<span class="nc bnc" id="L587" title="All 2 branches missed.">    		if (!contig.getConsensusSequence().equals(other.getConsensusSequence())) {</span>
<span class="nc" id="L588">    			return false;</span>
    		}
<span class="nc bnc" id="L590" title="All 2 branches missed.">    		if (contig.getNumberOfReads()!=other.getNumberOfReads()) {</span>
<span class="nc" id="L591">    			return false;</span>
    		}
<span class="nc bnc" id="L593" title="All 2 branches missed.">    		if(!readsMatch(other)){</span>
<span class="nc" id="L594">    			return false;</span>
    		}
<span class="nc bnc" id="L596" title="All 2 branches missed.">    		if (asmblId == null) {</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">    			if (other.getTigrProjectAssemblyId() != null) {</span>
<span class="nc" id="L598">    				return false;</span>
    			}
<span class="nc bnc" id="L600" title="All 2 branches missed.">    		} else if (!asmblId.equals(other.getTigrProjectAssemblyId())) {</span>
<span class="nc" id="L601">    			return false;</span>
    		}
<span class="nc bnc" id="L603" title="All 2 branches missed.">    		if (assemblyMethod == null) {</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">    			if (other.getAssemblyMethod() != null) {</span>
<span class="nc" id="L605">    				return false;</span>
    			}
<span class="nc bnc" id="L607" title="All 2 branches missed.">    		} else if (!assemblyMethod.equals(other.getAssemblyMethod())) {</span>
<span class="nc" id="L608">    			return false;</span>
    		}
<span class="nc" id="L610">    		if (Double.doubleToLongBits(avgCoverage) != Double</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">    				.doubleToLongBits(other.getAvgCoverage())) {</span>
<span class="nc" id="L612">    			return false;</span>
    		}
<span class="nc bnc" id="L614" title="All 2 branches missed.">    		if (celeraAssemblerId == null) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">    			if (other.getCeleraAssemblerId() != null) {</span>
<span class="nc" id="L616">    				return false;</span>
    			}
<span class="nc bnc" id="L618" title="All 2 branches missed.">    		} else if (!celeraAssemblerId.equals(other.getCeleraAssemblerId())) {</span>
<span class="nc" id="L619">    			return false;</span>
    		}
<span class="nc bnc" id="L621" title="All 2 branches missed.">    		if (comment == null) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">    			if (other.getComment() != null) {</span>
<span class="nc" id="L623">    				return false;</span>
    			}
<span class="nc bnc" id="L625" title="All 2 branches missed.">    		} else if (!comment.equals(other.getComment())) {</span>
<span class="nc" id="L626">    			return false;</span>
    		}
<span class="nc bnc" id="L628" title="All 2 branches missed.">    		if (commonName == null) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">    			if (other.getCommonName() != null) {</span>
<span class="nc" id="L630">    				return false;</span>
    			}
<span class="nc bnc" id="L632" title="All 2 branches missed.">    		} else if (!commonName.equals(other.getCommonName())) {</span>
<span class="nc" id="L633">    			return false;</span>
    		}
    		
<span class="nc bnc" id="L636" title="All 2 branches missed.">    		if (editDate == null) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">    			if (other.getEditDate() != null) {</span>
<span class="nc" id="L638">    				return false;</span>
    			}
<span class="nc bnc" id="L640" title="All 2 branches missed.">    		} else if (editDate.longValue()!=other.getEditDate().getTime()) {</span>
<span class="nc" id="L641">    			return false;</span>
    		}
<span class="nc bnc" id="L643" title="All 2 branches missed.">    		if (editPerson == null) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">    			if (other.getEditPerson() != null) {</span>
<span class="nc" id="L645">    				return false;</span>
    			}
<span class="nc bnc" id="L647" title="All 2 branches missed.">    		} else if (!editPerson.equals(other.getEditPerson())) {</span>
<span class="nc" id="L648">    			return false;</span>
    		}
<span class="nc bnc" id="L650" title="All 2 branches missed.">    		if (isCircular != other.isCircular()) {</span>
<span class="nc" id="L651">    			return false;</span>
    		}
<span class="nc bnc" id="L653" title="All 2 branches missed.">    		if (sampleId == null) {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">    			if (other.getSampleId() != null) {</span>
<span class="nc" id="L655">    				return false;</span>
    			}
<span class="nc bnc" id="L657" title="All 2 branches missed.">    		} else if (!sampleId.equals(other.getSampleId())) {</span>
<span class="nc" id="L658">    			return false;</span>
    		}
<span class="nc" id="L660">    		return true;</span>
    	}

        private boolean readsMatch(TasmContig other) {

<span class="nc" id="L665">            try (StreamingIterator&lt;TasmAssembledRead&gt; readIter = contig</span>
<span class="nc" id="L666">                    .getReadIterator()) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                while (readIter.hasNext()) {</span>
<span class="nc" id="L668">                    TasmAssembledRead read = readIter.next();</span>
<span class="nc" id="L669">                    String readId = read.getId();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                    if (!other.containsRead(readId)) {</span>
<span class="nc" id="L671">                        return false;</span>
                    }
<span class="nc bnc" id="L673" title="All 2 branches missed.">                    if (!read.equals(other.getRead(readId))) {</span>
<span class="nc" id="L674">                        return false;</span>
                    }
<span class="nc" id="L676">                }</span>
<span class="nc" id="L677">                return true;</span>
<span class="nc bnc" id="L678" title="All 16 branches missed.">            }</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>