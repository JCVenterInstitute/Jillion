<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Version3BasesSectionCodec.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jillion</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.trace.chromat.scf.section</a> &gt; <span class="el_source">Version3BasesSectionCodec.java</span></div><h1>Version3BasesSectionCodec.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Jillion development code
 * 
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 *  see:
 * 
 *          http://www.gnu.org/copyleft/lesser.html
 * 
 * 
 * Copyright for this code is held jointly by the individual authors.  These should be listed in the @author doc comments.
 * 
 * Information about Jillion can be found on its homepage
 * 
 *         http://jillion.sourceforge.net
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Sep 11, 2008
 *
 * @author dkatzel
 */
package org.jcvi.jillion.internal.trace.chromat.scf.section;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteBuffer;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.pos.Position;
import org.jcvi.jillion.core.pos.PositionSequence;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.trace.chromat.ChannelGroup;
import org.jcvi.jillion.trace.chromat.Chromatogram;
import org.jcvi.jillion.trace.chromat.ChromatogramFileVisitor;
import org.jcvi.jillion.trace.chromat.scf.ScfChromatogram;
import org.jcvi.jillion.trace.chromat.scf.ScfChromatogramBuilder;
import org.jcvi.jillion.trace.chromat.scf.ScfChromatogramFileVisitor;

<span class="fc" id="L48">public class Version3BasesSectionCodec extends AbstractBasesSectionCodec{</span>

    @Override
    protected void readBasesData(DataInputStream in, ScfChromatogramBuilder c,
            int numberOfBases) throws IOException {
<span class="fc" id="L53">        c.peaks( parsePeaks(in, numberOfBases));</span>
<span class="fc" id="L54">        setConfidences(c, parseConfidenceData(in, numberOfBases));</span>
<span class="fc" id="L55">        c.basecalls(parseBasecalls(in, numberOfBases));</span>
        
<span class="fc" id="L57">        c.substitutionConfidence(parseSpareConfidence(in, numberOfBases).array())</span>
<span class="fc" id="L58">        .insertionConfidence(parseSpareConfidence(in, numberOfBases).array())</span>
<span class="fc" id="L59">        .deletionConfidence(parseSpareConfidence(in, numberOfBases).array());</span>
        
<span class="fc" id="L61">    }</span>
    
    /**
     * {@inheritDoc}
     */
     @Override
     protected void readBasesData(DataInputStream in, ChromatogramFileVisitor visitor,
             int numberOfBases) throws IOException {
<span class="fc" id="L69">         visitor.visitPeaks( parsePeaks(in, numberOfBases));</span>
<span class="fc" id="L70">         byte[][] confidences =parseConfidenceData(in, numberOfBases);</span>
         
<span class="fc" id="L72">         visitor.visitAConfidence(confidences[0]);</span>
<span class="fc" id="L73">         visitor.visitCConfidence(confidences[1]);</span>
<span class="fc" id="L74">         visitor.visitGConfidence(confidences[2]);</span>
<span class="fc" id="L75">         visitor.visitTConfidence(confidences[3]);</span>
<span class="fc" id="L76">         visitor.visitBasecalls(parseBasecalls(in, numberOfBases));</span>
         
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">         if(visitor instanceof ScfChromatogramFileVisitor){</span>
<span class="fc" id="L79">             ScfChromatogramFileVisitor scfVisitor = (ScfChromatogramFileVisitor) visitor;</span>
<span class="fc" id="L80">             scfVisitor.visitSubstitutionConfidence(parseSpareConfidence(in, numberOfBases).array());</span>
<span class="fc" id="L81">             scfVisitor.visitInsertionConfidence(parseSpareConfidence(in, numberOfBases).array());</span>
<span class="fc" id="L82">             scfVisitor.visitDeletionConfidence(parseSpareConfidence(in, numberOfBases).array());</span>
         }
        
         
<span class="fc" id="L86">     }</span>

    private ByteBuffer parseSpareConfidence(DataInputStream in,
            int numberOfBases) throws IOException {
<span class="fc" id="L90">        byte[] spare = new byte[numberOfBases];</span>
        try{
<span class="fc" id="L92">        	IOUtil.blockingRead(in, spare, 0, numberOfBases);</span>
<span class="nc" id="L93">        }catch(EOFException e){</span>
<span class="nc" id="L94">        	throw new IOException(&quot;could not read all the spare confidences&quot;, e);</span>
<span class="fc" id="L95">        }</span>
        
<span class="fc" id="L97">        return ByteBuffer.wrap(spare);</span>
    }

    private short[] parsePeaks(DataInputStream in, int numberOfBases)
            throws IOException {
<span class="fc" id="L102">        short[] peaks = new short[numberOfBases];</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for(int i=0; i&lt;numberOfBases; i++){</span>
<span class="fc" id="L104">            peaks[i]=(short)in.readInt();</span>
        }
<span class="fc" id="L106">        return peaks;</span>
    }

    private byte[][] parseConfidenceData(DataInputStream in,
            int numberOfBases) throws IOException {
<span class="fc" id="L111">        byte[][] probability = new byte[4][numberOfBases];</span>
       
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for(int i=0; i&lt;4; i++){          </span>
           try{
<span class="fc" id="L115">        	IOUtil.blockingRead(in, probability[i], 0, numberOfBases);</span>
<span class="nc" id="L116">           }catch(EOFException e){</span>
<span class="nc" id="L117">        	   throw new IOException(&quot;could not read all the confidences for channel &quot;+ i, e);</span>
<span class="fc" id="L118">           }</span>
          
        }
<span class="fc" id="L121">        return probability;</span>
    }

    
    private NucleotideSequence parseBasecalls(DataInputStream in,
            int numberOfBases) throws IOException {
<span class="fc" id="L127">        byte[] bases = new byte[numberOfBases];</span>
        try{
<span class="fc" id="L129">        	IOUtil.blockingRead(in, bases, 0, numberOfBases);</span>
<span class="nc" id="L130">        }catch(EOFException e){</span>
<span class="nc" id="L131">        	throw new IOException(</span>
                    &quot;could not read all the bases&quot;, e);
<span class="fc" id="L133">        }        </span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for(int i=0; i&lt; numberOfBases; i++){</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if(bases[i]==0){</span>
<span class="nc" id="L136">                bases[i] = (byte)'N';</span>
            }
        }
<span class="fc" id="L139">        return new NucleotideSequenceBuilder(new String(bases,IOUtil.UTF_8))</span>
<span class="fc" id="L140">        				.build();</span>

    }

    @Override
    protected void writeBasesDataToBuffer(ByteBuffer buffer, Chromatogram c,
            int numberOfBases) {
<span class="fc" id="L147">        final ChannelGroup channelGroup = c.getChannelGroup();</span>
<span class="fc" id="L148">        bulkPutPeaks(buffer, c.getPeakSequence());</span>
<span class="fc" id="L149">        bulkPut(buffer,channelGroup.getAChannel().getQualitySequence(), numberOfBases);</span>
<span class="fc" id="L150">        bulkPut(buffer,channelGroup.getCChannel().getQualitySequence(), numberOfBases);</span>
<span class="fc" id="L151">        bulkPut(buffer,channelGroup.getGChannel().getQualitySequence(), numberOfBases);</span>
<span class="fc" id="L152">        bulkPut(buffer,channelGroup.getTChannel().getQualitySequence(), numberOfBases);</span>
<span class="fc" id="L153">        bulkPut(buffer, c.getNucleotideSequence());</span>
<span class="fc" id="L154">        bulkPutWithPadding(buffer, getOptionalSubsitutionConfidence(c), numberOfBases);</span>
<span class="fc" id="L155">        bulkPutWithPadding(buffer, getOptionalInsertionConfidence(c), numberOfBases);</span>
<span class="fc" id="L156">        bulkPutWithPadding(buffer, getOptionalDeletionConfidence(c), numberOfBases);</span>

<span class="fc" id="L158">    }</span>

    private QualitySequence getOptionalSubsitutionConfidence(Chromatogram c){
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    	if(c instanceof ScfChromatogram){</span>
<span class="fc" id="L162">    		return ((ScfChromatogram)c).getSubstitutionConfidence();</span>
    	}
<span class="nc" id="L164">    	return null;</span>
    }
    private QualitySequence getOptionalInsertionConfidence(Chromatogram c){
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    	if(c instanceof ScfChromatogram){</span>
<span class="fc" id="L168">    		return ((ScfChromatogram)c).getInsertionConfidence();</span>
    	}
<span class="nc" id="L170">    	return null;</span>
    }
    private QualitySequence getOptionalDeletionConfidence(Chromatogram c){
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">    	if(c instanceof ScfChromatogram){</span>
<span class="fc" id="L174">    		return ((ScfChromatogram)c).getDeletionConfidence();</span>
    	}
<span class="nc" id="L176">    	return null;</span>
    }
    
    private void bulkPut(ByteBuffer buffer,
            NucleotideSequence basecalls) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">       for(Nucleotide glyph : basecalls){</span>
<span class="fc" id="L182">           buffer.put((byte)glyph.getCharacter().charValue());</span>
<span class="fc" id="L183">       }</span>
        
<span class="fc" id="L185">    }</span>
    private void bulkPutPeaks(ByteBuffer buffer,
            PositionSequence peaks) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">       for(Position glyph : peaks){</span>
<span class="fc" id="L189">           buffer.putInt(glyph.getValue());</span>
<span class="fc" id="L190">       }</span>
        
<span class="fc" id="L192">    }</span>

    private void bulkPutWithPadding(ByteBuffer buffer,
            QualitySequence optionalConfidence, int numberOfBases) {
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">        if(optionalConfidence!=null &amp;&amp; optionalConfidence.getLength()&gt;0){</span>
<span class="fc" id="L197">        	int length = (int)optionalConfidence.getLength();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        	for(PhredQuality qual : optionalConfidence){</span>
<span class="fc" id="L199">        		buffer.put(qual.getQualityScore());</span>
<span class="fc" id="L200">        	}</span>
<span class="fc" id="L201">        	int padding = numberOfBases - length;</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        	for(int i=0; i&lt;padding; i++){</span>
<span class="nc" id="L203">        		buffer.put((byte)0);</span>
        	}
<span class="fc" id="L205">        }else{</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            for(int i=0; i&lt; numberOfBases; i++){</span>
<span class="fc" id="L207">                buffer.put((byte)0);</span>
            }
        }

<span class="fc" id="L211">    }</span>
    private void bulkPut(ByteBuffer buffer, QualitySequence qualities, int expectedSize){
<span class="fc bfc" id="L213" title="All 2 branches covered.">    	for(PhredQuality qual : qualities){</span>
<span class="fc" id="L214">    		buffer.put(qual.getQualityScore());</span>
<span class="fc" id="L215">    	}</span>
<span class="fc" id="L216">    	int padding = expectedSize - (int)qualities.getLength();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">    	for(int i=0; i&lt;padding; i++){</span>
<span class="fc" id="L218">    		 buffer.put((byte)0);</span>
    	}
<span class="fc" id="L220">    }</span>
   

    

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>